<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>./Data/ByteString/Internal/Type.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>   1: </span><a class=annot href="#"><span class=annottext>{VV : GHC.Types.Module | false}</span><span class='hs-comment'>{-# LANGUAGE CPP #-}</span></a>
<span class=hs-linenum>   2: </span><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<span class=hs-linenum>   3: </span>
<span class=hs-linenum>   4: </span><span class='hs-comment'>{-# LANGUAGE BangPatterns #-}</span>
<span class=hs-linenum>   5: </span><span class='hs-comment'>{-# LANGUAGE MagicHash #-}</span>
<span class=hs-linenum>   6: </span><span class='hs-comment'>{-# LANGUAGE PatternSynonyms #-}</span>
<span class=hs-linenum>   7: </span><span class='hs-comment'>{-# LANGUAGE TemplateHaskellQuotes #-}</span>
<span class=hs-linenum>   8: </span><span class='hs-comment'>{-# LANGUAGE TupleSections #-}</span>
<span class=hs-linenum>   9: </span><span class='hs-comment'>{-# LANGUAGE TypeFamilies #-}</span>
<span class=hs-linenum>  10: </span><span class='hs-comment'>{-# LANGUAGE UnboxedTuples #-}</span>
<span class=hs-linenum>  11: </span><span class='hs-comment'>{-# LANGUAGE UnliftedFFITypes #-}</span>
<span class=hs-linenum>  12: </span><span class='hs-comment'>{-# LANGUAGE ViewPatterns #-}</span>
<span class=hs-linenum>  13: </span>
<span class=hs-linenum>  14: </span><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<span class=hs-linenum>  15: </span>
<span class=hs-linenum>  16: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--prune-unsorted"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>  17: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>  18: </span>
<span class=hs-linenum>  19: </span><span class='hs-comment'>-- |</span>
<span class=hs-linenum>  20: </span><span class='hs-comment'>-- Module      : Data.ByteString.Internal.Type</span>
<span class=hs-linenum>  21: </span><span class='hs-comment'>-- Copyright   : (c) Don Stewart 2006-2008</span>
<span class=hs-linenum>  22: </span><span class='hs-comment'>--               (c) Duncan Coutts 2006-2012</span>
<span class=hs-linenum>  23: </span><span class='hs-comment'>-- License     : BSD-style</span>
<span class=hs-linenum>  24: </span><span class='hs-comment'>-- Maintainer  : dons00@gmail.com, duncan@community.haskell.org</span>
<span class=hs-linenum>  25: </span><span class='hs-comment'>-- Stability   : unstable</span>
<span class=hs-linenum>  26: </span><span class='hs-comment'>-- Portability : non-portable</span>
<span class=hs-linenum>  27: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>  28: </span><span class='hs-comment'>-- The 'ByteString' type, its instances, and whatever related</span>
<span class=hs-linenum>  29: </span><span class='hs-comment'>-- utilities the bytestring developers see fit to use internally.</span>
<span class=hs-linenum>  30: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>  31: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.ByteString.Internal.Type</span> <span class='hs-layout'>(</span>
<span class=hs-linenum>  32: </span>
<span class=hs-linenum>  33: </span>        <span class='hs-comment'>-- * The @ByteString@ type and representation</span>
<span class=hs-linenum>  34: </span>        <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>  35: </span>        <span class='hs-layout'>(</span> <span class='hs-conid'>BS</span>
<span class=hs-linenum>  36: </span>        <span class='hs-layout'>,</span> <span class='hs-conid'>PS</span> <span class='hs-comment'>-- backwards compatibility shim</span>
<span class=hs-linenum>  37: </span>        <span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  38: </span>
<span class=hs-linenum>  39: </span>        <span class='hs-conid'>StrictByteString</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  40: </span>
<span class=hs-linenum>  41: </span>        <span class='hs-comment'>-- * Internal indexing</span>
<span class=hs-linenum>  42: </span>        <span class='hs-varid'>findIndexOrLength</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  43: </span>
<span class=hs-linenum>  44: </span>        <span class='hs-comment'>-- * Conversion with lists: packing and unpacking</span>
<span class=hs-linenum>  45: </span>        <span class='hs-varid'>packBytes</span><span class='hs-layout'>,</span> <span class='hs-varid'>packUptoLenBytes</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsafePackLenBytes</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  46: </span>        <span class='hs-varid'>packChars</span><span class='hs-layout'>,</span> <span class='hs-varid'>packUptoLenChars</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsafePackLenChars</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  47: </span>        <span class='hs-varid'>unpackBytes</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackAppendBytesLazy</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackAppendBytesStrict</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  48: </span>        <span class='hs-varid'>unpackChars</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackAppendCharsLazy</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackAppendCharsStrict</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  49: </span>        <span class='hs-varid'>unsafePackAddress</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsafePackLenAddress</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  50: </span>        <span class='hs-varid'>unsafePackLiteral</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsafePackLenLiteral</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  51: </span>
<span class=hs-linenum>  52: </span>        <span class='hs-comment'>-- * Low level imperative construction</span>
<span class=hs-linenum>  53: </span>        <span class='hs-varid'>empty</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  54: </span>        <span class='hs-varid'>createFp</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  55: </span>        <span class='hs-varid'>createFpUptoN</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  56: </span>        <span class='hs-varid'>createFpUptoN'</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  57: </span>        <span class='hs-varid'>createFpAndTrim</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  58: </span>        <span class='hs-varid'>createFpAndTrim'</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  59: </span>        <span class='hs-varid'>unsafeCreateFp</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  60: </span>        <span class='hs-varid'>unsafeCreateFpUptoN</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  61: </span>        <span class='hs-varid'>unsafeCreateFpUptoN'</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  62: </span>        <span class='hs-varid'>create</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  63: </span>        <span class='hs-varid'>createUptoN</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  64: </span>        <span class='hs-varid'>createUptoN'</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  65: </span>        <span class='hs-varid'>createAndTrim</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  66: </span>        <span class='hs-varid'>createAndTrim'</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  67: </span>        <span class='hs-varid'>unsafeCreate</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  68: </span>        <span class='hs-varid'>unsafeCreateUptoN</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  69: </span>        <span class='hs-varid'>unsafeCreateUptoN'</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  70: </span>        <span class='hs-varid'>mallocByteString</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  71: </span>
<span class=hs-linenum>  72: </span>        <span class='hs-comment'>-- * Conversion to and from ForeignPtrs</span>
<span class=hs-linenum>  73: </span>        <span class='hs-varid'>mkDeferredByteString</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  74: </span>        <span class='hs-varid'>fromForeignPtr</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  75: </span>        <span class='hs-varid'>toForeignPtr</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  76: </span>        <span class='hs-varid'>fromForeignPtr0</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  77: </span>        <span class='hs-varid'>toForeignPtr0</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  78: </span>
<span class=hs-linenum>  79: </span>        <span class='hs-comment'>-- * Utilities</span>
<span class=hs-linenum>  80: </span>        <span class='hs-varid'>nullForeignPtr</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  81: </span>        <span class='hs-varid'>peekFp</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  82: </span>        <span class='hs-varid'>pokeFp</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  83: </span>        <span class='hs-varid'>peekFpByteOff</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  84: </span>        <span class='hs-varid'>pokeFpByteOff</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  85: </span>        <span class='hs-varid'>minusForeignPtr</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  86: </span>        <span class='hs-varid'>memcpyFp</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  87: </span>        <span class='hs-varid'>deferForeignPtrAvailability</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  88: </span>        <span class='hs-varid'>unsafeDupablePerformIO</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  89: </span>        <span class='hs-conid'>SizeOverflowException</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  90: </span>        <span class='hs-varid'>overflowError</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  91: </span>        <span class='hs-varid'>checkedAdd</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  92: </span>        <span class='hs-varid'>checkedMultiply</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  93: </span>
<span class=hs-linenum>  94: </span>        <span class='hs-comment'>-- * Standard C Functions</span>
<span class=hs-linenum>  95: </span>        <span class='hs-varid'>c_strlen</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  96: </span>        <span class='hs-varid'>c_free_finalizer</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  97: </span>
<span class=hs-linenum>  98: </span>        <span class='hs-varid'>memchr</span><span class='hs-layout'>,</span>
<span class=hs-linenum>  99: </span>        <span class='hs-varid'>memcmp</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 100: </span><span class='hs-comment'>--        memcpy,</span>
<span class=hs-linenum> 101: </span>        <span class='hs-varid'>memset</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 102: </span>
<span class=hs-linenum> 103: </span>        <span class='hs-comment'>-- * cbits functions</span>
<span class=hs-linenum> 104: </span>        <span class='hs-varid'>c_reverse</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 105: </span>        <span class='hs-varid'>c_intersperse</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 106: </span>        <span class='hs-varid'>c_maximum</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 107: </span>        <span class='hs-varid'>c_minimum</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 108: </span>        <span class='hs-varid'>c_count</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 109: </span>        <span class='hs-varid'>c_count_ba</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 110: </span>        <span class='hs-varid'>c_elem_index</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 111: </span>        <span class='hs-varid'>c_sort</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 112: </span>        <span class='hs-varid'>c_int_dec</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 113: </span>        <span class='hs-varid'>c_int_dec_padded9</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 114: </span>        <span class='hs-varid'>c_uint_dec</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 115: </span>        <span class='hs-varid'>c_uint_hex</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 116: </span>        <span class='hs-varid'>c_long_long_int_dec</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 117: </span>        <span class='hs-varid'>c_long_long_int_dec_padded18</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 118: </span>        <span class='hs-varid'>c_long_long_uint_dec</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 119: </span>        <span class='hs-varid'>c_long_long_uint_hex</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 120: </span>        <span class='hs-varid'>cIsValidUtf8BA</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 121: </span>        <span class='hs-varid'>cIsValidUtf8BASafe</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 122: </span>        <span class='hs-varid'>cIsValidUtf8</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 123: </span>        <span class='hs-varid'>cIsValidUtf8Safe</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 124: </span>
<span class=hs-linenum> 125: </span>        <span class='hs-comment'>-- * Chars</span>
<span class=hs-linenum> 126: </span>        <span class='hs-varid'>w2c</span><span class='hs-layout'>,</span> <span class='hs-varid'>c2w</span><span class='hs-layout'>,</span> <span class='hs-varid'>isSpaceWord8</span><span class='hs-layout'>,</span> <span class='hs-varid'>isSpaceChar8</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 127: </span>
<span class=hs-linenum> 128: </span>        <span class='hs-comment'>-- * Deprecated and unmentionable</span>
<span class=hs-linenum> 129: </span>        <span class='hs-varid'>accursedUnutterablePerformIO</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 130: </span>
<span class=hs-linenum> 131: </span>        <span class='hs-comment'>-- * Exported compatibility shim</span>
<span class=hs-linenum> 132: </span>        <span class='hs-varid'>plusForeignPtr</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 133: </span>        <span class='hs-varid'>unsafeWithForeignPtr</span>
<span class=hs-linenum> 134: </span>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 135: </span>
<span class=hs-linenum> 136: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span><span class='hs-layout'>,</span> <span class='hs-varid'>null</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 137: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.List</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>List</span>
<span class=hs-linenum> 138: </span>
<span class=hs-linenum> 139: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.ForeignPtr</span>       <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span><span class='hs-layout'>,</span> <span class='hs-varid'>withForeignPtr</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 140: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.Ptr</span>
<span class=hs-linenum> 141: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.Storable</span>         <span class='hs-layout'>(</span><span class='hs-conid'>Storable</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 142: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.C.Types</span>
<span class=hs-linenum> 143: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.C.String</span>         <span class='hs-layout'>(</span><span class='hs-conid'>CString</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 144: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.Marshal.Utils</span>
<span class=hs-linenum> 145: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.Marshal.Alloc</span>    <span class='hs-layout'>(</span><span class='hs-varid'>finalizerFree</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 146: </span>
<span class=hs-linenum> 147: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.ByteString.Internal.Pure</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Pure</span>
<span class=hs-linenum> 148: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Bits</span>                <span class='hs-layout'>(</span><span class='hs-varid'>toIntegralSized</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bits</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 149: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Maybe</span>               <span class='hs-layout'>(</span><span class='hs-varid'>fromMaybe</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 150: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span>            <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;$!&gt;</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 151: </span>
<span class=hs-linenum> 152: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.LiquidPtr</span>
<span class=hs-linenum> 153: </span>
<span class=hs-linenum> 154: </span><span class='hs-cpp'>#if !MIN_VERSION_base(4,13,0)</span>
<span class=hs-linenum> 155: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Semigroup</span>           <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 156: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 157: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Semigroup</span>           <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>sconcat</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 158: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List.NonEmpty</span>       <span class='hs-layout'>(</span><span class='hs-conid'>NonEmpty</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conop'>:|</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 159: </span>
<span class=hs-linenum> 160: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.DeepSeq</span>          <span class='hs-layout'>(</span><span class='hs-conid'>NFData</span><span class='hs-layout'>(</span><span class='hs-varid'>rnf</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 161: </span>
<span class=hs-linenum> 162: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.String</span>              <span class='hs-layout'>(</span><span class='hs-conid'>IsString</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 163: </span>
<span class=hs-linenum> 164: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Exception</span>        <span class='hs-layout'>(</span><span class='hs-varid'>assert</span><span class='hs-layout'>,</span> <span class='hs-varid'>throw</span><span class='hs-layout'>,</span> <span class='hs-conid'>Exception</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 165: </span>
<span class=hs-linenum> 166: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Bits</span>                <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>.&amp;.</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 167: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Char</span>                <span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 168: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Word</span>
<span class=hs-linenum> 169: </span>
<span class=hs-linenum> 170: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Data</span>                <span class='hs-layout'>(</span><span class='hs-conid'>Data</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkConstr</span> <span class='hs-layout'>,</span><span class='hs-varid'>mkDataType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Constr</span><span class='hs-layout'>,</span> <span class='hs-conid'>DataType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Fixity</span><span class='hs-layout'>(</span><span class='hs-conid'>Prefix</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>constrIndex</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 171: </span>
<span class=hs-linenum> 172: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Base</span>                 <span class='hs-layout'>(</span><span class='hs-varid'>nullAddr</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span><span class='hs-varid'>realWorld</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span><span class='hs-varid'>unsafeChr</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 173: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Exts</span>                 <span class='hs-layout'>(</span><span class='hs-conid'>IsList</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>minusAddr</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-conid'>ByteArray</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 174: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.CString</span>              <span class='hs-layout'>(</span><span class='hs-varid'>unpackCString</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 175: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Magic</span>                <span class='hs-layout'>(</span><span class='hs-varid'>runRW</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>lazy</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 176: </span>
<span class=hs-linenum> 177: </span><span class='hs-cpp'>#define TIMES_INT_2_AVAILABLE MIN_VERSION_ghc_prim(0,7,0)</span>
<span class=hs-linenum> 178: </span><span class='hs-cpp'>#if TIMES_INT_2_AVAILABLE</span>
<span class=hs-linenum> 179: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim</span>                <span class='hs-layout'>(</span><span class='hs-varid'>timesInt2</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 180: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 181: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim</span>                <span class='hs-layout'>(</span> <span class='hs-varid'>timesWord2</span><span class='hs-cpp'>#</span>
<span class=hs-linenum> 182: </span>                               <span class='hs-layout'>,</span> <span class='hs-varid'>or</span><span class='hs-cpp'>#</span>
<span class=hs-linenum> 183: </span>                               <span class='hs-layout'>,</span> <span class='hs-varid'>uncheckedShiftRL</span><span class='hs-cpp'>#</span>
<span class=hs-linenum> 184: </span>                               <span class='hs-layout'>,</span> <span class='hs-varid'>int2Word</span><span class='hs-cpp'>#</span>
<span class=hs-linenum> 185: </span>                               <span class='hs-layout'>,</span> <span class='hs-varid'>word2Int</span><span class='hs-cpp'>#</span>
<span class=hs-linenum> 186: </span>                               <span class='hs-layout'>)</span>
<span class=hs-linenum> 187: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Bits</span>               <span class='hs-layout'>(</span><span class='hs-varid'>finiteBitSize</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 188: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 189: </span>
<span class=hs-linenum> 190: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.IO</span>                   <span class='hs-layout'>(</span><span class='hs-conid'>IO</span><span class='hs-layout'>(</span><span class='hs-conid'>IO</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 191: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.ForeignPtr</span>           <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span><span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 192: </span><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &lt; 900</span>
<span class=hs-linenum> 193: </span>                                <span class='hs-layout'>,</span> <span class='hs-varid'>newForeignPtr_</span>
<span class=hs-linenum> 194: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 195: </span>                                <span class='hs-layout'>,</span> <span class='hs-varid'>mallocPlainForeignPtrBytes</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 196: </span>
<span class=hs-linenum> 197: </span><span class='hs-cpp'>#if MIN_VERSION_base(4,10,0)</span>
<span class=hs-linenum> 198: </span><span class='hs-comment'>--import GHC.ForeignPtr           (plusForeignPtr)</span>
<span class=hs-linenum> 199: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 200: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim</span>                 <span class='hs-layout'>(</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 201: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 202: </span>
<span class=hs-linenum> 203: </span><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 811</span>
<span class=hs-linenum> 204: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.CString</span>              <span class='hs-layout'>(</span><span class='hs-varid'>cstringLength</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 205: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.ForeignPtr</span>           <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtrContents</span><span class='hs-layout'>(</span><span class='hs-conid'>FinalPtr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 206: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 207: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Ptr</span>                  <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 208: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 209: </span>
<span class=hs-linenum> 210: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types</span>                <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 211: </span>
<span class=hs-linenum> 212: </span><span class='hs-comment'>-- #if MIN_VERSION_base(4,15,0)</span>
<span class=hs-linenum> 213: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.ForeignPtr</span>           <span class='hs-layout'>(</span><span class='hs-varid'>unsafeWithForeignPtr</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 214: </span><span class='hs-comment'>-- #endif</span>
<span class=hs-linenum> 215: </span>
<span class=hs-linenum> 216: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Language.Haskell.TH.Lib</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TH</span>
<span class=hs-linenum> 217: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Language.Haskell.TH.Syntax</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TH</span>
<span class=hs-linenum> 218: </span>
<span class=hs-linenum> 219: </span><span class='hs-cpp'>#if !MIN_VERSION_base(4,15,0)</span>
<span class=hs-linenum> 220: </span><span class='hs-definition'>unsafeWithForeignPtr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<span class=hs-linenum> 221: </span><span class='hs-definition'>unsafeWithForeignPtr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Data.LiquidPtr.withForeignPtr</span>
<span class=hs-linenum> 222: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 223: </span>
<span class=hs-linenum> 224: </span><span class='hs-comment'>-- CFILES stuff is Hugs only</span>
<span class=hs-linenum> 225: </span><span class='hs-comment'>{-# CFILES cbits/fpstring.c #-}</span>
<span class=hs-linenum> 226: </span>
<span class=hs-linenum> 227: </span><span class='hs-cpp'>#if !MIN_VERSION_base(4,10,0)</span>
<span class=hs-linenum> 228: </span><span class='hs-comment'>-- |Advances the given address by the given offset in bytes.</span>
<span class=hs-linenum> 229: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 230: </span><span class='hs-comment'>-- The new 'ForeignPtr' shares the finalizer of the original,</span>
<span class=hs-linenum> 231: </span><span class='hs-comment'>-- equivalent from a finalization standpoint to just creating another</span>
<span class=hs-linenum> 232: </span><span class='hs-comment'>-- reference to the original. That is, the finalizer will not be</span>
<span class=hs-linenum> 233: </span><span class='hs-comment'>-- called before the new 'ForeignPtr' is unreachable, nor will it be</span>
<span class=hs-linenum> 234: </span><span class='hs-comment'>-- called an additional time due to this call, and the finalizer will</span>
<span class=hs-linenum> 235: </span><span class='hs-comment'>-- be called with the same address that it would have had this call</span>
<span class=hs-linenum> 236: </span><span class='hs-comment'>-- not happened, *not* the new address.</span>
<span class=hs-linenum> 237: </span>
<span class=hs-linenum> 238: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>ofForeignPtr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GHC.ForeignPtr.ForeignPtr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>GHC.Ptr.Ptr</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 239: </span>
<span class=hs-linenum> 240: </span>
<span class=hs-linenum> 241: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>FptrEnd</span>  <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>pbase</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-layout'>(</span><span class='hs-varid'>plen</span> <span class='hs-layout'>(</span><span class='hs-varid'>pbase</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 242: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>FPtrSize</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>PtrEnd</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 243: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>FPtrValid</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>pbase</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;</span> <span class='hs-conid'>PtrSize</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 244: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>FPtrValidN</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>pbase</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-conid'>N</span> <span class='hs-varop'>&lt;</span> <span class='hs-conid'>PtrSize</span> <span class='hs-layout'>(</span><span class='hs-varid'>ofForeignPtr</span> <span class='hs-conid'>P</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 245: </span>
<span class=hs-linenum> 246: </span><span class='hs-definition'>plusForeignPtr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>b</span>
<span class=hs-linenum> 247: </span><span class='hs-definition'>plusForeignPtr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>addr</span> <span class='hs-varid'>guts</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>offset</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-layout'>(</span><span class='hs-varid'>plusAddr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>addr</span> <span class='hs-varid'>offset</span><span class='hs-layout'>)</span> <span class='hs-varid'>guts</span>
<span class=hs-linenum> 248: </span><span class='hs-comment'>{-# INLINE [0] plusForeignPtr #-}</span>
<span class=hs-linenum> 249: </span><span class='hs-comment'>{-# RULES
"ByteString plusForeignPtr/0" forall fp .
   plusForeignPtr fp 0 = fp
 #-}</span>
<span class=hs-linenum> 253: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 254: </span>
<span class=hs-linenum> 255: </span><span class='hs-definition'>minusForeignPtr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum> 256: </span><a class=annot href="#"><span class=annottext>forall a b .
(GHC.ForeignPtr.ForeignPtr a) -&gt; (GHC.ForeignPtr.ForeignPtr b) -&gt; GHC.Types.Int</span><span class='hs-definition'>minusForeignPtr</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>addr1</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>addr2</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 257: </span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Prim.Int#</span><span class='hs-conid'>I</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>GHC.Prim.Int#</span><span class='hs-layout'>(</span></a><span class='hs-varid'>minusAddr</span><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr1}</span><span class='hs-varid'>addr1</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr2}</span><span class='hs-varid'>addr2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 258: </span>
<span class=hs-linenum> 259: </span><span class='hs-definition'>peekFp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 260: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
(GHC.ForeignPtr.ForeignPtr a) -&gt; (GHC.Types.IO a)</span><span class='hs-definition'>peekFp</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr a)</span><span class='hs-varid'>fp</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafeWithForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr a) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a) -&gt; (GHC.Types.IO a)</span><span class='hs-conid'>Data.LiquidPtr.peek</span></a> 
<span class=hs-linenum> 261: </span>
<span class=hs-linenum> 262: </span><span class='hs-definition'>pokeFp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum> 263: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
(GHC.ForeignPtr.ForeignPtr a) -&gt; a -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>pokeFp</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr a)</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>val</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr a) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>unsafeWithForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr a) | v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a)</span><span class='hs-varid'>p</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Data.LiquidPtr.poke</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | v == p}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == val}</span><span class='hs-varid'>val</span></a>
<span class=hs-linenum> 264: </span>
<span class=hs-linenum> 265: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>peekFpByteOff</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foreign.Storable.Storable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>GHC.ForeignPtr.ForeignPtr</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{n:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| (pbase (ofForeignPtr p)) &lt;= (ofForeignPtr p) &amp;&amp; n &lt; PtrSize (ofForeignPtr p)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 266: </span><span class='hs-definition'>peekFpByteOff</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 267: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
x2:(GHC.ForeignPtr.ForeignPtr a) -&gt; {VV : GHC.Types.Int | VV &gt;= 0
                                                          &amp;&amp; VV &lt; (pbase (ofForeignPtr x2) + plen (pbase (ofForeignPtr x2))) - ofForeignPtr x2
                                                          &amp;&amp; pbase (ofForeignPtr x2) &lt;= ofForeignPtr x2} -&gt; (GHC.Types.IO a)</span><span class='hs-definition'>peekFpByteOff</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr a)</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | VV &gt;= 0
                      &amp;&amp; VV &lt; (pbase (ofForeignPtr fp) + plen (pbase (ofForeignPtr fp))) - ofForeignPtr fp
                      &amp;&amp; pbase (ofForeignPtr fp) &lt;= ofForeignPtr fp}</span><span class='hs-varid'>off</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>({v : (GHC.Ptr.Ptr a) | v == ofForeignPtr fp
                        &amp;&amp; v == pbase v
                        &amp;&amp; plen v == fplen fp} -&gt; (GHC.Types.IO a)) -&gt; (GHC.Types.IO a)</span><span class='hs-conid'>Data.LiquidPtr.withForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr a) | v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a)</span><span class='hs-varid'>p</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 268: </span>  <span class='hs-conid'>Data.LiquidPtr.peekByteOff</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | v == p}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == off
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; v &lt; (pbase (ofForeignPtr fp) + plen (pbase (ofForeignPtr fp))) - ofForeignPtr fp
                     &amp;&amp; pbase (ofForeignPtr fp) &lt;= ofForeignPtr fp}</span><span class='hs-varid'>off</span></a>
<span class=hs-linenum> 269: </span>
<span class=hs-linenum> 270: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>pokeFpByteOff</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Foreign.Storable.Storable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>GHC.ForeignPtr.ForeignPtr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{n:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| (pbase (ofForeignPtr p)) &lt;= (ofForeignPtr p) &amp;&amp; n &lt; PtrSize (ofForeignPtr p)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 271: </span><span class='hs-definition'>pokeFpByteOff</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum> 272: </span><a class=annot href="#"><span class=annottext>forall a b .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
x2:(GHC.ForeignPtr.ForeignPtr b) -&gt; {VV : GHC.Types.Int | VV &gt;= 0
                                                          &amp;&amp; VV &lt; (pbase (ofForeignPtr x2) + plen (pbase (ofForeignPtr x2))) - ofForeignPtr x2
                                                          &amp;&amp; pbase (ofForeignPtr x2) &lt;= ofForeignPtr x2} -&gt; a -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>pokeFpByteOff</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr a)</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | VV &gt;= 0
                      &amp;&amp; VV &lt; (pbase (ofForeignPtr fp) + plen (pbase (ofForeignPtr fp))) - ofForeignPtr fp
                      &amp;&amp; pbase (ofForeignPtr fp) &lt;= ofForeignPtr fp}</span><span class='hs-varid'>off</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>val</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>({v : (GHC.Ptr.Ptr a) | v == ofForeignPtr fp
                        &amp;&amp; v == pbase v
                        &amp;&amp; plen v == fplen fp} -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO ())</span><span class='hs-conid'>Data.LiquidPtr.withForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr a) | v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a)</span><span class='hs-varid'>p</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 273: </span>  <span class='hs-conid'>Data.LiquidPtr.pokeByteOff</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | v == p}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == off
                     &amp;&amp; v &gt;= 0
                     &amp;&amp; v &lt; (pbase (ofForeignPtr fp) + plen (pbase (ofForeignPtr fp))) - ofForeignPtr fp
                     &amp;&amp; pbase (ofForeignPtr fp) &lt;= ofForeignPtr fp}</span><span class='hs-varid'>off</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == val}</span><span class='hs-varid'>val</span></a>
<span class=hs-linenum> 274: </span>
<span class=hs-linenum> 275: </span><span class='hs-comment'>-- | Most operations on a 'ByteString' need to read from the buffer</span>
<span class=hs-linenum> 276: </span><span class='hs-comment'>-- given by its @ForeignPtr Word8@ field.  But since most operations</span>
<span class=hs-linenum> 277: </span><span class='hs-comment'>-- on @ByteString@ are (nominally) pure, their implementations cannot</span>
<span class=hs-linenum> 278: </span><span class='hs-comment'>-- see the IO state thread that was used to initialize the contents of</span>
<span class=hs-linenum> 279: </span><span class='hs-comment'>-- that buffer.  This means that under some circumstances, these</span>
<span class=hs-linenum> 280: </span><span class='hs-comment'>-- buffer-reads may be executed before the writes used to initialize</span>
<span class=hs-linenum> 281: </span><span class='hs-comment'>-- the buffer are executed, with unpredictable results.</span>
<span class=hs-linenum> 282: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 283: </span><span class='hs-comment'>-- 'deferForeignPtrAvailability' exists to help solve this problem.</span>
<span class=hs-linenum> 284: </span><span class='hs-comment'>-- At runtime, a call @'deferForeignPtrAvailability' x@ is equivalent</span>
<span class=hs-linenum> 285: </span><span class='hs-comment'>-- to @pure $! x@, but the former is more opaque to the simplifier, so</span>
<span class=hs-linenum> 286: </span><span class='hs-comment'>-- that reads from the pointer in its result cannot be executed until</span>
<span class=hs-linenum> 287: </span><span class='hs-comment'>-- the @'deferForeignPtrAvailability' x@ call is complete.</span>
<span class=hs-linenum> 288: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 289: </span><span class='hs-comment'>-- The opaque bits evaporate during CorePrep, so using</span>
<span class=hs-linenum> 290: </span><span class='hs-comment'>-- 'deferForeignPtrAvailability' incurs no direct overhead.</span>
<span class=hs-linenum> 291: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 292: </span><span class='hs-comment'>-- @since 0.11.5.0</span>
<span class=hs-linenum> 293: </span><span class='hs-definition'>deferForeignPtrAvailability</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 294: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.ForeignPtr.ForeignPtr a) -&gt; (GHC.Types.IO (GHC.ForeignPtr.ForeignPtr a))</span><span class='hs-definition'>deferForeignPtrAvailability</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>addr0</span><span class='hs-cpp'>#</span> <span class='hs-varid'>guts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Prim.State# GHC.Prim.RealWorld)</span><span class='hs-varid'>s0</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 295: </span>  <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(('GHC.Types.TupleRep ('[] GHC.Types.RuntimeRep)), 'GHC.Types.AddrRep, (GHC.Prim.State# GHC.Prim.RealWorld), GHC.Prim.Addr#)</span><span class='hs-varid'>lazy</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      ((GHC.Prim.State# GHC.Prim.RealWorld) -&gt; b) -&gt; b | VV == runRW#}</span><span class='hs-varid'>runRW</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>(('GHC.Types.TupleRep ('[] GHC.Types.RuntimeRep)), 'GHC.Types.AddrRep, (GHC.Prim.State# GHC.Prim.RealWorld), GHC.Prim.Addr#)</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Prim.State# GHC.Prim.RealWorld) | v == s0}</span><span class='hs-varid'>s0</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr0#}</span><span class='hs-varid'>addr0</span></a><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<span class=hs-linenum> 296: </span>    <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>addr1</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : forall a b c d . c -&gt; d -&gt; (a, b, c, d) | VV == (#,#)}</span><span class='hs-layout'>(</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Prim.State# GHC.Prim.RealWorld) | v == s1}</span><span class='hs-varid'>s1</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr a)</span><span class='hs-conid'>ForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr1#}</span><span class='hs-varid'>addr1</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.ForeignPtr.ForeignPtrContents | v == guts}</span><span class='hs-varid'>guts</span></a> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 297: </span>
<span class=hs-linenum> 298: </span><span class='hs-comment'>-- | Variant of 'fromForeignPtr0' that calls 'deferForeignPtrAvailability'</span>
<span class=hs-linenum> 299: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 300: </span><span class='hs-comment'>-- @since 0.11.5.0</span>
<span class=hs-linenum> 301: </span><span class='hs-definition'>mkDeferredByteString</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 302: </span><a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>mkDeferredByteString</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 303: </span>  <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>deferredFp</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8))</span><span class='hs-varid'>deferForeignPtrAvailability</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a>
<span class=hs-linenum> 304: </span>  <a class=annot href="#"><span class=annottext>forall a . a -&gt; (GHC.Types.IO a)</span><span class='hs-varid'>pure</span></a> <span class='hs-varop'>$!</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-conid'>BS</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == deferredFp}</span><span class='hs-varid'>deferredFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 305: </span>
<span class=hs-linenum> 306: </span><span class='hs-definition'>unsafeDupablePerformIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum> 307: </span><span class='hs-comment'>-- Why does this exist? In base-4.15.1.0 until at least base-4.18.0.0,</span>
<span class=hs-linenum> 308: </span><span class='hs-comment'>-- the version of unsafeDupablePerformIO in base prevents unboxing of</span>
<span class=hs-linenum> 309: </span><span class='hs-comment'>-- its results with an opaque call to GHC.Exts.lazy, for reasons described</span>
<span class=hs-linenum> 310: </span><span class='hs-comment'>-- in Note [unsafePerformIO and strictness] in GHC.IO.Unsafe. (See</span>
<span class=hs-linenum> 311: </span><span class='hs-comment'>-- https://hackage.haskell.org/package/base-4.18.0.0/docs/src/GHC.IO.Unsafe.html#line-30 .)</span>
<span class=hs-linenum> 312: </span><span class='hs-comment'>-- Even if we accept the (very questionable) premise that the sort of</span>
<span class=hs-linenum> 313: </span><span class='hs-comment'>-- function described in that note should work, we expect no such</span>
<span class=hs-linenum> 314: </span><span class='hs-comment'>-- calls to be made in the context of bytestring.  (And we really want</span>
<span class=hs-linenum> 315: </span><span class='hs-comment'>-- unboxing!)</span>
<span class=hs-linenum> 316: </span><a class=annot href="#"><span class=annottext>forall a . (GHC.Types.IO a) -&gt; a</span><span class='hs-definition'>unsafeDupablePerformIO</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>act</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(('GHC.Types.TupleRep ('[] GHC.Types.RuntimeRep)), ('GHC.Types.BoxedRep 'GHC.Types.Lifted), (GHC.Prim.State# GHC.Prim.RealWorld), a)</span><span class='hs-varid'>runRW</span></a><span class='hs-cpp'>#</span> <span class='hs-varid'>act</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == res}</span><span class='hs-varid'>res</span></a>
<span class=hs-linenum> 317: </span>
<span class=hs-linenum> 318: </span>
<span class=hs-linenum> 319: </span>
<span class=hs-linenum> 320: </span><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<span class=hs-linenum> 321: </span>
<span class=hs-linenum> 322: </span><span class='hs-comment'>-- | A space-efficient representation of a 'Word8' vector, supporting many</span>
<span class=hs-linenum> 323: </span><span class='hs-comment'>-- efficient operations.</span>
<span class=hs-linenum> 324: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 325: </span><span class='hs-comment'>-- A 'ByteString' contains 8-bit bytes, or by using the operations from</span>
<span class=hs-linenum> 326: </span><span class='hs-comment'>-- "Data.ByteString.Char8" it can be interpreted as containing 8-bit</span>
<span class=hs-linenum> 327: </span><span class='hs-comment'>-- characters.</span>
<span class=hs-linenum> 328: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 329: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BS</span> <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- payload</span>
<span class=hs-linenum> 330: </span>                     <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>                <span class='hs-comment'>-- length</span>
<span class=hs-linenum> 331: </span>                     <span class='hs-comment'>-- ^ @since 0.11.0.0</span>
<span class=hs-linenum> 332: </span>
<span class=hs-linenum> 333: </span><span class='hs-comment'>-- | Type synonym for the strict flavour of 'ByteString'.</span>
<span class=hs-linenum> 334: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 335: </span><span class='hs-comment'>-- @since 0.11.2.0</span>
<span class=hs-linenum> 336: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>StrictByteString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 337: </span>
<span class=hs-linenum> 338: </span><span class='hs-comment'>-- |</span>
<span class=hs-linenum> 339: </span><span class='hs-comment'>-- @'PS' foreignPtr offset length@ represents a 'ByteString' with data</span>
<span class=hs-linenum> 340: </span><span class='hs-comment'>-- backed by a given @foreignPtr@, starting at a given @offset@ in bytes</span>
<span class=hs-linenum> 341: </span><span class='hs-comment'>-- and of a specified @length@.</span>
<span class=hs-linenum> 342: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 343: </span><span class='hs-comment'>-- This pattern is used to emulate the legacy 'ByteString' data</span>
<span class=hs-linenum> 344: </span><span class='hs-comment'>-- constructor, so that pre-existing code generally doesn't need to</span>
<span class=hs-linenum> 345: </span><span class='hs-comment'>-- change to benefit from the simplified 'BS' constructor and can</span>
<span class=hs-linenum> 346: </span><span class='hs-comment'>-- continue to function unchanged.</span>
<span class=hs-linenum> 347: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 348: </span><span class='hs-comment'>-- /Note:/ Matching with this constructor will always be given a 0 offset,</span>
<span class=hs-linenum> 349: </span><span class='hs-comment'>-- as the base will be manipulated by 'plusForeignPtr' instead.</span>
<span class=hs-linenum> 350: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 351: </span><span class='hs-definition'>pattern</span> <span class='hs-conid'>PS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 352: </span><span class='hs-definition'>pattern</span> <span class='hs-conid'>PS</span> <span class='hs-varid'>fp</span> <span class='hs-varid'>zero</span> <span class='hs-varid'>len</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 0}</span><span class='hs-conid'>BS</span></a> <span class='hs-varid'>fp</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>zero</span></a><span class='hs-layout'>,</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 353: </span>  <span class='hs-conid'>PS</span> <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false}</span><span class='hs-varid'>o</span></a> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false}</span><span class='hs-varid'>len</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-conid'>BS</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen fp - o
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>plusForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>o</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 354: </span><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 802</span>
<span class=hs-linenum> 355: </span><span class='hs-comment'>{-# COMPLETE PS #-}</span>
<span class=hs-linenum> 356: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 357: </span>
<span class=hs-linenum> 358: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Eq</span>  <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 359: </span>    <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq</span>
<span class=hs-linenum> 360: </span>
<span class=hs-linenum> 361: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 362: </span>    <span class='hs-varid'>compare</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compareBytes</span>
<span class=hs-linenum> 363: </span>
<span class=hs-linenum> 364: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(GHC.Base.Semigroup Data.ByteString.Internal.Type.ByteString)</span><span class='hs-conid'>Semigroup</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 365: </span>    <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false} -&gt; {v : Data.ByteString.Internal.Type.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>append</span>
<span class=hs-linenum> 366: </span>    <a class=annot href="#"><span class=annottext>{VV : (GHC.Base.NonEmpty {VV : Data.ByteString.Internal.Type.ByteString | false}) | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>sconcat</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:|</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>concat</span></a> <a class=annot href="#"><span class=annottext>{v : [Data.ByteString.Internal.Type.ByteString] | head v == b
                                                  &amp;&amp; len v == 1 + len bs
                                                  &amp;&amp; tail v == bs}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>b</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}] | v == bs
                                                                &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 367: </span>    <span class='hs-comment'>{-# INLINE stimes #-}</span>
<span class=hs-linenum> 368: </span>    <a class=annot href="#"><span class=annottext>forall a .
(GHC.Real.Integral&lt;[]&gt; a) =&gt;
{VV : a | false} -&gt; {v : Data.ByteString.Internal.Type.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>stimes</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesPolymorphic</span>
<span class=hs-linenum> 369: </span>
<span class=hs-linenum> 370: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(GHC.Base.Monoid Data.ByteString.Internal.Type.ByteString)</span><span class='hs-conid'>Monoid</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 371: </span>    <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == empty}</span><span class='hs-varid'>mempty</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>empty</span>
<span class=hs-linenum> 372: </span>    <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>mappend</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 373: </span>    <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>mconcat</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span>
<span class=hs-linenum> 374: </span>
<span class=hs-linenum> 375: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Control.DeepSeq.NFData Data.ByteString.Internal.Type.ByteString)</span><span class='hs-conid'>NFData</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 376: </span>    <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; ()</span><span class='hs-varid'>rnf</span></a> <span class='hs-conid'>BS</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : () | v == ()}</span><span class='hs-conid'>()</span></a>
<span class=hs-linenum> 377: </span>
<span class=hs-linenum> 378: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 379: </span>    <span class='hs-varid'>showsPrec</span> <span class='hs-varid'>p</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showsPrec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>unpackChars</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span>
<span class=hs-linenum> 380: </span>
<span class=hs-linenum> 381: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Read</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 382: </span>    <span class='hs-varid'>readsPrec</span> <span class='hs-varid'>p</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>packChars</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readsPrec</span> <span class='hs-varid'>p</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 383: </span>
<span class=hs-linenum> 384: </span><span class='hs-comment'>-- | @since 0.10.12.0</span>
<span class=hs-linenum> 385: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(GHC.Exts.IsList Data.ByteString.Internal.Type.ByteString)</span><span class='hs-conid'>IsList</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 386: </span>  <span class='hs-keyword'>type</span> <span class='hs-conid'>Item</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Word8</span>
<span class=hs-linenum> 387: </span>  <a class=annot href="#"><span class=annottext>[(GHC.Exts.Item Data.ByteString.Internal.Type.ByteString)] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>fromList</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>packBytes</span>
<span class=hs-linenum> 388: </span>  <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [(GHC.Exts.Item Data.ByteString.Internal.Type.ByteString)]</span><span class='hs-varid'>toList</span></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackBytes</span>
<span class=hs-linenum> 389: </span>
<span class=hs-linenum> 390: </span><span class='hs-comment'>-- | Beware: 'fromString' truncates multi-byte characters to octets.</span>
<span class=hs-linenum> 391: </span><span class='hs-comment'>-- e.g. "" becomes 6knh~Qn</span>
<span class=hs-linenum> 392: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.String.IsString Data.ByteString.Internal.Type.ByteString)</span><span class='hs-conid'>IsString</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 393: </span>    <span class='hs-comment'>{-# INLINE fromString #-}</span>
<span class=hs-linenum> 394: </span>    <a class=annot href="#"><span class=annottext>[GHC.Types.Char] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>fromString</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>packChars</span>
<span class=hs-linenum> 395: </span>
<span class=hs-linenum> 396: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>forall a .
(GHC.Base.MonadPlus&lt;[]&gt; a) =&gt;
(forall d .
 (Data.Data.Data&lt;[]&gt; d) =&gt;
 d -&gt; a d) -&gt; Data.ByteString.Internal.Type.ByteString -&gt; a Data.ByteString.Internal.Type.ByteString</span><span class='hs-conid'>Data</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 397: </span>  <a class=annot href="#"><span class=annottext>forall a .
(forall d b .
 (Data.Data.Data&lt;[]&gt; d) =&gt;
 a (d -&gt; b) -&gt; d -&gt; a b) -&gt; (forall g .
                             g -&gt; a g) -&gt; Data.ByteString.Internal.Type.ByteString -&gt; a Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>gfoldl</span></a> <a class=annot href="#"><span class=annottext>forall a b . (Data.Data.Data&lt;[]&gt; a) =&gt; c (a -&gt; b) -&gt; a -&gt; c b</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>forall a . a -&gt; b a</span><span class='hs-varid'>z</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>txt</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a [GHC.Word.Word8] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>z</span></a> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>packBytes</span></a> <span class='hs-varop'>`f`</span> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>unpackBytes</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == txt}</span><span class='hs-varid'>txt</span></a>
<span class=hs-linenum> 398: </span>  <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; {v : Data.Data.Constr | false}</span><span class='hs-varid'>toConstr</span></a> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>packConstr</span>
<span class=hs-linenum> 399: </span>  <a class=annot href="#"><span class=annottext>forall a .
(forall b r .
 (Data.Data.Data&lt;[]&gt; b) =&gt;
 a (b -&gt; r) -&gt; a r) -&gt; (forall r .
                        r -&gt; a r) -&gt; Data.Data.Constr -&gt; a Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>gunfold</span></a> <a class=annot href="#"><span class=annottext>forall a b . (Data.Data.Data&lt;[]&gt; a) =&gt; c (a -&gt; b) -&gt; c b</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>forall a . a -&gt; b a</span><span class='hs-varid'>z</span></a> <a class=annot href="#"><span class=annottext>Data.Data.Constr</span><span class='hs-varid'>c</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>constrIndex</span></a> <a class=annot href="#"><span class=annottext>{v : Data.Data.Constr | v == c}</span><span class='hs-varid'>c</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum> 400: </span>    <span class='hs-num'>1</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : (Data.Data.Data [GHC.Word.Word8]) | v == $dData_ajnM}</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>a [GHC.Word.Word8] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varid'>z</span> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>packBytes</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 401: </span>    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Classes.IP [GHC.Types.Char] GHC.Stack.Types.CallStack) | v == $dIP_ajnQ}</span><span class='hs-varid'>error</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"gunfold: unexpected constructor of strict ByteString"</span></a>
<span class=hs-linenum> 402: </span>  <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; {v : Data.Data.DataType | false}</span><span class='hs-varid'>dataTypeOf</span></a> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>byteStringDataType</span>
<span class=hs-linenum> 403: </span>
<span class=hs-linenum> 404: </span><span class='hs-definition'>packConstr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Constr</span>
<span class=hs-linenum> 405: </span><a class=annot href="#"><span class=annottext>{VV : Data.Data.Constr | false}</span><span class='hs-definition'>packConstr</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConstr</span> <a class=annot href="#"><span class=annottext>{VV : Data.Data.DataType | false}</span><span class='hs-varid'>byteStringDataType</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"pack"</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a> <a class=annot href="#"><span class=annottext>{v : Data.Data.Fixity | v == Prefix}</span><span class='hs-conid'>Prefix</span></a>
<span class=hs-linenum> 406: </span>
<span class=hs-linenum> 407: </span><span class='hs-definition'>byteStringDataType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataType</span>
<span class=hs-linenum> 408: </span><a class=annot href="#"><span class=annottext>{VV : Data.Data.DataType | false}</span><span class='hs-definition'>byteStringDataType</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDataType</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Data.ByteString.ByteString"</span></a> <a class=annot href="#"><span class=annottext>{v : [Data.Data.Constr] | head v == packConstr}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{VV : Data.Data.Constr | false}</span><span class='hs-varid'>packConstr</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 409: </span>
<span class=hs-linenum> 410: </span><span class='hs-comment'>-- | @since 0.11.2.0</span>
<span class=hs-linenum> 411: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Language.Haskell.TH.Syntax.Lift ('GHC.Types.BoxedRep 'GHC.Types.Lifted) Data.ByteString.Internal.Type.ByteString)</span><span class='hs-conid'>TH.Lift</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 412: </span><span class='hs-cpp'>#if MIN_VERSION_template_haskell(2,16,0)</span>
<span class=hs-linenum> 413: </span>  <a class=annot href="#"><span class=annottext>forall a .
(Language.Haskell.TH.Syntax.Quote&lt;[]&gt; a) =&gt;
Data.ByteString.Internal.Type.ByteString -&gt; a Language.Haskell.TH.Syntax.Exp</span><span class='hs-varid'>lift</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>ptr</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a Language.Haskell.TH.Syntax.Exp</span><span class='hs-keyglyph'>[</span></a><span class='hs-keyglyph'>|</span> <span class='hs-varid'>unsafePackLenLiteral</span> <span class='hs-keyglyph'>|</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 414: </span>    <span class='hs-varop'>`TH.appE`</span> <a class=annot href="#"><span class=annottext>a Language.Haskell.TH.Syntax.Exp</span><span class='hs-conid'>TH.litE</span></a> <a class=annot href="#"><span class=annottext>Language.Haskell.TH.Syntax.Lit</span><span class='hs-layout'>(</span></a><span class='hs-conid'>TH.integerL</span> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == len}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>fromIntegral</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 415: </span>    <span class='hs-varop'>`TH.appE`</span> <a class=annot href="#"><span class=annottext>a Language.Haskell.TH.Syntax.Exp</span><span class='hs-conid'>TH.litE</span></a> <a class=annot href="#"><span class=annottext>Language.Haskell.TH.Syntax.Lit</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>Language.Haskell.TH.Syntax.Lit</span><span class='hs-conid'>TH.BytesPrimL</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>Language.Haskell.TH.Syntax.Bytes</span><span class='hs-conid'>TH.Bytes</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == ptr}</span><span class='hs-varid'>ptr</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Word | v == len}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>fromIntegral</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 416: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 417: </span>  <span class='hs-varid'>lift</span> <span class='hs-varid'>bs</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>unsafePackLenLiteral</span> <span class='hs-keyglyph'>|</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 418: </span>    <span class='hs-varop'>`TH.appE`</span> <span class='hs-conid'>TH.litE</span> <span class='hs-layout'>(</span><span class='hs-conid'>TH.integerL</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromIntegral</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 419: </span>    <span class='hs-varop'>`TH.appE`</span> <span class='hs-conid'>TH.litE</span> <span class='hs-layout'>(</span><span class='hs-conid'>TH.StringPrimL</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unpackBytes</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 420: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 421: </span>
<span class=hs-linenum> 422: </span><span class='hs-cpp'>#if MIN_VERSION_template_haskell(2,17,0)</span>
<span class=hs-linenum> 423: </span>  <a class=annot href="#"><span class=annottext>forall a .
(Language.Haskell.TH.Syntax.Quote&lt;[]&gt; a) =&gt;
Data.ByteString.Internal.Type.ByteString -&gt; (Language.Haskell.TH.Syntax.Code ('GHC.Types.BoxedRep 'GHC.Types.Lifted) a Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>liftTyped</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a Language.Haskell.TH.Syntax.Exp -&gt; (Language.Haskell.TH.Syntax.Code ('GHC.Types.BoxedRep 'GHC.Types.Lifted) a Data.ByteString.Internal.Type.ByteString)</span><span class='hs-conid'>TH.unsafeCodeCoerce</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; a Language.Haskell.TH.Syntax.Exp</span><span class='hs-conid'>TH.lift</span></a>
<span class=hs-linenum> 424: </span><span class='hs-cpp'>#elif MIN_VERSION_template_haskell(2,16,0)</span>
<span class=hs-linenum> 425: </span>  <span class='hs-varid'>liftTyped</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TH.unsafeTExpCoerce</span> <span class='hs-varop'>.</span> <span class='hs-conid'>TH.lift</span>
<span class=hs-linenum> 426: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 427: </span>
<span class=hs-linenum> 428: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum> 429: </span><span class='hs-comment'>-- Internal indexing</span>
<span class=hs-linenum> 430: </span>
<span class=hs-linenum> 431: </span><span class='hs-comment'>-- | 'findIndexOrLength' is a variant of findIndex, that returns the length</span>
<span class=hs-linenum> 432: </span><span class='hs-comment'>-- of the string if no element is found, rather than Nothing.</span>
<span class=hs-linenum> 433: </span><span class='hs-definition'>findIndexOrLength</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum> 434: </span><a class=annot href="#"><span class=annottext>(GHC.Word.Word8 -&gt; GHC.Types.Bool) -&gt; Data.ByteString.Internal.Type.ByteString -&gt; GHC.Types.Int</span><span class='hs-definition'>findIndexOrLength</span></a> <a class=annot href="#"><span class=annottext>GHC.Word.Word8 -&gt; GHC.Types.Bool</span><span class='hs-varid'>k</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>x</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 435: </span>    <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Types.Int) -&gt; GHC.Types.Int</span><span class='hs-varid'>accursedUnutterablePerformIO</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == x}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum> 436: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 437: </span>    <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>g</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false} -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>
<span class=hs-linenum> 438: </span>      <span class='hs-keyword'>where</span>
<span class=hs-linenum> 439: </span>        <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false} -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>go</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum> 440: </span>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <a class=annot href="#"><span class=annottext>GHC.Word.Word8</span><span class='hs-varid'>w</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Word.Word8)</span><span class='hs-varid'>peekFp</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a>
<span class=hs-linenum> 441: </span>                               <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Word.Word8 | v == w}</span><span class='hs-varid'>w</span></a>
<span class=hs-linenum> 442: </span>                                 <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a>
<span class=hs-linenum> 443: </span>                                 <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false} -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a><span class='hs-varop'>+</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 444: </span><span class='hs-comment'>{-# INLINE findIndexOrLength #-}</span>
<span class=hs-linenum> 445: </span>
<span class=hs-linenum> 446: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum> 447: </span><span class='hs-comment'>-- Packing and unpacking from lists</span>
<span class=hs-linenum> 448: </span>
<span class=hs-linenum> 449: </span><span class='hs-definition'>packBytes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 450: </span><a class=annot href="#"><span class=annottext>[GHC.Word.Word8] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>packBytes</span></a> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>ws</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePackLenBytes</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len ws
                     &amp;&amp; v &gt;= 0}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>List.length</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == ws
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>ws</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == ws
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>ws</span></a>
<span class=hs-linenum> 451: </span>
<span class=hs-linenum> 452: </span><span class='hs-definition'>packChars</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 453: </span><a class=annot href="#"><span class=annottext>[GHC.Types.Char] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>packChars</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>cs</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePackLenChars</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len cs
                     &amp;&amp; v &gt;= 0}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>List.length</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == cs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == cs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum> 454: </span>
<span class=hs-linenum> 455: </span><span class='hs-comment'>{-# INLINE [0] packChars #-}</span>
<span class=hs-linenum> 456: </span>
<span class=hs-linenum> 457: </span><span class='hs-comment'>{-# RULES
"ByteString packChars/packAddress" forall s .
   packChars (unpackCString# s) = unsafePackLiteral s
 #-}</span>
<span class=hs-linenum> 461: </span>
<span class=hs-linenum> 462: </span><span class='hs-definition'>unsafePackLenBytes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 463: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Word.Word8] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>unsafePackLenBytes</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>xs0</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 464: </span>    <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>unsafeCreateFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == xs0
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs0</span></a>
<span class=hs-linenum> 465: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 466: </span>    <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr a) | false} -&gt; {VV : [{VV : a | false}]&lt;\_ VV -&gt; {VV : a | false}&gt; | false} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>go</span></a> <span class='hs-varop'>!</span><span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : () | v == ()}</span><span class='hs-conid'>()</span></a>
<span class=hs-linenum> 467: </span>    <span class='hs-varid'>go</span> <span class='hs-varop'>!</span><span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>pokeFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr a) | false}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{VV : a | false}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr a) | 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr a) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [{VV : a | false}]&lt;\_ VV -&gt; {VV : a | false}&gt; | v == xs
                                                     &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum> 468: </span>
<span class=hs-linenum> 469: </span><span class='hs-definition'>unsafePackLenChars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 470: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Types.Char] -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>unsafePackLenChars</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>cs0</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 471: </span>    <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>unsafeCreateFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == cs0
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs0</span></a>
<span class=hs-linenum> 472: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 473: </span>    <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; {VV : [{VV : GHC.Types.Char | false}]&lt;\_ VV -&gt; {VV : GHC.Types.Char | false}&gt; | false} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>go</span></a> <span class='hs-varop'>!</span><span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : () | v == ()}</span><span class='hs-conid'>()</span></a>
<span class=hs-linenum> 474: </span>    <span class='hs-varid'>go</span> <span class='hs-varop'>!</span><span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>pokeFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>GHC.Word.Word8</span><span class='hs-layout'>(</span></a><span class='hs-varid'>c2w</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Char | false}</span><span class='hs-varid'>c</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Types.Char | false}]&lt;\_ VV -&gt; {v : GHC.Types.Char | false}&gt; | v == cs
                                                                             &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum> 475: </span>
<span class=hs-linenum> 476: </span>
<span class=hs-linenum> 477: </span><span class='hs-comment'>-- | /O(n)/ Pack a null-terminated sequence of bytes, pointed to by an</span>
<span class=hs-linenum> 478: </span><span class='hs-comment'>-- Addr\# (an arbitrary machine address assumed to point outside the</span>
<span class=hs-linenum> 479: </span><span class='hs-comment'>-- garbage-collected heap) into a @ByteString@. A much faster way to</span>
<span class=hs-linenum> 480: </span><span class='hs-comment'>-- create an 'Addr#' is with an unboxed string literal, than to pack a</span>
<span class=hs-linenum> 481: </span><span class='hs-comment'>-- boxed string. A unboxed string literal is compiled to a static @char</span>
<span class=hs-linenum> 482: </span><span class='hs-comment'>-- []@ by GHC. Establishing the length of the string requires a call to</span>
<span class=hs-linenum> 483: </span><span class='hs-comment'>-- @strlen(3)@, so the 'Addr#' must point to a null-terminated buffer (as</span>
<span class=hs-linenum> 484: </span><span class='hs-comment'>-- is the case with @\"string\"\#@ literals in GHC). Use 'Data.ByteString.Unsafe.unsafePackAddressLen'</span>
<span class=hs-linenum> 485: </span><span class='hs-comment'>-- if you know the length of the string statically.</span>
<span class=hs-linenum> 486: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 487: </span><span class='hs-comment'>-- An example:</span>
<span class=hs-linenum> 488: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 489: </span><span class='hs-comment'>-- &gt; literalFS = unsafePackAddress "literal"#</span>
<span class=hs-linenum> 490: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 491: </span><span class='hs-comment'>-- This function is /unsafe/. If you modify the buffer pointed to by the</span>
<span class=hs-linenum> 492: </span><span class='hs-comment'>-- original 'Addr#' this modification will be reflected in the resulting</span>
<span class=hs-linenum> 493: </span><span class='hs-comment'>-- @ByteString@, breaking referential transparency.</span>
<span class=hs-linenum> 494: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 495: </span><span class='hs-comment'>-- Note this also won't work if your 'Addr#' has embedded @\'\\0\'@ characters in</span>
<span class=hs-linenum> 496: </span><span class='hs-comment'>-- the string, as @strlen@ will return too short a length.</span>
<span class=hs-linenum> 497: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 498: </span><span class='hs-definition'>unsafePackAddress</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 499: </span><a class=annot href="#"><span class=annottext>GHC.Prim.Addr# -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>unsafePackAddress</span></a> <a class=annot href="#"><span class=annottext>GHC.Prim.Addr#</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 500: </span><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 811</span>
<span class=hs-linenum> 501: </span>    <span class='hs-varid'>unsafePackLenAddress</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>GHC.Prim.Int#</span><span class='hs-layout'>(</span></a><span class='hs-varid'>cstringLength</span><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr#}</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr#}</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span>
<span class=hs-linenum> 502: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 503: </span>    <span class='hs-varid'>l</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>c_strlen</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-varid'>addr</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 504: </span>    <span class='hs-varid'>unsafePackLenAddress</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromIntegral</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>addr</span><span class='hs-cpp'>#</span>
<span class=hs-linenum> 505: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 506: </span><span class='hs-comment'>{-# INLINE unsafePackAddress #-}</span>
<span class=hs-linenum> 507: </span>
<span class=hs-linenum> 508: </span><span class='hs-comment'>-- | See 'unsafePackAddress'. This function is similar,</span>
<span class=hs-linenum> 509: </span><span class='hs-comment'>-- but takes an additional length argument rather then computing</span>
<span class=hs-linenum> 510: </span><span class='hs-comment'>-- it with @strlen@.</span>
<span class=hs-linenum> 511: </span><span class='hs-comment'>-- Therefore embedding @\'\\0\'@ characters is possible.</span>
<span class=hs-linenum> 512: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 513: </span><span class='hs-comment'>-- @since 0.11.2.0</span>
<span class=hs-linenum> 514: </span><span class='hs-definition'>unsafePackLenAddress</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 515: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Prim.Addr# -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>unsafePackLenAddress</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <a class=annot href="#"><span class=annottext>GHC.Prim.Addr#</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 516: </span><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 811</span>
<span class=hs-linenum> 517: </span>    <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-layout'>(</span></a><span class='hs-conid'>ForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr#}</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.ForeignPtr.ForeignPtrContents | v == FinalPtr}</span><span class='hs-conid'>FinalPtr</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 518: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 519: </span>    <span class='hs-varid'>p</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newForeignPtr_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-varid'>addr</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 520: </span>    <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>BS</span> <span class='hs-varid'>p</span> <span class='hs-varid'>len</span>
<span class=hs-linenum> 521: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 522: </span><span class='hs-comment'>{-# INLINE unsafePackLenAddress #-}</span>
<span class=hs-linenum> 523: </span>
<span class=hs-linenum> 524: </span><span class='hs-comment'>-- | See 'unsafePackAddress'. This function has similar behavior. Prefer</span>
<span class=hs-linenum> 525: </span><span class='hs-comment'>-- this function when the address in known to be an @Addr#@ literal. In</span>
<span class=hs-linenum> 526: </span><span class='hs-comment'>-- that context, there is no need for the sequencing guarantees that 'IO'</span>
<span class=hs-linenum> 527: </span><span class='hs-comment'>-- provides. On GHC 9.0 and up, this function uses the @FinalPtr@ data</span>
<span class=hs-linenum> 528: </span><span class='hs-comment'>-- constructor for @ForeignPtrContents@.</span>
<span class=hs-linenum> 529: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 530: </span><span class='hs-comment'>-- @since 0.11.1.0</span>
<span class=hs-linenum> 531: </span><span class='hs-definition'>unsafePackLiteral</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 532: </span><a class=annot href="#"><span class=annottext>GHC.Prim.Addr# -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>unsafePackLiteral</span></a> <a class=annot href="#"><span class=annottext>GHC.Prim.Addr#</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 533: </span><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 811</span>
<span class=hs-linenum> 534: </span>  <span class='hs-varid'>unsafePackLenLiteral</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>GHC.Prim.Int#</span><span class='hs-layout'>(</span></a><span class='hs-varid'>cstringLength</span><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr#}</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr#}</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span>
<span class=hs-linenum> 535: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 536: </span>  <span class='hs-keyword'>let</span> <span class='hs-varid'>len</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>accursedUnutterablePerformIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>c_strlen</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-varid'>addr</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 537: </span>   <span class='hs-keyword'>in</span> <span class='hs-varid'>unsafePackLenLiteral</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromIntegral</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <span class='hs-varid'>addr</span><span class='hs-cpp'>#</span>
<span class=hs-linenum> 538: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 539: </span><span class='hs-comment'>{-# INLINE unsafePackLiteral #-}</span>
<span class=hs-linenum> 540: </span>
<span class=hs-linenum> 541: </span>
<span class=hs-linenum> 542: </span><span class='hs-comment'>-- | See 'unsafePackLiteral'. This function is similar,</span>
<span class=hs-linenum> 543: </span><span class='hs-comment'>-- but takes an additional length argument rather then computing</span>
<span class=hs-linenum> 544: </span><span class='hs-comment'>-- it with @strlen@.</span>
<span class=hs-linenum> 545: </span><span class='hs-comment'>-- Therefore embedding @\'\\0\'@ characters is possible.</span>
<span class=hs-linenum> 546: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 547: </span><span class='hs-comment'>-- @since 0.11.2.0</span>
<span class=hs-linenum> 548: </span><span class='hs-definition'>unsafePackLenLiteral</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Addr</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 549: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Prim.Addr# -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>unsafePackLenLiteral</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <a class=annot href="#"><span class=annottext>GHC.Prim.Addr#</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 550: </span><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 811</span>
<span class=hs-linenum> 551: </span>  <span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-layout'>(</span></a><span class='hs-conid'>ForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == addr#}</span><span class='hs-varid'>addr</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.ForeignPtr.ForeignPtrContents | v == FinalPtr}</span><span class='hs-conid'>FinalPtr</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 552: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 553: </span>  <span class='hs-comment'>-- newForeignPtr_ allocates a MutVar# internally. If that MutVar#</span>
<span class=hs-linenum> 554: </span>  <span class='hs-comment'>-- gets commoned up with the MutVar# of some unrelated ForeignPtr,</span>
<span class=hs-linenum> 555: </span>  <span class='hs-comment'>-- it may prevent automatic finalization for that other ForeignPtr.</span>
<span class=hs-linenum> 556: </span>  <span class='hs-comment'>-- So we avoid accursedUnutterablePerformIO here.</span>
<span class=hs-linenum> 557: </span>  <span class='hs-conid'>BS</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsafeDupablePerformIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>newForeignPtr_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-varid'>addr</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>len</span>
<span class=hs-linenum> 558: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 559: </span><span class='hs-comment'>{-# INLINE unsafePackLenLiteral #-}</span>
<span class=hs-linenum> 560: </span>
<span class=hs-linenum> 561: </span><span class='hs-definition'>packUptoLenBytes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 562: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Word.Word8] -&gt; (Data.ByteString.Internal.Type.ByteString, [GHC.Word.Word8])</span><span class='hs-definition'>packUptoLenBytes</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>xs0</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 563: </span>    <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, [GHC.Word.Word8]))) -&gt; (Data.ByteString.Internal.Type.ByteString, [GHC.Word.Word8])</span><span class='hs-varid'>unsafeCreateFpUptoN'</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p0</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 564: </span>      <span class='hs-keyword'>let</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen p0 - len
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-varid'>p_end</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen p0 - len
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-varid'>plusForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p0</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 565: </span>          <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; {VV : [{VV : GHC.Word.Word8 | false}]&lt;\_ VV -&gt; {VV : GHC.Word.Word8 | false}&gt; | false} -&gt; (GHC.Types.IO (GHC.Types.Int, [GHC.Word.Word8]))</span><span class='hs-varid'>go</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-conid'>[]</span>              <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.Int, [GHC.Word.Word8])</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>`minusForeignPtr`</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p0</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 566: </span>          <span class='hs-varid'>go</span> <span class='hs-varop'>!</span><span class='hs-varid'>p</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == p_end
                                                  &amp;&amp; fplen v == fplen p0 - len
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-varid'>p_end</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Types.Int, [GHC.Word.Word8]) | fst v == len
                                         &amp;&amp; x_Tuple21 v == len}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Word.Word8 | false}]&lt;\_ VV -&gt; {v : GHC.Word.Word8 | false}&gt; | false}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 567: </span>          <span class='hs-varid'>go</span> <span class='hs-varop'>!</span><span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>pokeFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Word.Word8 | false}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.Types.Int, [GHC.Word.Word8]))</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Word.Word8 | false}]&lt;\_ VV -&gt; {v : GHC.Word.Word8 | false}&gt; | v == xs
                                                                             &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum> 568: </span>      <span class='hs-keyword'>in</span> <span class='hs-varid'>go</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p0</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == xs0
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs0</span></a>
<span class=hs-linenum> 569: </span>
<span class=hs-linenum> 570: </span><span class='hs-definition'>packUptoLenChars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 571: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Types.Char] -&gt; (Data.ByteString.Internal.Type.ByteString, [GHC.Types.Char])</span><span class='hs-definition'>packUptoLenChars</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>cs0</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 572: </span>    <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, [GHC.Types.Char]))) -&gt; (Data.ByteString.Internal.Type.ByteString, [GHC.Types.Char])</span><span class='hs-varid'>unsafeCreateFpUptoN'</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p0</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 573: </span>      <span class='hs-keyword'>let</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen p0 - len
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-varid'>p_end</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen p0 - len
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-varid'>plusForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p0</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 574: </span>          <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; {VV : [{VV : GHC.Types.Char | false}]&lt;\_ VV -&gt; {VV : GHC.Types.Char | false}&gt; | false} -&gt; (GHC.Types.IO (GHC.Types.Int, [GHC.Types.Char]))</span><span class='hs-varid'>go</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-conid'>[]</span>              <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.Int, [GHC.Types.Char])</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>`minusForeignPtr`</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p0</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 575: </span>          <span class='hs-varid'>go</span> <span class='hs-varop'>!</span><span class='hs-varid'>p</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == p_end
                                                  &amp;&amp; fplen v == fplen p0 - len
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-varid'>p_end</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Types.Int, [GHC.Types.Char]) | fst v == len
                                         &amp;&amp; x_Tuple21 v == len}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Types.Char | false}]&lt;\_ VV -&gt; {v : GHC.Types.Char | false}&gt; | false}</span><span class='hs-varid'>cs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 576: </span>          <span class='hs-varid'>go</span> <span class='hs-varop'>!</span><span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>cs</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>pokeFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>GHC.Word.Word8</span><span class='hs-layout'>(</span></a><span class='hs-varid'>c2w</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Char | false}</span><span class='hs-varid'>c</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.Types.Int, [GHC.Types.Char]))</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [{v : GHC.Types.Char | false}]&lt;\_ VV -&gt; {v : GHC.Types.Char | false}&gt; | v == cs
                                                                             &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum> 577: </span>      <span class='hs-keyword'>in</span> <span class='hs-varid'>go</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>p0</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == cs0
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs0</span></a>
<span class=hs-linenum> 578: </span>
<span class=hs-linenum> 579: </span><span class='hs-comment'>-- Unpacking bytestrings into lists efficiently is a tradeoff: on the one hand</span>
<span class=hs-linenum> 580: </span><span class='hs-comment'>-- we would like to write a tight loop that just blasts the list into memory, on</span>
<span class=hs-linenum> 581: </span><span class='hs-comment'>-- the other hand we want it to be unpacked lazily so we don't end up with a</span>
<span class=hs-linenum> 582: </span><span class='hs-comment'>-- massive list data structure in memory.</span>
<span class=hs-linenum> 583: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 584: </span><span class='hs-comment'>-- Our strategy is to combine both: we will unpack lazily in reasonable sized</span>
<span class=hs-linenum> 585: </span><span class='hs-comment'>-- chunks, where each chunk is unpacked strictly.</span>
<span class=hs-linenum> 586: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 587: </span><span class='hs-comment'>-- unpackBytes and unpackChars do the lazy loop, while unpackAppendBytes and</span>
<span class=hs-linenum> 588: </span><span class='hs-comment'>-- unpackAppendChars do the chunks strictly.</span>
<span class=hs-linenum> 589: </span>
<span class=hs-linenum> 590: </span><span class='hs-definition'>unpackBytes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 591: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Word.Word8]</span><span class='hs-definition'>unpackBytes</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>bs</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackAppendBytesLazy</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum> 592: </span>
<span class=hs-linenum> 593: </span><span class='hs-definition'>unpackChars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 594: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Types.Char]</span><span class='hs-definition'>unpackChars</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>bs</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackAppendCharsLazy</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum> 595: </span>
<span class=hs-linenum> 596: </span><span class='hs-definition'>unpackAppendBytesLazy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 597: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Word.Word8] -&gt; [GHC.Word.Word8]</span><span class='hs-definition'>unpackAppendBytesLazy</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum> 598: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>100</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Word.Word8] -&gt; [GHC.Word.Word8]</span><span class='hs-varid'>unpackAppendBytesStrict</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == xs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum> 599: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Word.Word8] -&gt; [GHC.Word.Word8]</span><span class='hs-varid'>unpackAppendBytesStrict</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>100</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == remainder
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>remainder</span></a>
<span class=hs-linenum> 600: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 601: </span>    <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>remainder</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Word.Word8] -&gt; [GHC.Word.Word8]</span><span class='hs-varid'>unpackAppendBytesLazy</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>plusForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>100</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>100</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == xs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum> 602: </span>
<span class=hs-linenum> 603: </span>  <span class='hs-comment'>-- Why 100 bytes you ask? Because on a 64bit machine the list we allocate</span>
<span class=hs-linenum> 604: </span>  <span class='hs-comment'>-- takes just shy of 4k which seems like a reasonable amount.</span>
<span class=hs-linenum> 605: </span>  <span class='hs-comment'>-- (5 words per list element, 8 bytes per word, 100 elements = 4000 bytes)</span>
<span class=hs-linenum> 606: </span>
<span class=hs-linenum> 607: </span><span class='hs-definition'>unpackAppendCharsLazy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 608: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Types.Char] -&gt; [GHC.Types.Char]</span><span class='hs-definition'>unpackAppendCharsLazy</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum> 609: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>100</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Types.Char] -&gt; [GHC.Types.Char]</span><span class='hs-varid'>unpackAppendCharsStrict</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == cs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum> 610: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Types.Char] -&gt; [GHC.Types.Char]</span><span class='hs-varid'>unpackAppendCharsStrict</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>100</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == remainder
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>remainder</span></a>
<span class=hs-linenum> 611: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 612: </span>    <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>remainder</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Types.Char] -&gt; [GHC.Types.Char]</span><span class='hs-varid'>unpackAppendCharsLazy</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>plusForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>100</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>100</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == cs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum> 613: </span>
<span class=hs-linenum> 614: </span><span class='hs-comment'>-- For these unpack functions, since we're unpacking the whole list strictly we</span>
<span class=hs-linenum> 615: </span><span class='hs-comment'>-- build up the result list in an accumulator. This means we have to build up</span>
<span class=hs-linenum> 616: </span><span class='hs-comment'>-- the list starting at the end. So our traversal starts at the end of the</span>
<span class=hs-linenum> 617: </span><span class='hs-comment'>-- buffer and loops down until we hit the sentinal:</span>
<span class=hs-linenum> 618: </span>
<span class=hs-linenum> 619: </span><span class='hs-definition'>unpackAppendBytesStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 620: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Word.Word8] -&gt; [GHC.Word.Word8]</span><span class='hs-definition'>unpackAppendBytesStrict</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 621: </span>    <a class=annot href="#"><span class=annottext>(GHC.Types.IO [GHC.Word.Word8]) -&gt; [GHC.Word.Word8]</span><span class='hs-varid'>accursedUnutterablePerformIO</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO [GHC.Word.Word8])) -&gt; (GHC.Types.IO [GHC.Word.Word8])</span><span class='hs-varid'>unsafeWithForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>base</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 622: </span>      <span class='hs-varid'>loop</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | pbase v == pbase base
                                    &amp;&amp; v &lt; base}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == base}</span><span class='hs-varid'>base</span></a> <span class='hs-varop'>`Data.LiquidPtr.plusPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | pbase v == pbase base
                                    &amp;&amp; v &lt; base}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == base}</span><span class='hs-varid'>base</span></a> <span class='hs-varop'>`Data.LiquidPtr.plusPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-comment'>-</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-varop'>+</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == xs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum> 623: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 624: </span>    <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a) -&gt; (GHC.Ptr.Ptr a) -&gt; [a] -&gt; (GHC.Types.IO [a])</span><span class='hs-varid'>loop</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a)</span><span class='hs-varid'>sentinal</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>acc</span></a>
<span class=hs-linenum> 625: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | v == p}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | v == sentinal}</span><span class='hs-varid'>sentinal</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == acc
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>acc</span></a>
<span class=hs-linenum> 626: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO a)</span><span class='hs-conid'>Data.LiquidPtr.peek</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | v == p}</span><span class='hs-varid'>p</span></a>
<span class=hs-linenum> 627: </span>                           <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a) -&gt; (GHC.Ptr.Ptr a) -&gt; [a] -&gt; (GHC.Types.IO [a])</span><span class='hs-varid'>loop</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | v == sentinal}</span><span class='hs-varid'>sentinal</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | v == p}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>`Data.LiquidPtr.plusPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | head v == x
           &amp;&amp; len v == 1 + len acc
           &amp;&amp; tail v == acc}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{v : [a] | v == acc
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>acc</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 628: </span>
<span class=hs-linenum> 629: </span><span class='hs-definition'>unpackAppendCharsStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 630: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Types.Char] -&gt; [GHC.Types.Char]</span><span class='hs-definition'>unpackAppendCharsStrict</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 631: </span>    <a class=annot href="#"><span class=annottext>(GHC.Types.IO [GHC.Types.Char]) -&gt; [GHC.Types.Char]</span><span class='hs-varid'>accursedUnutterablePerformIO</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO [GHC.Types.Char])) -&gt; (GHC.Types.IO [GHC.Types.Char])</span><span class='hs-varid'>unsafeWithForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>base</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 632: </span>      <span class='hs-varid'>loop</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | pbase v == pbase base
                                    &amp;&amp; v &lt; base}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == base}</span><span class='hs-varid'>base</span></a> <span class='hs-varop'>`Data.LiquidPtr.plusPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | pbase v == pbase base
                                    &amp;&amp; v &lt; base}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == base}</span><span class='hs-varid'>base</span></a> <span class='hs-varop'>`Data.LiquidPtr.plusPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-comment'>-</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-varop'>+</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == xs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum> 633: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 634: </span>    <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; [GHC.Types.Char] -&gt; (GHC.Types.IO [GHC.Types.Char])</span><span class='hs-varid'>loop</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>sentinal</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>acc</span></a>
<span class=hs-linenum> 635: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == sentinal}</span><span class='hs-varid'>sentinal</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == acc
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>acc</span></a>
<span class=hs-linenum> 636: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <a class=annot href="#"><span class=annottext>GHC.Word.Word8</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Word.Word8)</span><span class='hs-conid'>Data.LiquidPtr.peek</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-varid'>p</span></a>
<span class=hs-linenum> 637: </span>                           <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; [GHC.Types.Char] -&gt; (GHC.Types.IO [GHC.Types.Char])</span><span class='hs-varid'>loop</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == sentinal}</span><span class='hs-varid'>sentinal</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>`Data.LiquidPtr.plusPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v == 1 + len acc
                        &amp;&amp; tail v == acc}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Char</span><span class='hs-varid'>w2c</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Word.Word8 | v == x}</span><span class='hs-varid'>x</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == acc
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>acc</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 638: </span>
<span class=hs-linenum> 639: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum> 640: </span>
<span class=hs-linenum> 641: </span><span class='hs-comment'>-- | The 0 pointer. Used to indicate the empty Bytestring.</span>
<span class=hs-linenum> 642: </span><span class='hs-definition'>nullForeignPtr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span>
<span class=hs-linenum> 643: </span><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 811</span>
<span class=hs-linenum> 644: </span><a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-definition'>nullForeignPtr</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Addr# | v == nullAddr#}</span><span class='hs-varid'>nullAddr</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.ForeignPtr.ForeignPtrContents | v == FinalPtr}</span><span class='hs-conid'>FinalPtr</span></a>
<span class=hs-linenum> 645: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 646: </span><span class='hs-definition'>nullForeignPtr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>nullAddr</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>error</span> <span class='hs-str'>"nullForeignPtr"</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 647: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 648: </span>
<span class=hs-linenum> 649: </span><span class='hs-comment'>-- ---------------------------------------------------------------------</span>
<span class=hs-linenum> 650: </span><span class='hs-comment'>-- Low level constructors</span>
<span class=hs-linenum> 651: </span>
<span class=hs-linenum> 652: </span><span class='hs-comment'>-- | /O(1)/ Build a ByteString from a ForeignPtr.</span>
<span class=hs-linenum> 653: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 654: </span><span class='hs-comment'>-- If you do not need the offset parameter then you should be using</span>
<span class=hs-linenum> 655: </span><span class='hs-comment'>-- 'Data.ByteString.Unsafe.unsafePackCStringLen' or</span>
<span class=hs-linenum> 656: </span><span class='hs-comment'>-- 'Data.ByteString.Unsafe.unsafePackCStringFinalizer' instead.</span>
<span class=hs-linenum> 657: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 658: </span><span class='hs-definition'>fromForeignPtr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span>
<span class=hs-linenum> 659: </span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-comment'>-- ^ Offset</span>
<span class=hs-linenum> 660: </span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-comment'>-- ^ Length</span>
<span class=hs-linenum> 661: </span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 662: </span><a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; GHC.Types.Int -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>fromForeignPtr</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>o</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen fp - o
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>plusForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == o}</span><span class='hs-varid'>o</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 663: </span><span class='hs-comment'>{-# INLINE fromForeignPtr #-}</span>
<span class=hs-linenum> 664: </span>
<span class=hs-linenum> 665: </span><span class='hs-comment'>-- | @since 0.11.0.0</span>
<span class=hs-linenum> 666: </span><span class='hs-definition'>fromForeignPtr0</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span>
<span class=hs-linenum> 667: </span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-comment'>-- ^ Length</span>
<span class=hs-linenum> 668: </span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 669: </span><a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>fromForeignPtr0</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BS</span>
<span class=hs-linenum> 670: </span><span class='hs-comment'>{-# INLINE fromForeignPtr0 #-}</span>
<span class=hs-linenum> 671: </span>
<span class=hs-linenum> 672: </span><span class='hs-comment'>-- | /O(1)/ Deconstruct a ForeignPtr from a ByteString</span>
<span class=hs-linenum> 673: </span><span class='hs-definition'>toForeignPtr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ (ptr, offset, length)</span>
<span class=hs-linenum> 674: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8), GHC.Types.Int, GHC.Types.Int)</span><span class='hs-definition'>toForeignPtr</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a b c &lt;p3 :: b-&gt; a c -&gt; Bool, p2 :: a b -&gt; Bool&gt;.
      x1:a -&gt; x2:{VV : b&lt;p2 x1&gt; | true} -&gt; x3:{VV : c&lt;p3 x2 x1&gt; | true} -&gt; {v : (a, b, c)&lt;\x8 VV -&gt; {VV : b&lt;p2 x8&gt; | true}, \x8 x8 VV -&gt; {VV : c&lt;p3 x8 x8&gt; | true}&gt; | fst3 v == x1
                                                                                                                                                                      &amp;&amp; snd3 v == x2
                                                                                                                                                                      &amp;&amp; x_Tuple31 v == x1
                                                                                                                                                                      &amp;&amp; x_Tuple32 v == x2
                                                                                                                                                                      &amp;&amp; x_Tuple33 v == x3} | VV == (,,)}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == ps}</span><span class='hs-varid'>ps</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 675: </span><span class='hs-comment'>{-# INLINE toForeignPtr #-}</span>
<span class=hs-linenum> 676: </span>
<span class=hs-linenum> 677: </span><span class='hs-comment'>-- | /O(1)/ Deconstruct a ForeignPtr from a ByteString</span>
<span class=hs-linenum> 678: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 679: </span><span class='hs-comment'>-- @since 0.11.0.0</span>
<span class=hs-linenum> 680: </span><span class='hs-definition'>toForeignPtr0</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ (ptr, length)</span>
<span class=hs-linenum> 681: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8), GHC.Types.Int)</span><span class='hs-definition'>toForeignPtr0</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a b &lt;p2 :: a b -&gt; Bool&gt;.
      x1:a -&gt; x2:{VV : b&lt;p2 x1&gt; | true} -&gt; {v : (a, b)&lt;\x5 VV -&gt; {VV : b&lt;p2 x5&gt; | true}&gt; | fst v == x1
                                                                                           &amp;&amp; snd v == x2
                                                                                           &amp;&amp; x_Tuple21 v == x1
                                                                                           &amp;&amp; x_Tuple22 v == x2} | VV == (,)}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == ps}</span><span class='hs-varid'>ps</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 682: </span><span class='hs-comment'>{-# INLINE toForeignPtr0 #-}</span>
<span class=hs-linenum> 683: </span>
<span class=hs-linenum> 684: </span><span class='hs-comment'>-- | A way of creating ByteStrings outside the IO monad. The @Int@</span>
<span class=hs-linenum> 685: </span><span class='hs-comment'>-- argument gives the final size of the ByteString.</span>
<span class=hs-linenum> 686: </span><span class='hs-definition'>unsafeCreateFp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 687: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>unsafeCreateFp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafeDupablePerformIO</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>createFp</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 688: </span><span class='hs-comment'>{-# INLINE unsafeCreateFp #-}</span>
<span class=hs-linenum> 689: </span>
<span class=hs-linenum> 690: </span><span class='hs-comment'>-- | Like 'unsafeCreateFp' but instead of giving the final size of the</span>
<span class=hs-linenum> 691: </span><span class='hs-comment'>-- ByteString, it is just an upper bound. The inner action returns</span>
<span class=hs-linenum> 692: </span><span class='hs-comment'>-- the actual size. Unlike 'createFpAndTrim' the ByteString is not</span>
<span class=hs-linenum> 693: </span><span class='hs-comment'>-- reallocated if the final size is less than the estimated size.</span>
<span class=hs-linenum> 694: </span><span class='hs-definition'>unsafeCreateFpUptoN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 695: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>unsafeCreateFpUptoN</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafeDupablePerformIO</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>createFpUptoN</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 696: </span><span class='hs-comment'>{-# INLINE unsafeCreateFpUptoN #-}</span>
<span class=hs-linenum> 697: </span>
<span class=hs-linenum> 698: </span><span class='hs-definition'>unsafeCreateFpUptoN'</span>
<span class=hs-linenum> 699: </span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 700: </span><a class=annot href="#"><span class=annottext>forall a .
GHC.Types.Int -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))) -&gt; (Data.ByteString.Internal.Type.ByteString, a)</span><span class='hs-definition'>unsafeCreateFpUptoN'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafeDupablePerformIO</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>createFpUptoN'</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 701: </span><span class='hs-comment'>{-# INLINE unsafeCreateFpUptoN' #-}</span>
<span class=hs-linenum> 702: </span>
<span class=hs-linenum> 703: </span><span class='hs-comment'>-- | Create ByteString of size @l@ and use action @f@ to fill its contents.</span>
<span class=hs-linenum> 704: </span><span class='hs-definition'>createFp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 705: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>createFp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 706: </span>    <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8))</span><span class='hs-varid'>mallocByteString</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 707: </span>    <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>action</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a>
<span class=hs-linenum> 708: </span>    <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>mkDeferredByteString</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 709: </span><span class='hs-comment'>{-# INLINE createFp #-}</span>
<span class=hs-linenum> 710: </span>
<span class=hs-linenum> 711: </span><span class='hs-comment'>-- | Given a maximum size @l@ and an action @f@ that fills the 'ByteString'</span>
<span class=hs-linenum> 712: </span><span class='hs-comment'>-- starting at the given 'Ptr' and returns the actual utilized length,</span>
<span class=hs-linenum> 713: </span><span class='hs-comment'>-- @`createFpUptoN'` l f@ returns the filled 'ByteString'.</span>
<span class=hs-linenum> 714: </span><span class='hs-definition'>createFpUptoN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 715: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>createFpUptoN</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>maxLen</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 716: </span>    <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8))</span><span class='hs-varid'>mallocByteString</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a>
<span class=hs-linenum> 717: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>action</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a>
<span class=hs-linenum> 718: </span>    <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>mkDeferredByteString</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 719: </span><span class='hs-comment'>{-# INLINE createFpUptoN #-}</span>
<span class=hs-linenum> 720: </span>
<span class=hs-linenum> 721: </span><span class='hs-comment'>-- | Like 'createFpUptoN', but also returns an additional value created by the</span>
<span class=hs-linenum> 722: </span><span class='hs-comment'>-- action.</span>
<span class=hs-linenum> 723: </span><span class='hs-definition'>createFpUptoN'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 724: </span><a class=annot href="#"><span class=annottext>forall a .
GHC.Types.Int -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))) -&gt; (GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-definition'>createFpUptoN'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>maxLen</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a)) -&gt; (GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 725: </span>    <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8))</span><span class='hs-varid'>mallocByteString</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a>
<span class=hs-linenum> 726: </span>    <span class='hs-layout'>(</span><span class='hs-varid'>len</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-varid'>action</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a>
<span class=hs-linenum> 727: </span>    <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>bs</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>mkDeferredByteString</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 728: </span>    <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a)) -&gt; (GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-varid'>pure</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.ByteString.Internal.Type.ByteString, a) | fst v == bs
                                                     &amp;&amp; snd v == res
                                                     &amp;&amp; x_Tuple21 v == bs
                                                     &amp;&amp; x_Tuple22 v == res}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == res}</span><span class='hs-varid'>res</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 729: </span><span class='hs-comment'>{-# INLINE createFpUptoN' #-}</span>
<span class=hs-linenum> 730: </span>
<span class=hs-linenum> 731: </span><span class='hs-comment'>-- | Given the maximum size needed and a function to make the contents</span>
<span class=hs-linenum> 732: </span><span class='hs-comment'>-- of a ByteString, createFpAndTrim makes the 'ByteString'. The generating</span>
<span class=hs-linenum> 733: </span><span class='hs-comment'>-- function is required to return the actual final size (&lt;= the maximum</span>
<span class=hs-linenum> 734: </span><span class='hs-comment'>-- size), and the resulting byte array is reallocated to this size.</span>
<span class=hs-linenum> 735: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 736: </span><span class='hs-comment'>-- createFpAndTrim is the main mechanism for creating custom, efficient</span>
<span class=hs-linenum> 737: </span><span class='hs-comment'>-- ByteString functions, using Haskell or C functions to fill the space.</span>
<span class=hs-linenum> 738: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 739: </span><span class='hs-definition'>createFpAndTrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 740: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>createFpAndTrim</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>maxLen</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO Data.ByteString.Internal.Type.ByteString) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 741: </span>    <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8))</span><span class='hs-varid'>mallocByteString</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a>
<span class=hs-linenum> 742: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>action</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a>
<span class=hs-linenum> 743: </span>    <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool -&gt; GHC.Types.Bool</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a>
<span class=hs-linenum> 744: </span>        <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>mkDeferredByteString</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a>
<span class=hs-linenum> 745: </span>        <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>createFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>dest</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>memcpyFp</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == dest}</span><span class='hs-varid'>dest</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 746: </span><span class='hs-comment'>{-# INLINE createFpAndTrim #-}</span>
<span class=hs-linenum> 747: </span>
<span class=hs-linenum> 748: </span><span class='hs-definition'>createFpAndTrim'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 749: </span><a class=annot href="#"><span class=annottext>forall a .
GHC.Types.Int -&gt; ((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, GHC.Types.Int, a))) -&gt; (GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-definition'>createFpAndTrim'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>maxLen</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO {VV : ({VV : GHC.Types.Int | false}, GHC.Types.Int, a) | false})</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a)) -&gt; (GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 750: </span>    <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8))</span><span class='hs-varid'>mallocByteString</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a>
<span class=hs-linenum> 751: </span>    <span class='hs-layout'>(</span><span class='hs-varid'>off</span><span class='hs-layout'>,</span> <span class='hs-varid'>len</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {v : ({v : GHC.Types.Int | false}, GHC.Types.Int, a) | false})</span><span class='hs-varid'>action</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a>
<span class=hs-linenum> 752: </span>    <span class='hs-varid'>assert</span> <span class='hs-layout'>(</span>
<span class=hs-linenum> 753: </span>      <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-comment'>-- length OK</span>
<span class=hs-linenum> 754: </span>      <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-varop'>||</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>off</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>off</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- offset OK</span>
<span class=hs-linenum> 755: </span>      <span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>pure</span></a> <a class=annot href="#"><span class=annottext>{v : () | v == ()}</span><span class='hs-conid'>()</span></a>
<span class=hs-linenum> 756: </span>    <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>bs</span></a> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a>
<span class=hs-linenum> 757: </span>        <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>mkDeferredByteString</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == maxLen}</span><span class='hs-varid'>maxLen</span></a> <span class='hs-comment'>-- entire buffer used =&gt; offset is zero</span>
<span class=hs-linenum> 758: </span>        <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-varid'>createFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>dest</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 759: </span>               <span class='hs-varid'>memcpyFp</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == dest}</span><span class='hs-varid'>dest</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen fp - off
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>off</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 760: </span>    <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.ByteString.Internal.Type.ByteString, a) | fst v == bs
                                                     &amp;&amp; snd v == res
                                                     &amp;&amp; x_Tuple21 v == bs
                                                     &amp;&amp; x_Tuple22 v == res}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == res}</span><span class='hs-varid'>res</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 761: </span><span class='hs-comment'>{-# INLINE createFpAndTrim' #-}</span>
<span class=hs-linenum> 762: </span>
<span class=hs-linenum> 763: </span>
<span class=hs-linenum> 764: </span><span class='hs-definition'>wrapAction</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>res</span>
<span class=hs-linenum> 765: </span><a class=annot href="#"><span class=annottext>forall a .
((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO a)) -&gt; (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO a)</span><span class='hs-definition'>wrapAction</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flip</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      x1:(GHC.ForeignPtr.ForeignPtr a) -&gt; ({v : (GHC.Ptr.Ptr a) | v == ofForeignPtr x1
                                                                  &amp;&amp; v == pbase v
                                                                  &amp;&amp; plen v == fplen x1} -&gt; (GHC.Types.IO b)) -&gt; (GHC.Types.IO b) | VV == withForeignPtr}</span><span class='hs-conid'>Data.LiquidPtr.withForeignPtr</span></a>
<span class=hs-linenum> 766: </span>  <span class='hs-comment'>-- Cannot use unsafeWithForeignPtr, because action can diverge</span>
<span class=hs-linenum> 767: </span>
<span class=hs-linenum> 768: </span><span class='hs-comment'>-- | A way of creating ByteStrings outside the IO monad. The @Int@</span>
<span class=hs-linenum> 769: </span><span class='hs-comment'>-- argument gives the final size of the ByteString.</span>
<span class=hs-linenum> 770: </span><span class='hs-definition'>unsafeCreate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 771: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>unsafeCreate</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafeCreateFp</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-layout'>(</span></a><span class='hs-varid'>wrapAction</span> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 772: </span><span class='hs-comment'>{-# INLINE unsafeCreate #-}</span>
<span class=hs-linenum> 773: </span>
<span class=hs-linenum> 774: </span><span class='hs-comment'>-- | Like 'unsafeCreate' but instead of giving the final size of the</span>
<span class=hs-linenum> 775: </span><span class='hs-comment'>-- ByteString, it is just an upper bound. The inner action returns</span>
<span class=hs-linenum> 776: </span><span class='hs-comment'>-- the actual size. Unlike 'createAndTrim' the ByteString is not</span>
<span class=hs-linenum> 777: </span><span class='hs-comment'>-- reallocated if the final size is less than the estimated size.</span>
<span class=hs-linenum> 778: </span><span class='hs-definition'>unsafeCreateUptoN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 779: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>unsafeCreateUptoN</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafeCreateFpUptoN</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>wrapAction</span> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 780: </span><span class='hs-comment'>{-# INLINE unsafeCreateUptoN #-}</span>
<span class=hs-linenum> 781: </span>
<span class=hs-linenum> 782: </span><span class='hs-comment'>-- | @since 0.10.12.0</span>
<span class=hs-linenum> 783: </span><span class='hs-definition'>unsafeCreateUptoN'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 784: </span><a class=annot href="#"><span class=annottext>forall a .
GHC.Types.Int -&gt; ((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))) -&gt; (Data.ByteString.Internal.Type.ByteString, a)</span><span class='hs-definition'>unsafeCreateUptoN'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafeCreateFpUptoN'</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>wrapAction</span> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 785: </span><span class='hs-comment'>{-# INLINE unsafeCreateUptoN' #-}</span>
<span class=hs-linenum> 786: </span>
<span class=hs-linenum> 787: </span><span class='hs-comment'>-- | Create ByteString of size @l@ and use action @f@ to fill its contents.</span>
<span class=hs-linenum> 788: </span><span class='hs-definition'>create</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 789: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>create</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>createFp</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-layout'>(</span></a><span class='hs-varid'>wrapAction</span> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>action</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 790: </span><span class='hs-comment'>{-# INLINE create #-}</span>
<span class=hs-linenum> 791: </span>
<span class=hs-linenum> 792: </span><span class='hs-comment'>-- | Given a maximum size @l@ and an action @f@ that fills the 'ByteString'</span>
<span class=hs-linenum> 793: </span><span class='hs-comment'>-- starting at the given 'Ptr' and returns the actual utilized length,</span>
<span class=hs-linenum> 794: </span><span class='hs-comment'>-- @`createUptoN'` l f@ returns the filled 'ByteString'.</span>
<span class=hs-linenum> 795: </span><span class='hs-definition'>createUptoN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 796: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>createUptoN</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>createFpUptoN</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>wrapAction</span> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>action</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 797: </span><span class='hs-comment'>{-# INLINE createUptoN #-}</span>
<span class=hs-linenum> 798: </span>
<span class=hs-linenum> 799: </span><span class='hs-comment'>-- | Like 'createUptoN', but also returns an additional value created by the</span>
<span class=hs-linenum> 800: </span><span class='hs-comment'>-- action.</span>
<span class=hs-linenum> 801: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 802: </span><span class='hs-comment'>-- @since 0.10.12.0</span>
<span class=hs-linenum> 803: </span><span class='hs-definition'>createUptoN'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 804: </span><a class=annot href="#"><span class=annottext>forall a .
GHC.Types.Int -&gt; ((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))) -&gt; (GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-definition'>createUptoN'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>createFpUptoN'</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>wrapAction</span> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, a))</span><span class='hs-varid'>action</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 805: </span><span class='hs-comment'>{-# INLINE createUptoN' #-}</span>
<span class=hs-linenum> 806: </span>
<span class=hs-linenum> 807: </span><span class='hs-comment'>-- | Given the maximum size needed and a function to make the contents</span>
<span class=hs-linenum> 808: </span><span class='hs-comment'>-- of a ByteString, createAndTrim makes the 'ByteString'. The generating</span>
<span class=hs-linenum> 809: </span><span class='hs-comment'>-- function is required to return the actual final size (&lt;= the maximum</span>
<span class=hs-linenum> 810: </span><span class='hs-comment'>-- size), and the resulting byte array is reallocated to this size.</span>
<span class=hs-linenum> 811: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 812: </span><span class='hs-comment'>-- createAndTrim is the main mechanism for creating custom, efficient</span>
<span class=hs-linenum> 813: </span><span class='hs-comment'>-- ByteString functions, using Haskell or C functions to fill the space.</span>
<span class=hs-linenum> 814: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 815: </span><span class='hs-definition'>createAndTrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 816: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; ((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)) -&gt; (GHC.Types.IO Data.ByteString.Internal.Type.ByteString)</span><span class='hs-definition'>createAndTrim</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>createFpAndTrim</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>wrapAction</span> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Int)</span><span class='hs-varid'>action</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 817: </span><span class='hs-comment'>{-# INLINE createAndTrim #-}</span>
<span class=hs-linenum> 818: </span>
<span class=hs-linenum> 819: </span><span class='hs-definition'>createAndTrim'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 820: </span><a class=annot href="#"><span class=annottext>forall a .
GHC.Types.Int -&gt; ((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, GHC.Types.Int, a))) -&gt; (GHC.Types.IO (Data.ByteString.Internal.Type.ByteString, a))</span><span class='hs-definition'>createAndTrim'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, GHC.Types.Int, a))</span><span class='hs-varid'>action</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>createFpAndTrim'</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, GHC.Types.Int, a))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>wrapAction</span> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Types.Int, GHC.Types.Int, a))</span><span class='hs-varid'>action</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 821: </span><span class='hs-comment'>{-# INLINE createAndTrim' #-}</span>
<span class=hs-linenum> 822: </span>
<span class=hs-linenum> 823: </span>
<span class=hs-linenum> 824: </span><span class='hs-comment'>-- | Wrapper of 'Foreign.ForeignPtr.mallocForeignPtrBytes' with faster implementation for GHC</span>
<span class=hs-linenum> 825: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 826: </span><span class='hs-definition'>mallocByteString</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForeignPtr</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 827: </span><a class=annot href="#"><span class=annottext>forall a .
GHC.Types.Int -&gt; (GHC.Types.IO (GHC.ForeignPtr.ForeignPtr a))</span><span class='hs-definition'>mallocByteString</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mallocPlainForeignPtrBytes</span>
<span class=hs-linenum> 828: </span><span class='hs-comment'>{-# INLINE mallocByteString #-}</span>
<span class=hs-linenum> 829: </span>
<span class=hs-linenum> 830: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum> 831: </span><span class='hs-comment'>-- Implementations for Eq, Ord and Monoid instances</span>
<span class=hs-linenum> 832: </span>
<span class=hs-linenum> 833: </span><span class='hs-definition'>eq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum> 834: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Internal.Type.ByteString -&gt; GHC.Types.Bool</span><span class='hs-definition'>eq</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>a</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>b</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp'</span> <span class='hs-varid'>len'</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 835: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>/=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len'}</span><span class='hs-varid'>len'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not v
                      &amp;&amp; v == False}</span><span class='hs-conid'>False</span></a>    <span class='hs-comment'>-- short cut on length</span>
<span class=hs-linenum> 836: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp'}</span><span class='hs-varid'>fp'</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v
                      &amp;&amp; v == True}</span><span class='hs-conid'>True</span></a>     <span class='hs-comment'>-- short cut for the same string</span>
<span class=hs-linenum> 837: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Ordering</span><span class='hs-varid'>compareBytes</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == a}</span><span class='hs-varid'>a</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == b
                                                &amp;&amp; v == BS fp' len'}</span><span class='hs-varid'>b</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | v == EQ}</span><span class='hs-conid'>EQ</span></a>
<span class=hs-linenum> 838: </span><span class='hs-comment'>{-# INLINE eq #-}</span>
<span class=hs-linenum> 839: </span><span class='hs-comment'>-- ^ still needed</span>
<span class=hs-linenum> 840: </span>
<span class=hs-linenum> 841: </span><span class='hs-definition'>compareBytes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<span class=hs-linenum> 842: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Internal.Type.ByteString -&gt; GHC.Types.Ordering</span><span class='hs-definition'>compareBytes</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span>   <span class='hs-num'>0</span><span class='hs-layout'>)</span>    <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span>   <span class='hs-num'>0</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | v == EQ}</span><span class='hs-conid'>EQ</span></a>  <span class='hs-comment'>-- short cut for empty strings</span>
<span class=hs-linenum> 843: </span><span class='hs-definition'>compareBytes</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp1</span> <span class='hs-varid'>len1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp2</span> <span class='hs-varid'>len2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 844: </span>    <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Types.Ordering) -&gt; GHC.Types.Ordering</span><span class='hs-varid'>accursedUnutterablePerformIO</span></a> <span class='hs-varop'>$</span>
<span class=hs-linenum> 845: </span>      <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Ordering)) -&gt; (GHC.Types.IO GHC.Types.Ordering)</span><span class='hs-varid'>unsafeWithForeignPtr</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp1</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>p1</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 846: </span>      <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO GHC.Types.Ordering)) -&gt; (GHC.Types.IO GHC.Types.Ordering)</span><span class='hs-varid'>unsafeWithForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp2}</span><span class='hs-varid'>fp2</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>p2</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 847: </span>        <a class=annot href="#"><span class=annottext>Foreign.C.Types.CInt</span><span class='hs-varid'>i</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO Foreign.C.Types.CInt)</span><span class='hs-varid'>memcmp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p1}</span><span class='hs-varid'>p1</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p2}</span><span class='hs-varid'>p2</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>min</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len1</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len2}</span><span class='hs-varid'>len2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 848: </span>        <a class=annot href="#"><span class=annottext>forall a . a -&gt; (GHC.Types.IO a)</span><span class='hs-varid'>return</span></a> <span class='hs-varop'>$!</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : Foreign.C.Types.CInt | v == i}</span><span class='hs-varid'>i</span></a> <span class='hs-varop'>`compare`</span> <a class=annot href="#"><span class=annottext>Foreign.C.Types.CInt</span><span class='hs-num'>0</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum> 849: </span>                    <span class='hs-conid'>EQ</span>  <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len1</span></a> <span class='hs-varop'>`compare`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len2}</span><span class='hs-varid'>len2</span></a>
<span class=hs-linenum> 850: </span>                    <span class='hs-varid'>x</span>   <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Ordering</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum> 851: </span>
<span class=hs-linenum> 852: </span>
<span class=hs-linenum> 853: </span><span class='hs-comment'>-- | /O(1)/ The empty 'ByteString'</span>
<span class=hs-linenum> 854: </span><span class='hs-definition'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 855: </span><span class='hs-comment'>-- This enables bypassing #457 by not using (polymorphic) mempty in</span>
<span class=hs-linenum> 856: </span><span class='hs-comment'>-- any definitions used by the (Monoid ByteString) instance</span>
<span class=hs-linenum> 857: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>empty</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == nullForeignPtr}</span><span class='hs-varid'>nullForeignPtr</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>
<span class=hs-linenum> 858: </span>
<span class=hs-linenum> 859: </span><span class='hs-definition'>append</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 860: </span><a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Internal.Type.ByteString | false} -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>append</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span>   <span class='hs-num'>0</span><span class='hs-layout'>)</span>    <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>b</span></a>                  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>b</span></a>
<span class=hs-linenum> 861: </span><span class='hs-definition'>append</span> <span class='hs-varid'>a</span>             <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span>   <span class='hs-num'>0</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>a</span></a>
<span class=hs-linenum> 862: </span><span class='hs-definition'>append</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp1</span> <span class='hs-varid'>len1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp2</span> <span class='hs-varid'>len2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 863: </span>    <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>unsafeCreateFp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>checkedAdd</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"append"</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len1}</span><span class='hs-varid'>len1</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len2}</span><span class='hs-varid'>len2</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr1</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 864: </span>      <span class='hs-keyword'>let</span> <span class='hs-varid'>destptr2</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr1</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len1}</span><span class='hs-varid'>len1</span></a>
<span class=hs-linenum> 865: </span>      <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>memcpyFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr1</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp1}</span><span class='hs-varid'>fp1</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len1}</span><span class='hs-varid'>len1</span></a>
<span class=hs-linenum> 866: </span>      <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>memcpyFp</span></a> <span class='hs-varid'>destptr2</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp2}</span><span class='hs-varid'>fp2</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len2}</span><span class='hs-varid'>len2</span></a>
<span class=hs-linenum> 867: </span>
<span class=hs-linenum> 868: </span><span class='hs-definition'>concat</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ByteString</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 869: </span><a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>concat</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>goLen0</span> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a>
<span class=hs-linenum> 870: </span>    <span class='hs-comment'>-- The idea here is we first do a pass over the input list to determine:</span>
<span class=hs-linenum> 871: </span>    <span class='hs-comment'>--</span>
<span class=hs-linenum> 872: </span>    <span class='hs-comment'>--  1. is a copy necessary? e.g. @concat []@, @concat [mempty, "hello"]@,</span>
<span class=hs-linenum> 873: </span>    <span class='hs-comment'>--     and @concat ["hello", mempty, mempty]@ can all be handled without</span>
<span class=hs-linenum> 874: </span>    <span class='hs-comment'>--     copying.</span>
<span class=hs-linenum> 875: </span>    <span class='hs-comment'>--  2. if a copy is necessary, how large is the result going to be?</span>
<span class=hs-linenum> 876: </span>    <span class='hs-comment'>--</span>
<span class=hs-linenum> 877: </span>    <span class='hs-comment'>-- If a copy is necessary then we create a buffer of the appropriate size</span>
<span class=hs-linenum> 878: </span>    <span class='hs-comment'>-- and do another pass over the input list, copying the chunks into the</span>
<span class=hs-linenum> 879: </span>    <span class='hs-comment'>-- buffer. Also, since foreign calls aren't entirely free we skip over</span>
<span class=hs-linenum> 880: </span>    <span class='hs-comment'>-- empty chunks while copying.</span>
<span class=hs-linenum> 881: </span>    <span class='hs-comment'>--</span>
<span class=hs-linenum> 882: </span>    <span class='hs-comment'>-- We pass the original [ByteString] (bss0) through as an argument through</span>
<span class=hs-linenum> 883: </span>    <span class='hs-comment'>-- goLen0, goLen1, and goLen since we will need it again in goCopy. Passing</span>
<span class=hs-linenum> 884: </span>    <span class='hs-comment'>-- it as an explicit argument avoids capturing it in these functions'</span>
<span class=hs-linenum> 885: </span>    <span class='hs-comment'>-- closures which would result in unnecessary closure allocation.</span>
<span class=hs-linenum> 886: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 887: </span>    <span class='hs-comment'>-- It's still possible that the result is empty</span>
<span class=hs-linenum> 888: </span>    <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen0</span></a> <span class='hs-keyword'>_</span>    <span class='hs-conid'>[]</span>                     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == empty}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum> 889: </span>    <span class='hs-varid'>goLen0</span> <span class='hs-varid'>bss0</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span> <span class='hs-num'>0</span>     <span class='hs-conop'>:</span><span class='hs-varid'>bss</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen0</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | v == bss
                                                                                                                                 &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bss</span></a>
<span class=hs-linenum> 890: </span>    <span class='hs-varid'>goLen0</span> <span class='hs-varid'>bss0</span> <span class='hs-layout'>(</span><span class='hs-varid'>bs</span>           <span class='hs-conop'>:</span><span class='hs-varid'>bss</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {v : Data.ByteString.Internal.Type.ByteString | false} -&gt; {v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen1</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | v == bss
                                                                                                                                 &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bss</span></a>
<span class=hs-linenum> 891: </span>
<span class=hs-linenum> 892: </span>    <span class='hs-comment'>-- It's still possible that the result is a single chunk</span>
<span class=hs-linenum> 893: </span>    <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false} -&gt; {VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen1</span></a> <span class='hs-keyword'>_</span>    <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a> <span class='hs-conid'>[]</span>                  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a>
<span class=hs-linenum> 894: </span>    <span class='hs-varid'>goLen1</span> <span class='hs-varid'>bss0</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span> <span class='hs-num'>0</span>  <span class='hs-conop'>:</span><span class='hs-varid'>bss</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false} -&gt; {VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen1</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | v == bss
                                                                                                                                 &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bss</span></a>
<span class=hs-linenum> 895: </span>    <span class='hs-varid'>goLen1</span> <span class='hs-varid'>bss0</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>len</span><span class='hs-conop'>:</span><span class='hs-varid'>bss</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {v : GHC.Types.Int | false} -&gt; {v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>checkedAdd</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"concat"</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>len'</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | v == bss
                                                                                                                                 &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bss</span></a>
<span class=hs-linenum> 896: </span>      <span class='hs-keyword'>where</span> <span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false}</span><span class='hs-varid'>len'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a>
<span class=hs-linenum> 897: </span>
<span class=hs-linenum> 898: </span>    <span class='hs-comment'>-- General case, just find the total length we'll need</span>
<span class=hs-linenum> 899: </span>    <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {VV : GHC.Types.Int | false} -&gt; {VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen</span></a> <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false}</span><span class='hs-varid'>total</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>len</span><span class='hs-conop'>:</span><span class='hs-varid'>bss</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {VV : GHC.Types.Int | false} -&gt; {VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == total'}</span><span class='hs-varid'>total'</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | v == bss
                                                                                                                                 &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bss</span></a>
<span class=hs-linenum> 900: </span>      <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>total'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>checkedAdd</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"concat"</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>total</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 901: </span>    <span class='hs-varid'>goLen</span> <span class='hs-varid'>bss0</span> <span class='hs-varid'>total</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 902: </span>      <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>unsafeCreateFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>total</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>goCopy</span> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | false}</span><span class='hs-varid'>bss0</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a>
<span class=hs-linenum> 903: </span>
<span class=hs-linenum> 904: </span>    <span class='hs-comment'>-- Copy the data</span>
<span class=hs-linenum> 905: </span>    <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>goCopy</span></a> <span class='hs-conid'>[]</span>                  <span class='hs-varop'>!</span><span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : () | v == ()}</span><span class='hs-conid'>()</span></a>
<span class=hs-linenum> 906: </span>    <span class='hs-varid'>goCopy</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span>  <span class='hs-num'>0</span>  <span class='hs-conop'>:</span><span class='hs-varid'>bss</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><span class='hs-varid'>ptr</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : [{VV : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false}&gt; | false} -&gt; {VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>goCopy</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | v == bss
                                                                                                                                 &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bss</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a>
<span class=hs-linenum> 907: </span>    <span class='hs-varid'>goCopy</span> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp</span> <span class='hs-varid'>len</span><span class='hs-conop'>:</span><span class='hs-varid'>bss</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><span class='hs-varid'>ptr</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 908: </span>      <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>memcpyFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 909: </span>      <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>goCopy</span></a> <a class=annot href="#"><span class=annottext>{v : [{v : Data.ByteString.Internal.Type.ByteString | false}]&lt;\_ VV -&gt; {v : Data.ByteString.Internal.Type.ByteString | false}&gt; | v == bss
                                                                                                                                 &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bss</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 910: </span><span class='hs-comment'>{-# NOINLINE concat #-}</span>
<span class=hs-linenum> 911: </span>
<span class=hs-linenum> 912: </span><span class='hs-comment'>{-# RULES
"ByteString concat [] -&gt; empty"
   concat [] = empty
"ByteString concat [bs] -&gt; bs" forall x.
   concat [x] = x
 #-}</span>
<span class=hs-linenum> 918: </span>
<span class=hs-linenum> 919: </span><span class='hs-comment'>-- | Repeats the given ByteString n times.</span>
<span class=hs-linenum> 920: </span><span class='hs-comment'>-- Polymorphic wrapper to make sure any generated</span>
<span class=hs-linenum> 921: </span><span class='hs-comment'>-- specializations are reasonably small.</span>
<span class=hs-linenum> 922: </span><span class='hs-definition'>stimesPolymorphic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 923: </span><span class='hs-comment'>{-# INLINABLE stimesPolymorphic #-}</span>
<span class=hs-linenum> 924: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Real.Integral&lt;[]&gt; a) =&gt;
{VV : a | false} -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>stimesPolymorphic</span></a> <a class=annot href="#"><span class=annottext>{VV : a | false}</span><span class='hs-varid'>nRaw</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Maybe.Maybe {v : GHC.Types.Int | false}) | false}</span><span class='hs-varid'>checkedIntegerToInt</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == n
                               &amp;&amp; v == nRaw}</span><span class='hs-varid'>n</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum> 925: </span>  <span class='hs-conid'>Just</span> <span class='hs-varid'>nInt</span>
<span class=hs-linenum> 926: </span>    <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>nInt</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>  <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false} -&gt; {v : Data.ByteString.Internal.Type.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>stimesNonNegativeInt</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>nInt</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a>
<span class=hs-linenum> 927: </span>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>stimesNegativeErr</span></a>
<span class=hs-linenum> 928: </span>  <span class='hs-conid'>Nothing</span>
<span class=hs-linenum> 929: </span>    <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == n
                               &amp;&amp; v == nRaw}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>&lt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == 0}</span><span class='hs-num'>0</span></a>  <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>stimesNegativeErr</span></a>
<span class=hs-linenum> 930: </span>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BS</span> <span class='hs-keyword'>_</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a>  <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == empty}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum> 931: </span>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>stimesOverflowErr</span></a>
<span class=hs-linenum> 932: </span>  <span class='hs-keyword'>where</span>  <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == nRaw}</span><span class='hs-varid'>n</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == nRaw}</span><span class='hs-varid'>toInteger</span></a> <a class=annot href="#"><span class=annottext>{VV : a | false}</span><span class='hs-varid'>nRaw</span></a>
<span class=hs-linenum> 933: </span>  <span class='hs-comment'>-- By exclusively using n instead of nRaw, the semantics are kept simple</span>
<span class=hs-linenum> 934: </span>  <span class='hs-comment'>-- and the likelihood of potentially dangerous mistakes minimized.</span>
<span class=hs-linenum> 935: </span>
<span class=hs-linenum> 936: </span>
<span class=hs-linenum> 937: </span><span class='hs-comment'>{-
Note [Float error calls out of INLINABLE things]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If a function is marked INLINE or INLINABLE, then when ghc inlines or
specializes it, it duplicates the function body exactly as written.

This feature is useful for systems of rewrite rules, but sometimes
comes at a code-size cost.  One situation where this cost generally
comes with no compensating up-side is when the function in question
calls `error` or something similar.

Such an `error` call is not meaningfully improved by the extra context
inlining or specialization provides, and if inlining or specialization
happens in a different module from where the function was originally
defined, CSE will not be able to de-duplicate the error call floated
out of the inlined RHS and the error call floated out of the original
RHS.  See also https://gitlab.haskell.org/ghc/ghc/-/issues/23823

To mitigate this, we manually float the error calls out of INLINABLE
functions when it is possible to do so.
-}</span>
<span class=hs-linenum> 959: </span>
<span class=hs-linenum> 960: </span><span class='hs-definition'>stimesNegativeErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 961: </span><span class='hs-comment'>-- See Note [Float error calls out of INLINABLE things]</span>
<span class=hs-linenum> 962: </span><a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-definition'>stimesNegativeErr</span></a>
<span class=hs-linenum> 963: </span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"stimes @ByteString: non-negative multiplier expected"</span></a>
<span class=hs-linenum> 964: </span>
<span class=hs-linenum> 965: </span><span class='hs-definition'>stimesOverflowErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 966: </span><span class='hs-comment'>-- See Note [Float error calls out of INLINABLE things]</span>
<span class=hs-linenum> 967: </span><a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-definition'>stimesOverflowErr</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>overflowError</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"stimes"</span></a>
<span class=hs-linenum> 968: </span>
<span class=hs-linenum> 969: </span><span class='hs-comment'>-- | Repeats the given ByteString n times.</span>
<span class=hs-linenum> 970: </span><span class='hs-definition'>stimesNonNegativeInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 971: </span><a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false} -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>stimesNonNegativeInt</span></a> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BS</span> <span class='hs-varid'>fp</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 972: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == empty}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum> 973: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-conid'>BS</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 974: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == empty}</span><span class='hs-varid'>empty</span></a>
<span class=hs-linenum> 975: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>unsafeCreateFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>destfptr</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 976: </span>      <a class=annot href="#"><span class=annottext>GHC.Word.Word8</span><span class='hs-varid'>byte</span></a> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Word.Word8)</span><span class='hs-varid'>peekFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a>
<span class=hs-linenum> 977: </span>      <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>unsafeWithForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == destfptr}</span><span class='hs-varid'>destfptr</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>destptr</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 978: </span>        <span class='hs-varid'>fillBytes</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == destptr}</span><span class='hs-varid'>destptr</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Word.Word8 | v == byte}</span><span class='hs-varid'>byte</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a>
<span class=hs-linenum> 979: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>unsafeCreateFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == size}</span><span class='hs-varid'>size</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 980: </span>      <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>memcpyFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 981: </span>      <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>fillFrom</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 982: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 983: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>size</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>checkedMultiply</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"stimes"</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum> 984: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>halfSize</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == size}</span><span class='hs-varid'>size</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>`div`</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a> <span class='hs-comment'>-- subtraction and division won't overflow</span>
<span class=hs-linenum> 985: </span>
<span class=hs-linenum> 986: </span>    <span class='hs-varid'>fillFrom</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum> 987: </span>    <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; {VV : GHC.Types.Int | false} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>fillFrom</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false}</span><span class='hs-varid'>copied</span></a>
<span class=hs-linenum> 988: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>copied</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == halfSize}</span><span class='hs-varid'>halfSize</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum> 989: </span>        <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>memcpyFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen destptr - copied
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>copied</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>copied</span></a>
<span class=hs-linenum> 990: </span>        <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>fillFrom</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>copied</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 991: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>memcpyFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen destptr - copied
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <span class='hs-varop'>`plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>copied</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>destptr</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == size - copied}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == size}</span><span class='hs-varid'>size</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>copied</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 992: </span>
<span class=hs-linenum> 993: </span>
<span class=hs-linenum> 994: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum> 995: </span>
<span class=hs-linenum> 996: </span><span class='hs-comment'>-- | Conversion between 'Word8' and 'Char'. Should compile to a no-op.</span>
<span class=hs-linenum> 997: </span><span class='hs-definition'>w2c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Char</span>
<span class=hs-linenum> 998: </span><a class=annot href="#"><span class=annottext>GHC.Word.Word8 -&gt; GHC.Types.Char</span><span class='hs-definition'>w2c</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Char</span><span class='hs-varid'>unsafeChr</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>x1:GHC.Word.Word8 -&gt; {v : GHC.Types.Int | v == x1}</span><span class='hs-varid'>fromIntegral</span></a>
<span class=hs-linenum> 999: </span><span class='hs-comment'>{-# INLINE w2c #-}</span>
<span class=hs-linenum>1000: </span>
<span class=hs-linenum>1001: </span><span class='hs-comment'>-- | Unsafe conversion between 'Char' and 'Word8'. This is a no-op and</span>
<span class=hs-linenum>1002: </span><span class='hs-comment'>-- silently truncates to 8 bits Chars &gt; '\255'. It is provided as</span>
<span class=hs-linenum>1003: </span><span class='hs-comment'>-- convenience for ByteString construction.</span>
<span class=hs-linenum>1004: </span><span class='hs-definition'>c2w</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word8</span>
<span class=hs-linenum>1005: </span><a class=annot href="#"><span class=annottext>GHC.Types.Char -&gt; GHC.Word.Word8</span><span class='hs-definition'>c2w</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; {v : GHC.Word.Word8 | v == x1}</span><span class='hs-varid'>fromIntegral</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>GHC.Types.Char -&gt; GHC.Types.Int</span><span class='hs-varid'>ord</span></a>
<span class=hs-linenum>1006: </span><span class='hs-comment'>{-# INLINE c2w #-}</span>
<span class=hs-linenum>1007: </span>
<span class=hs-linenum>1008: </span><span class='hs-comment'>-- | Selects words corresponding to white-space characters in the Latin-1 range</span>
<span class=hs-linenum>1009: </span><span class='hs-definition'>isSpaceWord8</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>1010: </span><a class=annot href="#"><span class=annottext>GHC.Word.Word8 -&gt; GHC.Types.Bool</span><span class='hs-definition'>isSpaceWord8</span></a> <a class=annot href="#"><span class=annottext>GHC.Word.Word8</span><span class='hs-varid'>w8</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>1011: </span>    <span class='hs-comment'>-- Avoid the cost of narrowing arithmetic results to Word8,</span>
<span class=hs-linenum>1012: </span>    <span class='hs-comment'>-- the conversion from Word8 to Word is free.</span>
<span class=hs-linenum>1013: </span>    <span class='hs-keyword'>let</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span>
<span class=hs-linenum>1014: </span>        <span class='hs-varop'>!</span><span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Word | v == w8}</span><span class='hs-varid'>fromIntegral</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Word.Word8 | v == w8}</span><span class='hs-varid'>w8</span></a>
<span class=hs-linenum>1015: </span>     <span class='hs-keyword'>in</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Word | v == w8}</span><span class='hs-varid'>w</span></a> <span class='hs-varop'>.&amp;.</span> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>0x50</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>0</span></a>    <span class='hs-comment'>-- Quick non-whitespace filter</span>
<span class=hs-linenum>1016: </span>        <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Word | v == w8}</span><span class='hs-varid'>w</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>0x21</span></a> <span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>0x7e</span></a> <span class='hs-comment'>-- Second non-whitespace filter</span>
<span class=hs-linenum>1017: </span>        <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Word | v == w8}</span><span class='hs-varid'>w</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>0x20</span></a>     <span class='hs-comment'>-- SP</span>
<span class=hs-linenum>1018: </span>          <span class='hs-varop'>||</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Word | v == w8}</span><span class='hs-varid'>w</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>0xa0</span></a>     <span class='hs-comment'>-- NBSP</span>
<span class=hs-linenum>1019: </span>          <span class='hs-varop'>||</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Word | v == w8}</span><span class='hs-varid'>w</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>0x09</span></a> <span class='hs-varop'>&lt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Word</span><span class='hs-num'>5</span></a><span class='hs-layout'>)</span> <span class='hs-comment'>-- HT, NL, VT, FF, CR</span>
<span class=hs-linenum>1020: </span><span class='hs-comment'>{-# INLINE isSpaceWord8 #-}</span>
<span class=hs-linenum>1021: </span>
<span class=hs-linenum>1022: </span><span class='hs-comment'>-- | Selects white-space characters in the Latin-1 range</span>
<span class=hs-linenum>1023: </span><span class='hs-definition'>isSpaceChar8</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>1024: </span><a class=annot href="#"><span class=annottext>GHC.Types.Char -&gt; GHC.Types.Bool</span><span class='hs-definition'>isSpaceChar8</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Word.Word8 -&gt; GHC.Types.Bool</span><span class='hs-varid'>isSpaceWord8</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>GHC.Types.Char -&gt; GHC.Word.Word8</span><span class='hs-varid'>c2w</span></a>
<span class=hs-linenum>1025: </span><span class='hs-comment'>{-# INLINE isSpaceChar8 #-}</span>
<span class=hs-linenum>1026: </span>
<span class=hs-linenum>1027: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum>1028: </span>
<span class=hs-linenum>1029: </span><span class='hs-comment'>-- | The type of exception raised by 'overflowError'</span>
<span class=hs-linenum>1030: </span><span class='hs-comment'>-- and on failure by overflow-checked arithmetic operations.</span>
<span class=hs-linenum>1031: </span><span class='hs-keyword'>newtype</span> <span class='hs-conid'>SizeOverflowException</span>
<span class=hs-linenum>1032: </span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeOverflowException</span> <span class='hs-conid'>String</span>
<span class=hs-linenum>1033: </span>
<span class=hs-linenum>1034: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-conid'>SizeOverflowException</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>1035: </span>  <span class='hs-varid'>show</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeOverflowException</span> <span class='hs-varid'>err</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>err</span>
<span class=hs-linenum>1036: </span>
<span class=hs-linenum>1037: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>GHC.Exception.Type.SomeException -&gt; (GHC.Maybe.Maybe Data.ByteString.Internal.Type.SizeOverflowException)</span><span class='hs-conid'>Exception</span></a> <span class='hs-conid'>SizeOverflowException</span>
<span class=hs-linenum>1038: </span>
<span class=hs-linenum>1039: </span><span class='hs-comment'>-- | Raises a 'SizeOverflowException',</span>
<span class=hs-linenum>1040: </span><span class='hs-comment'>-- with a message using the given function name.</span>
<span class=hs-linenum>1041: </span><span class='hs-definition'>overflowError</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>1042: </span><a class=annot href="#"><span class=annottext>forall a . [GHC.Types.Char] -&gt; a</span><span class='hs-definition'>overflowError</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>fun</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Exception.Type.Exception Data.ByteString.Internal.Type.SizeOverflowException)</span><span class='hs-varid'>throw</span></a> <span class='hs-varop'>$</span> <span class='hs-conid'>SizeOverflowException</span> <span class='hs-varid'>msg</span>
<span class=hs-linenum>1043: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>msg</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Data.ByteString."</span></a> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == fun
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>fun</span></a> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>": size overflow"</span></a>
<span class=hs-linenum>1044: </span>
<span class=hs-linenum>1045: </span><span class='hs-comment'>-- | Add two non-negative numbers.</span>
<span class=hs-linenum>1046: </span><span class='hs-comment'>-- Calls 'overflowError' on overflow.</span>
<span class=hs-linenum>1047: </span><span class='hs-definition'>checkedAdd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>1048: </span><span class='hs-comment'>{-# INLINE checkedAdd #-}</span>
<span class=hs-linenum>1049: </span><a class=annot href="#"><span class=annottext>[GHC.Types.Char] -&gt; GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-definition'>checkedAdd</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>fun</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a>
<span class=hs-linenum>1050: </span>  <span class='hs-comment'>-- checking "r &lt; 0" here matches the condition in mallocPlainForeignPtrBytes,</span>
<span class=hs-linenum>1051: </span>  <span class='hs-comment'>-- helping the compiler see the latter is redundant in some places</span>
<span class=hs-linenum>1052: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == r}</span><span class='hs-varid'>r</span></a> <span class='hs-varop'>&lt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a . [GHC.Types.Char] -&gt; a | VV == overflowError}</span><span class='hs-varid'>overflowError</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == fun
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>fun</span></a>
<span class=hs-linenum>1053: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == r}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>1054: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>r</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (if x &lt; y then x else y)}</span><span class='hs-varid'>min</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y}</span><span class='hs-varid'>y</span></a>
<span class=hs-linenum>1055: </span>
<span class=hs-linenum>1056: </span><span class='hs-comment'>-- | Multiplies two non-negative numbers.</span>
<span class=hs-linenum>1057: </span><span class='hs-comment'>-- Calls 'overflowError' on overflow.</span>
<span class=hs-linenum>1058: </span><span class='hs-definition'>checkedMultiply</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>1059: </span><span class='hs-comment'>{-# INLINE checkedMultiply #-}</span>
<span class=hs-linenum>1060: </span><a class=annot href="#"><span class=annottext>[GHC.Types.Char] -&gt; GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-definition'>checkedMultiply</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>fun</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varid'>assert</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>min</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y
                     &amp;&amp; v == y#
                     &amp;&amp; v == (y# : int)}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&gt;=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<span class=hs-linenum>1061: </span><span class='hs-cpp'>#if TIMES_INT_2_AVAILABLE</span>
<span class=hs-linenum>1062: </span>  <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>('GHC.Types.IntRep, 'GHC.Types.IntRep, 'GHC.Types.IntRep, GHC.Prim.Int#, GHC.Prim.Int#, GHC.Prim.Int#)</span><span class='hs-varid'>timesInt2</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == x#}</span><span class='hs-varid'>x</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == y#}</span><span class='hs-varid'>y</span></a><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<span class=hs-linenum>1063: </span>    <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>result</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>x1:GHC.Prim.Int# -&gt; {v : GHC.Types.Int | v == (x1 : int)}</span><span class='hs-conid'>I</span></a><span class='hs-cpp'>#</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == result}</span><span class='hs-varid'>result</span></a>
<span class=hs-linenum>1064: </span>    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : forall a . [GHC.Types.Char] -&gt; a | VV == overflowError}</span><span class='hs-varid'>overflowError</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == fun
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>fun</span></a>
<span class=hs-linenum>1065: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum>1066: </span>  <span class='hs-keyword'>case</span> <span class='hs-varid'>timesWord2</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>int2Word</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>int2Word</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<span class=hs-linenum>1067: </span>    <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>hi</span><span class='hs-layout'>,</span> <span class='hs-varid'>lo</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>or</span><span class='hs-cpp'>#</span> <span class='hs-varid'>hi</span> <span class='hs-layout'>(</span><span class='hs-varid'>uncheckedShiftRL</span><span class='hs-cpp'>#</span> <span class='hs-varid'>lo</span> <span class='hs-varid'>shiftAmt</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<span class=hs-linenum>1068: </span>      <span class='hs-num'>0</span><span class='hs-cpp'>##</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>word2Int</span><span class='hs-cpp'>#</span> <span class='hs-varid'>lo</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1069: </span>      <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>overflowError</span> <span class='hs-varid'>fun</span>
<span class=hs-linenum>1070: </span>  <span class='hs-keyword'>where</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>shiftAmt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>finiteBitSize</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span><span class='hs-layout'>)</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span>
<span class=hs-linenum>1071: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum>1072: </span>
<span class=hs-linenum>1073: </span>
<span class=hs-linenum>1074: </span><span class='hs-comment'>-- | Attempts to convert an 'Integer' value to an 'Int', returning</span>
<span class=hs-linenum>1075: </span><span class='hs-comment'>-- 'Nothing' if doing so would result in an overflow.</span>
<span class=hs-linenum>1076: </span><span class='hs-definition'>checkedIntegerToInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>1077: </span><span class='hs-comment'>{-# INLINE checkedIntegerToInt #-}</span>
<span class=hs-linenum>1078: </span><span class='hs-comment'>-- We could use Data.Bits.toIntegralSized, but this hand-rolled</span>
<span class=hs-linenum>1079: </span><span class='hs-comment'>-- version is currently a bit faster as of GHC 9.2.</span>
<span class=hs-linenum>1080: </span><span class='hs-comment'>-- It's even faster to just match on the Integer constructors, but</span>
<span class=hs-linenum>1081: </span><span class='hs-comment'>-- we'd still need a fallback implementation for integer-simple.</span>
<span class=hs-linenum>1082: </span><a class=annot href="#"><span class=annottext>{VV : GHC.Num.Integer.Integer | false} -&gt; {VV : (GHC.Maybe.Maybe {VV : GHC.Types.Int | false}) | false}</span><span class='hs-definition'>checkedIntegerToInt</span></a> <a class=annot href="#"><span class=annottext>{VV : GHC.Num.Integer.Integer | false}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>1083: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | false}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == res}</span><span class='hs-varid'>toInteger</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == res
                     &amp;&amp; v == x}</span><span class='hs-varid'>res</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:a -&gt; {v : (GHC.Maybe.Maybe a) | isJust v
                                         &amp;&amp; fromJust v == x1
                                         &amp;&amp; lqdc##$select v == x1} | VV == Just}</span><span class='hs-conid'>Just</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == res
                     &amp;&amp; v == x}</span><span class='hs-varid'>res</span></a>
<span class=hs-linenum>1084: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}</span><span class='hs-conid'>Nothing</span></a>
<span class=hs-linenum>1085: </span>  <span class='hs-keyword'>where</span>  <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>res</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>fromInteger</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | false}</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>1086: </span>
<span class=hs-linenum>1087: </span>
<span class=hs-linenum>1088: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum>1089: </span>
<span class=hs-linenum>1090: </span><span class='hs-comment'>-- | This \"function\" has a superficial similarity to 'System.IO.Unsafe.unsafePerformIO' but</span>
<span class=hs-linenum>1091: </span><span class='hs-comment'>-- it is in fact a malevolent agent of chaos. It unpicks the seams of reality</span>
<span class=hs-linenum>1092: </span><span class='hs-comment'>-- (and the 'IO' monad) so that the normal rules no longer apply. It lulls you</span>
<span class=hs-linenum>1093: </span><span class='hs-comment'>-- into thinking it is reasonable, but when you are not looking it stabs you</span>
<span class=hs-linenum>1094: </span><span class='hs-comment'>-- in the back and aliases all of your mutable buffers. The carcass of many a</span>
<span class=hs-linenum>1095: </span><span class='hs-comment'>-- seasoned Haskell programmer lie strewn at its feet.</span>
<span class=hs-linenum>1096: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1097: </span><span class='hs-comment'>-- Witness the trail of destruction:</span>
<span class=hs-linenum>1098: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1099: </span><span class='hs-comment'>-- * &lt;https://github.com/haskell/bytestring/commit/71c4b438c675aa360c79d79acc9a491e7bbc26e7&gt;</span>
<span class=hs-linenum>1100: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1101: </span><span class='hs-comment'>-- * &lt;https://github.com/haskell/bytestring/commit/210c656390ae617d9ee3b8bcff5c88dd17cef8da&gt;</span>
<span class=hs-linenum>1102: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1103: </span><span class='hs-comment'>-- * &lt;https://github.com/haskell/aeson/commit/720b857e2e0acf2edc4f5512f2b217a89449a89d&gt;</span>
<span class=hs-linenum>1104: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1105: </span><span class='hs-comment'>-- * &lt;https://ghc.haskell.org/trac/ghc/ticket/3486&gt;</span>
<span class=hs-linenum>1106: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1107: </span><span class='hs-comment'>-- * &lt;https://ghc.haskell.org/trac/ghc/ticket/3487&gt;</span>
<span class=hs-linenum>1108: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1109: </span><span class='hs-comment'>-- * &lt;https://ghc.haskell.org/trac/ghc/ticket/7270&gt;</span>
<span class=hs-linenum>1110: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1111: </span><span class='hs-comment'>-- * &lt;https://gitlab.haskell.org/ghc/ghc/-/issues/22204&gt;</span>
<span class=hs-linenum>1112: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1113: </span><span class='hs-comment'>-- Do not talk about \"safe\"! You do not know what is safe!</span>
<span class=hs-linenum>1114: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1115: </span><span class='hs-comment'>-- Yield not to its blasphemous call! Flee traveller! Flee or you will be</span>
<span class=hs-linenum>1116: </span><span class='hs-comment'>-- corrupted and devoured!</span>
<span class=hs-linenum>1117: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1118: </span><span class='hs-comment'>{-# INLINE accursedUnutterablePerformIO #-}</span>
<span class=hs-linenum>1119: </span><span class='hs-definition'>accursedUnutterablePerformIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>1120: </span><a class=annot href="#"><span class=annottext>forall a . (GHC.Types.IO a) -&gt; a</span><span class='hs-definition'>accursedUnutterablePerformIO</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(('GHC.Types.TupleRep ('[] GHC.Types.RuntimeRep)), ('GHC.Types.BoxedRep 'GHC.Types.Lifted), (GHC.Prim.State# GHC.Prim.RealWorld), a)</span><span class='hs-varid'>m</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Prim.State# GHC.Prim.RealWorld) | v == realWorld#}</span><span class='hs-varid'>realWorld</span></a><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == r}</span><span class='hs-varid'>r</span></a>
<span class=hs-linenum>1121: </span>
<span class=hs-linenum>1122: </span><span class='hs-comment'>-- ---------------------------------------------------------------------</span>
<span class=hs-linenum>1123: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1124: </span><span class='hs-comment'>-- Standard C functions</span>
<span class=hs-linenum>1125: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1126: </span>
<span class=hs-linenum>1127: </span><span class='hs-definition'>memchr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1128: </span><span class='hs-definition'>memcmp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CInt</span>
<span class=hs-linenum>1129: </span><span class='hs-comment'>-- {-# DEPRECATED memset "Use Foreign.Marshal.Utils.fillBytes instead" #-}</span>
<span class=hs-linenum>1130: </span><span class='hs-comment'>-- | deprecated since @bytestring-0.11.5.0@</span>
<span class=hs-linenum>1131: </span><span class='hs-definition'>memset</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1132: </span>
<span class=hs-linenum>1133: </span><span class='hs-comment'>-- #if !PURE_HASKELL</span>
<span class=hs-linenum>1134: </span>
<span class=hs-linenum>1135: </span><span class='hs-comment'>-- foreign import ccall unsafe "string.h strlen" c_strlen</span>
<span class=hs-linenum>1136: </span><span class='hs-comment'>--     :: CString -&gt; IO CSize</span>
<span class=hs-linenum>1137: </span>
<span class=hs-linenum>1138: </span><span class='hs-comment'>-- foreign import ccall unsafe "string.h memchr" c_memchr</span>
<span class=hs-linenum>1139: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; CInt -&gt; CSize -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1140: </span><span class='hs-comment'>-- memchr p w sz = c_memchr p (fromIntegral w) sz</span>
<span class=hs-linenum>1141: </span>
<span class=hs-linenum>1142: </span><span class='hs-comment'>-- foreign import ccall unsafe "string.h memcmp" c_memcmp</span>
<span class=hs-linenum>1143: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; Ptr Word8 -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1144: </span><span class='hs-comment'>-- memcmp p q s = c_memcmp p q (fromIntegral s)</span>
<span class=hs-linenum>1145: </span>
<span class=hs-linenum>1146: </span><span class='hs-comment'>-- foreign import ccall unsafe "string.h memset" c_memset</span>
<span class=hs-linenum>1147: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; CInt -&gt; CSize -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1148: </span><span class='hs-comment'>-- memset p w sz = c_memset p (fromIntegral w) sz</span>
<span class=hs-linenum>1149: </span>
<span class=hs-linenum>1150: </span><span class='hs-comment'>-- #else</span>
<span class=hs-linenum>1151: </span>
<span class=hs-linenum>1152: </span><span class='hs-definition'>c_strlen</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CSize</span>
<span class=hs-linenum>1153: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr Foreign.C.Types.CChar) -&gt; (GHC.Types.IO Foreign.C.Types.CSize)</span><span class='hs-definition'>c_strlen</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr Foreign.C.Types.CChar)</span><span class='hs-varid'>p</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; Foreign.C.Types.CSize</span><span class='hs-varid'>checkedCast</span></a> <span class='hs-varop'>&lt;$!&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Types.Int)</span><span class='hs-conid'>Pure.strlen</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Data.LiquidPtr.castPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr Foreign.C.Types.CChar) | v == p}</span><span class='hs-varid'>p</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>1154: </span>
<span class=hs-linenum>1155: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; GHC.Word.Word8 -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>memchr</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>GHC.Word.Word8</span><span class='hs-varid'>w</span></a> <a class=annot href="#"><span class=annottext>Foreign.C.Types.CSize</span><span class='hs-varid'>len</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Pure.memchr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Word.Word8 | v == w}</span><span class='hs-varid'>w</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>checkedCast</span> <a class=annot href="#"><span class=annottext>{v : Foreign.C.Types.CSize | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>1156: </span>
<span class=hs-linenum>1157: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; (GHC.Types.IO Foreign.C.Types.CInt)</span><span class='hs-definition'>memcmp</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>q</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>s</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; Foreign.C.Types.CInt</span><span class='hs-varid'>checkedCast</span></a> <span class='hs-varop'>&lt;$!&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO GHC.Types.Int)</span><span class='hs-conid'>Pure.memcmp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == q}</span><span class='hs-varid'>q</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == s}</span><span class='hs-varid'>s</span></a>
<span class=hs-linenum>1158: </span>
<span class=hs-linenum>1159: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; GHC.Word.Word8 -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>memset</span></a> <a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>GHC.Word.Word8</span><span class='hs-varid'>w</span></a> <a class=annot href="#"><span class=annottext>Foreign.C.Types.CSize</span><span class='hs-varid'>len</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-varid'>p</span></a> <span class='hs-varop'>&lt;$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>fillBytes</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Word.Word8 | v == w}</span><span class='hs-varid'>w</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>checkedCast</span> <a class=annot href="#"><span class=annottext>{v : Foreign.C.Types.CSize | v == len}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>1160: </span>
<span class=hs-linenum>1161: </span><span class='hs-comment'>-- #endif</span>
<span class=hs-linenum>1162: </span>
<span class=hs-linenum>1163: </span><span class='hs-comment'>-- {-# DEPRECATED memcpy "Use Foreign.Marshal.Utils.copyBytes instead" #-}</span>
<span class=hs-linenum>1164: </span><span class='hs-comment'>-- | deprecated since @bytestring-0.11.5.0@</span>
<span class=hs-linenum>1165: </span><span class='hs-comment'>-- memcpy :: Ptr Word8 -&gt; Ptr Word8 -&gt; Int -&gt; IO ()</span>
<span class=hs-linenum>1166: </span><span class='hs-comment'>-- memcpy = copyBytes</span>
<span class=hs-linenum>1167: </span>
<span class=hs-linenum>1168: </span><span class='hs-definition'>memcpyFp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ForeignPtr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>1169: </span><a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>memcpyFp</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fq</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>s</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>unsafeWithForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>p</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>1170: </span>                     <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>unsafeWithForeignPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fq}</span><span class='hs-varid'>fq</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8)</span><span class='hs-varid'>q</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>copyBytes</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == p}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == q}</span><span class='hs-varid'>q</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == s}</span><span class='hs-varid'>s</span></a>
<span class=hs-linenum>1171: </span>
<span class=hs-linenum>1172: </span><span class='hs-definition'>c_free_finalizer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunPtr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1173: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.FunPtr (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ()))</span><span class='hs-definition'>c_free_finalizer</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>finalizerFree</span>
<span class=hs-linenum>1174: </span>
<span class=hs-linenum>1175: </span>
<span class=hs-linenum>1176: </span>
<span class=hs-linenum>1177: </span><span class='hs-comment'>-- ---------------------------------------------------------------------</span>
<span class=hs-linenum>1178: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1179: </span><span class='hs-comment'>-- Uses our C code</span>
<span class=hs-linenum>1180: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>1181: </span>
<span class=hs-linenum>1182: </span><span class='hs-comment'>-- #if !PURE_HASKELL</span>
<span class=hs-linenum>1183: </span>
<span class=hs-linenum>1184: </span><span class='hs-comment'>-- foreign import ccall unsafe "static fpstring.h fps_reverse" c_reverse</span>
<span class=hs-linenum>1185: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; Ptr Word8 -&gt; CSize -&gt; IO ()</span>
<span class=hs-linenum>1186: </span>
<span class=hs-linenum>1187: </span><span class='hs-comment'>-- foreign import ccall unsafe "static fpstring.h fps_intersperse" c_intersperse</span>
<span class=hs-linenum>1188: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; Ptr Word8 -&gt; CSize -&gt; Word8 -&gt; IO ()</span>
<span class=hs-linenum>1189: </span>
<span class=hs-linenum>1190: </span><span class='hs-comment'>-- foreign import ccall unsafe "static fpstring.h fps_maximum" c_maximum</span>
<span class=hs-linenum>1191: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; CSize -&gt; IO Word8</span>
<span class=hs-linenum>1192: </span>
<span class=hs-linenum>1193: </span><span class='hs-comment'>-- foreign import ccall unsafe "static fpstring.h fps_minimum" c_minimum</span>
<span class=hs-linenum>1194: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; CSize -&gt; IO Word8</span>
<span class=hs-linenum>1195: </span>
<span class=hs-linenum>1196: </span><span class='hs-comment'>-- foreign import ccall unsafe "static fpstring.h fps_count" c_count</span>
<span class=hs-linenum>1197: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; CSize -&gt; Word8 -&gt; IO CSize</span>
<span class=hs-linenum>1198: </span>
<span class=hs-linenum>1199: </span><span class='hs-comment'>-- -- fps_count works with both pointers and ByteArray#</span>
<span class=hs-linenum>1200: </span><span class='hs-comment'>-- foreign import ccall unsafe "static fpstring.h fps_count" c_count_ba</span>
<span class=hs-linenum>1201: </span><span class='hs-comment'>--     :: ByteArray# -&gt; CSize -&gt; Word8 -&gt; IO CSize</span>
<span class=hs-linenum>1202: </span>
<span class=hs-linenum>1203: </span><span class='hs-comment'>-- foreign import ccall unsafe "static fpstring.h fps_sort" c_sort</span>
<span class=hs-linenum>1204: </span><span class='hs-comment'>--     :: Ptr Word8 -&gt; CSize -&gt; IO ()</span>
<span class=hs-linenum>1205: </span>
<span class=hs-linenum>1206: </span><span class='hs-comment'>-- foreign import ccall unsafe "static sbs_elem_index"</span>
<span class=hs-linenum>1207: </span><span class='hs-comment'>--     c_elem_index :: ByteArray# -&gt; Word8 -&gt; CSize -&gt; IO CPtrdiff</span>
<span class=hs-linenum>1208: </span>
<span class=hs-linenum>1209: </span>
<span class=hs-linenum>1210: </span>
<span class=hs-linenum>1211: </span><span class='hs-comment'>-- foreign import ccall unsafe "static _hs_bytestring_uint_dec" c_uint_dec</span>
<span class=hs-linenum>1212: </span><span class='hs-comment'>--     :: CUInt -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1213: </span>
<span class=hs-linenum>1214: </span><span class='hs-comment'>-- foreign import ccall unsafe "static _hs_bytestring_long_long_uint_dec" c_long_long_uint_dec</span>
<span class=hs-linenum>1215: </span><span class='hs-comment'>--     :: CULLong -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1216: </span>
<span class=hs-linenum>1217: </span><span class='hs-comment'>-- foreign import ccall unsafe "static _hs_bytestring_int_dec" c_int_dec</span>
<span class=hs-linenum>1218: </span><span class='hs-comment'>--     :: CInt -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1219: </span>
<span class=hs-linenum>1220: </span><span class='hs-comment'>-- foreign import ccall unsafe "static _hs_bytestring_long_long_int_dec" c_long_long_int_dec</span>
<span class=hs-linenum>1221: </span><span class='hs-comment'>--     :: CLLong -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1222: </span>
<span class=hs-linenum>1223: </span><span class='hs-comment'>-- foreign import ccall unsafe "static _hs_bytestring_uint_hex" c_uint_hex</span>
<span class=hs-linenum>1224: </span><span class='hs-comment'>--     :: CUInt -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1225: </span>
<span class=hs-linenum>1226: </span><span class='hs-comment'>-- foreign import ccall unsafe "static _hs_bytestring_long_long_uint_hex" c_long_long_uint_hex</span>
<span class=hs-linenum>1227: </span><span class='hs-comment'>--     :: CULLong -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1228: </span>
<span class=hs-linenum>1229: </span><span class='hs-comment'>-- foreign import ccall unsafe "static _hs_bytestring_int_dec_padded9"</span>
<span class=hs-linenum>1230: </span><span class='hs-comment'>--     c_int_dec_padded9 :: CInt -&gt; Ptr Word8 -&gt; IO ()</span>
<span class=hs-linenum>1231: </span>
<span class=hs-linenum>1232: </span><span class='hs-comment'>-- foreign import ccall unsafe "static _hs_bytestring_long_long_int_dec_padded18"</span>
<span class=hs-linenum>1233: </span><span class='hs-comment'>--     c_long_long_int_dec_padded18 :: CLLong -&gt; Ptr Word8 -&gt; IO ()</span>
<span class=hs-linenum>1234: </span>
<span class=hs-linenum>1235: </span><span class='hs-comment'>-- -- We import bytestring_is_valid_utf8 both unsafe and safe. For small inputs</span>
<span class=hs-linenum>1236: </span><span class='hs-comment'>-- -- we can use the unsafe version to get a bit more performance, but for large</span>
<span class=hs-linenum>1237: </span><span class='hs-comment'>-- -- inputs the safe version should be used to avoid GC synchronization pauses</span>
<span class=hs-linenum>1238: </span><span class='hs-comment'>-- -- in multithreaded contexts.</span>
<span class=hs-linenum>1239: </span>
<span class=hs-linenum>1240: </span><span class='hs-comment'>-- foreign import ccall unsafe "bytestring_is_valid_utf8" cIsValidUtf8BA</span>
<span class=hs-linenum>1241: </span><span class='hs-comment'>--   :: ByteArray# -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1242: </span>
<span class=hs-linenum>1243: </span><span class='hs-comment'>-- foreign import ccall safe "bytestring_is_valid_utf8" cIsValidUtf8BASafe</span>
<span class=hs-linenum>1244: </span><span class='hs-comment'>--   :: ByteArray# -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1245: </span>
<span class=hs-linenum>1246: </span><span class='hs-comment'>-- foreign import ccall unsafe "bytestring_is_valid_utf8" cIsValidUtf8</span>
<span class=hs-linenum>1247: </span><span class='hs-comment'>--   :: Ptr Word8 -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1248: </span>
<span class=hs-linenum>1249: </span><span class='hs-comment'>-- foreign import ccall safe "bytestring_is_valid_utf8" cIsValidUtf8Safe</span>
<span class=hs-linenum>1250: </span><span class='hs-comment'>--   :: Ptr Word8 -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1251: </span>
<span class=hs-linenum>1252: </span>
<span class=hs-linenum>1253: </span><span class='hs-comment'>-- #else</span>
<span class=hs-linenum>1254: </span>
<span class=hs-linenum>1255: </span><span class='hs-definition'>c_reverse</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>1256: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>c_reverse</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1257: </span>
<span class=hs-linenum>1258: </span><span class='hs-definition'>c_intersperse</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>1259: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; Foreign.C.Types.CSize -&gt; GHC.Word.Word8 -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>c_intersperse</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1260: </span>
<span class=hs-linenum>1261: </span><span class='hs-definition'>c_maximum</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Word8</span>
<span class=hs-linenum>1262: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO GHC.Word.Word8)</span><span class='hs-definition'>c_maximum</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1263: </span>
<span class=hs-linenum>1264: </span><span class='hs-definition'>c_minimum</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Word8</span>
<span class=hs-linenum>1265: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO GHC.Word.Word8)</span><span class='hs-definition'>c_minimum</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1266: </span>
<span class=hs-linenum>1267: </span><span class='hs-definition'>c_count</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CSize</span>
<span class=hs-linenum>1268: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; Foreign.C.Types.CSize -&gt; GHC.Word.Word8 -&gt; (GHC.Types.IO Foreign.C.Types.CSize)</span><span class='hs-definition'>c_count</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1269: </span>
<span class=hs-linenum>1270: </span><span class='hs-definition'>c_count_ba</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteArray</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CSize</span>
<span class=hs-linenum>1271: </span><a class=annot href="#"><span class=annottext>GHC.Prim.ByteArray# -&gt; Foreign.C.Types.CSize -&gt; GHC.Word.Word8 -&gt; (GHC.Types.IO Foreign.C.Types.CSize)</span><span class='hs-definition'>c_count_ba</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1272: </span>
<span class=hs-linenum>1273: </span><span class='hs-definition'>c_sort</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>1274: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>c_sort</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1275: </span>
<span class=hs-linenum>1276: </span><span class='hs-definition'>c_elem_index</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteArray</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CPtrdiff</span>
<span class=hs-linenum>1277: </span><a class=annot href="#"><span class=annottext>GHC.Prim.ByteArray# -&gt; GHC.Word.Word8 -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO Foreign.C.Types.CPtrdiff)</span><span class='hs-definition'>c_elem_index</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1278: </span>
<span class=hs-linenum>1279: </span><span class='hs-definition'>c_uint_dec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CUInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1280: </span><a class=annot href="#"><span class=annottext>Foreign.C.Types.CUInt -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>c_uint_dec</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1281: </span>
<span class=hs-linenum>1282: </span><span class='hs-definition'>c_long_long_uint_dec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CULLong</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1283: </span><a class=annot href="#"><span class=annottext>Foreign.C.Types.CULLong -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>c_long_long_uint_dec</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1284: </span>
<span class=hs-linenum>1285: </span><span class='hs-definition'>c_int_dec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1286: </span><a class=annot href="#"><span class=annottext>Foreign.C.Types.CInt -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>c_int_dec</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1287: </span>
<span class=hs-linenum>1288: </span><span class='hs-definition'>c_long_long_int_dec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CLLong</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1289: </span><a class=annot href="#"><span class=annottext>Foreign.C.Types.CLLong -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>c_long_long_int_dec</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1290: </span>
<span class=hs-linenum>1291: </span><span class='hs-definition'>c_uint_hex</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CUInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1292: </span><a class=annot href="#"><span class=annottext>Foreign.C.Types.CUInt -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>c_uint_hex</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1293: </span>
<span class=hs-linenum>1294: </span><span class='hs-definition'>c_long_long_uint_hex</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CULLong</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>1295: </span><a class=annot href="#"><span class=annottext>Foreign.C.Types.CULLong -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>c_long_long_uint_hex</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1296: </span>
<span class=hs-linenum>1297: </span><span class='hs-definition'>c_int_dec_padded9</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>1298: </span><a class=annot href="#"><span class=annottext>Foreign.C.Types.CInt -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>c_int_dec_padded9</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1299: </span>
<span class=hs-linenum>1300: </span><span class='hs-definition'>c_long_long_int_dec_padded18</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CLLong</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>1301: </span><a class=annot href="#"><span class=annottext>Foreign.C.Types.CLLong -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>c_long_long_int_dec_padded18</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1302: </span>
<span class=hs-linenum>1303: </span><span class='hs-definition'>cIsValidUtf8</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CInt</span>
<span class=hs-linenum>1304: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO Foreign.C.Types.CInt)</span><span class='hs-definition'>cIsValidUtf8</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1305: </span>
<span class=hs-linenum>1306: </span><span class='hs-definition'>cIsValidUtf8BA</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteArray</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CInt</span>
<span class=hs-linenum>1307: </span><a class=annot href="#"><span class=annottext>GHC.Prim.ByteArray# -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO Foreign.C.Types.CInt)</span><span class='hs-definition'>cIsValidUtf8BA</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1308: </span>
<span class=hs-linenum>1309: </span><span class='hs-definition'>cIsValidUtf8BASafe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteArray</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CInt</span>
<span class=hs-linenum>1310: </span><a class=annot href="#"><span class=annottext>GHC.Prim.ByteArray# -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO Foreign.C.Types.CInt)</span><span class='hs-definition'>cIsValidUtf8BASafe</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1311: </span>
<span class=hs-linenum>1312: </span><span class='hs-definition'>cIsValidUtf8Safe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CInt</span>
<span class=hs-linenum>1313: </span><a class=annot href="#"><span class=annottext>(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; Foreign.C.Types.CSize -&gt; (GHC.Types.IO Foreign.C.Types.CInt)</span><span class='hs-definition'>cIsValidUtf8Safe</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<span class=hs-linenum>1314: </span>
<span class=hs-linenum>1315: </span><span class='hs-comment'>----------------------------------------------------------------</span>
<span class=hs-linenum>1316: </span><span class='hs-comment'>-- Haskell version of functions in fpstring.c</span>
<span class=hs-linenum>1317: </span><span class='hs-comment'>----------------------------------------------------------------</span>
<span class=hs-linenum>1318: </span>
<span class=hs-linenum>1319: </span><span class='hs-comment'>-- | Reverse n-bytes from the second pointer into the first</span>
<span class=hs-linenum>1320: </span><span class='hs-comment'>-- c_reverse :: Ptr Word8 -&gt; Ptr Word8 -&gt; CSize -&gt; IO ()</span>
<span class=hs-linenum>1321: </span><span class='hs-comment'>-- c_reverse p1 p2 sz = Pure.reverseBytes p1 p2 (checkedCast sz)</span>
<span class=hs-linenum>1322: </span>
<span class=hs-linenum>1323: </span><span class='hs-comment'>-- | find maximum char in a packed string</span>
<span class=hs-linenum>1324: </span><span class='hs-comment'>-- c_maximum :: Ptr Word8 -&gt; CSize -&gt; IO Word8</span>
<span class=hs-linenum>1325: </span><span class='hs-comment'>-- c_maximum ptr sz = Pure.findMaximum ptr (checkedCast sz)</span>
<span class=hs-linenum>1326: </span>
<span class=hs-linenum>1327: </span><span class='hs-comment'>-- -- | find minimum char in a packed string</span>
<span class=hs-linenum>1328: </span><span class='hs-comment'>-- c_minimum :: Ptr Word8 -&gt; CSize -&gt; IO Word8</span>
<span class=hs-linenum>1329: </span><span class='hs-comment'>-- c_minimum ptr sz = Pure.findMinimum ptr (checkedCast sz)</span>
<span class=hs-linenum>1330: </span>
<span class=hs-linenum>1331: </span><span class='hs-comment'>-- -- | count the number of occurrences of a char in a string</span>
<span class=hs-linenum>1332: </span><span class='hs-comment'>-- c_count :: Ptr Word8 -&gt; CSize -&gt; Word8 -&gt; IO CSize</span>
<span class=hs-linenum>1333: </span><span class='hs-comment'>-- c_count ptr sz c = checkedCast &lt;$!&gt; Pure.countOcc ptr (checkedCast sz) c</span>
<span class=hs-linenum>1334: </span>
<span class=hs-linenum>1335: </span><span class='hs-comment'>-- -- | count the number of occurrences of a char in a string</span>
<span class=hs-linenum>1336: </span><span class='hs-comment'>-- c_count_ba :: ByteArray# -&gt; Int -&gt; Word8 -&gt; IO CSize</span>
<span class=hs-linenum>1337: </span><span class='hs-comment'>-- c_count_ba ba o c = checkedCast &lt;$!&gt; Pure.countOccBA ba o c</span>
<span class=hs-linenum>1338: </span>
<span class=hs-linenum>1339: </span><span class='hs-comment'>-- -- | duplicate a string, interspersing the character through the elements of the</span>
<span class=hs-linenum>1340: </span><span class='hs-comment'>-- -- duplicated string</span>
<span class=hs-linenum>1341: </span><span class='hs-comment'>-- c_intersperse :: Ptr Word8 -&gt; Ptr Word8 -&gt; CSize -&gt; Word8 -&gt; IO ()</span>
<span class=hs-linenum>1342: </span><span class='hs-comment'>-- c_intersperse p1 p2 sz e = Pure.intersperse p1 p2 (checkedCast sz) e</span>
<span class=hs-linenum>1343: </span>
<span class=hs-linenum>1344: </span><span class='hs-comment'>-- -- | Quick sort bytes</span>
<span class=hs-linenum>1345: </span><span class='hs-comment'>-- c_sort :: Ptr Word8 -&gt; CSize -&gt; IO ()</span>
<span class=hs-linenum>1346: </span><span class='hs-comment'>-- c_sort ptr sz = Pure.quickSort ptr (checkedCast sz)</span>
<span class=hs-linenum>1347: </span>
<span class=hs-linenum>1348: </span><span class='hs-comment'>-- c_elem_index :: ByteArray# -&gt; Word8 -&gt; CSize -&gt; IO CPtrdiff</span>
<span class=hs-linenum>1349: </span><span class='hs-comment'>-- c_elem_index ba e sz = checkedCast &lt;$!&gt; Pure.elemIndex ba e (checkedCast sz)</span>
<span class=hs-linenum>1350: </span>
<span class=hs-linenum>1351: </span><span class='hs-comment'>-- cIsValidUtf8BA :: ByteArray# -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1352: </span><span class='hs-comment'>-- cIsValidUtf8BA ba sz = bool_to_cint &lt;$&gt; Pure.isValidUtf8BA ba (checkedCast sz)</span>
<span class=hs-linenum>1353: </span>
<span class=hs-linenum>1354: </span><span class='hs-comment'>-- cIsValidUtf8 :: Ptr Word8 -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1355: </span><span class='hs-comment'>-- cIsValidUtf8 ptr sz = bool_to_cint &lt;$&gt; Pure.isValidUtf8 ptr (checkedCast sz)</span>
<span class=hs-linenum>1356: </span>
<span class=hs-linenum>1357: </span><span class='hs-comment'>-- -- Pure module is compiled with `-fno-omit-yields` so it's always safe (it won't</span>
<span class=hs-linenum>1358: </span><span class='hs-comment'>-- -- block on large inputs)</span>
<span class=hs-linenum>1359: </span>
<span class=hs-linenum>1360: </span><span class='hs-comment'>-- cIsValidUtf8BASafe :: ByteArray# -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1361: </span><span class='hs-comment'>-- cIsValidUtf8BASafe = cIsValidUtf8BA</span>
<span class=hs-linenum>1362: </span>
<span class=hs-linenum>1363: </span><span class='hs-comment'>-- cIsValidUtf8Safe :: Ptr Word8 -&gt; CSize -&gt; IO CInt</span>
<span class=hs-linenum>1364: </span><span class='hs-comment'>-- cIsValidUtf8Safe = cIsValidUtf8</span>
<span class=hs-linenum>1365: </span>
<span class=hs-linenum>1366: </span><span class='hs-definition'>bool_to_cint</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CInt</span>
<span class=hs-linenum>1367: </span><a class=annot href="#"><span class=annottext>GHC.Types.Bool -&gt; Foreign.C.Types.CInt</span><span class='hs-definition'>bool_to_cint</span></a> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == 1}</span><span class='hs-num'>1</span></a>
<span class=hs-linenum>1368: </span><span class='hs-definition'>bool_to_cint</span> <span class='hs-conid'>False</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Num.Integer.Integer | v == 0}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>1369: </span>
<span class=hs-linenum>1370: </span><span class='hs-definition'>checkedCast</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bits</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bits</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>1371: </span><a class=annot href="#"><span class=annottext>forall a b .
(GHC.Bits.Bits&lt;[]&gt; a, GHC.Bits.Bits&lt;[]&gt; b, GHC.Real.Integral&lt;[]&gt; a, GHC.Real.Integral&lt;[]&gt; b) =&gt;
a -&gt; b</span><span class='hs-definition'>checkedCast</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>1372: </span>  <span class='hs-varid'>fromMaybe</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><span class='hs-varid'>errorWithoutStackTrace</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"checkedCast: overflow"</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>1373: </span>            <a class=annot href="#"><span class=annottext>(GHC.Maybe.Maybe a)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>toIntegralSized</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>1374: </span>
<span class=hs-linenum>1375: </span><span class='hs-comment'>----------------------------------------------------------------</span>
<span class=hs-linenum>1376: </span><span class='hs-comment'>-- Haskell version of functions in itoa.c</span>
<span class=hs-linenum>1377: </span><span class='hs-comment'>----------------------------------------------------------------</span>
<span class=hs-linenum>1378: </span>
<span class=hs-linenum>1379: </span><span class='hs-comment'>-- c_int_dec :: CInt -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1380: </span><span class='hs-comment'>-- c_int_dec = Pure.encodeSignedDec</span>
<span class=hs-linenum>1381: </span>
<span class=hs-linenum>1382: </span><span class='hs-comment'>-- c_long_long_int_dec :: CLLong -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1383: </span><span class='hs-comment'>-- c_long_long_int_dec = Pure.encodeSignedDec</span>
<span class=hs-linenum>1384: </span>
<span class=hs-linenum>1385: </span><span class='hs-comment'>-- c_uint_dec :: CUInt -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1386: </span><span class='hs-comment'>-- c_uint_dec = Pure.encodeUnsignedDec</span>
<span class=hs-linenum>1387: </span>
<span class=hs-linenum>1388: </span><span class='hs-comment'>-- c_long_long_uint_dec :: CULLong -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1389: </span><span class='hs-comment'>-- c_long_long_uint_dec = Pure.encodeUnsignedDec</span>
<span class=hs-linenum>1390: </span>
<span class=hs-linenum>1391: </span><span class='hs-comment'>-- c_uint_hex :: CUInt -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1392: </span><span class='hs-comment'>-- c_uint_hex = Pure.encodeUnsignedHex</span>
<span class=hs-linenum>1393: </span>
<span class=hs-linenum>1394: </span><span class='hs-comment'>-- c_long_long_uint_hex :: CULLong -&gt; Ptr Word8 -&gt; IO (Ptr Word8)</span>
<span class=hs-linenum>1395: </span><span class='hs-comment'>-- c_long_long_uint_hex = Pure.encodeUnsignedHex</span>
<span class=hs-linenum>1396: </span>
<span class=hs-linenum>1397: </span><span class='hs-comment'>-- c_int_dec_padded9 :: CInt -&gt; Ptr Word8 -&gt; IO ()</span>
<span class=hs-linenum>1398: </span><span class='hs-comment'>-- c_int_dec_padded9 = Pure.encodeUnsignedDecPadded 9</span>
<span class=hs-linenum>1399: </span>
<span class=hs-linenum>1400: </span><span class='hs-comment'>-- c_long_long_int_dec_padded18 :: CLLong -&gt; Ptr Word8 -&gt; IO ()</span>
<span class=hs-linenum>1401: </span><span class='hs-comment'>-- c_long_long_int_dec_padded18 = Pure.encodeUnsignedDecPadded 18</span>
<span class=hs-linenum>1402: </span>
<span class=hs-linenum>1403: </span><span class='hs-comment'>-- #endif</span>
</pre>
</body>
</html>