<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>/Users/pratyushsahu/Desktop/Research/bytestring_lh-llm/Data/ByteString/Builder/Prim/Internal.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>  1: </span><a class=annot href="#"><span class=annottext>GHC.Types.Module</span><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables, CPP #-}</span></a>
<span class=hs-linenum>  2: </span><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<span class=hs-linenum>  3: </span><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<span class=hs-linenum>  4: </span><span class='hs-comment'>-- |</span>
<span class=hs-linenum>  5: </span><span class='hs-comment'>-- Copyright   : 2010-2011 Simon Meier, 2010 Jasper van der Jeugt</span>
<span class=hs-linenum>  6: </span><span class='hs-comment'>-- License     : BSD3-style (see LICENSE)</span>
<span class=hs-linenum>  7: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>  8: </span><span class='hs-comment'>-- Maintainer  : Simon Meier &lt;iridcode@gmail.com&gt;</span>
<span class=hs-linenum>  9: </span><span class='hs-comment'>-- Stability   : unstable, private</span>
<span class=hs-linenum> 10: </span><span class='hs-comment'>-- Portability : GHC</span>
<span class=hs-linenum> 11: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 12: </span><span class='hs-comment'>-- *Warning:* this module is internal. If you find that you need it please</span>
<span class=hs-linenum> 13: </span><span class='hs-comment'>-- contact the maintainers and explain what you are trying to do and discuss</span>
<span class=hs-linenum> 14: </span><span class='hs-comment'>-- what you would need in the public API. It is important that you do this as</span>
<span class=hs-linenum> 15: </span><span class='hs-comment'>-- the module may not be exposed at all in future releases.</span>
<span class=hs-linenum> 16: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 17: </span><span class='hs-comment'>-- The maintainers are glad to accept patches for further</span>
<span class=hs-linenum> 18: </span><span class='hs-comment'>-- standard encodings of standard Haskell values.</span>
<span class=hs-linenum> 19: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 20: </span><span class='hs-comment'>-- If you need to write your own builder primitives, then be aware that you are</span>
<span class=hs-linenum> 21: </span><span class='hs-comment'>-- writing code with /all safety belts off/; i.e.,</span>
<span class=hs-linenum> 22: </span><span class='hs-comment'>-- *this is the code that might make your application vulnerable to buffer-overflow attacks!*</span>
<span class=hs-linenum> 23: </span><span class='hs-comment'>-- The "Data.ByteString.Builder.Prim.Tests" module provides you with</span>
<span class=hs-linenum> 24: </span><span class='hs-comment'>-- utilities for testing your encodings thoroughly.</span>
<span class=hs-linenum> 25: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 26: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.ByteString.Builder.Prim.Internal</span> <span class='hs-layout'>(</span>
<span class=hs-linenum> 27: </span>  <span class='hs-comment'>-- * Fixed-size builder primitives</span>
<span class=hs-linenum> 28: </span>    <span class='hs-conid'>Size</span>
<span class=hs-linenum> 29: </span>  <span class='hs-layout'>,</span> <span class='hs-conid'>FixedPrim</span>
<span class=hs-linenum> 30: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>fixedPrim</span>
<span class=hs-linenum> 31: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>size</span>
<span class=hs-linenum> 32: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>runF</span>
<span class=hs-linenum> 33: </span>
<span class=hs-linenum> 34: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>emptyF</span>
<span class=hs-linenum> 35: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>contramapF</span>
<span class=hs-linenum> 36: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>pairF</span>
<span class=hs-linenum> 37: </span>  <span class='hs-comment'>-- , liftIOF</span>
<span class=hs-linenum> 38: </span>
<span class=hs-linenum> 39: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>storableToF</span>
<span class=hs-linenum> 40: </span>
<span class=hs-linenum> 41: </span>  <span class='hs-comment'>-- * Bounded-size builder primitives</span>
<span class=hs-linenum> 42: </span>  <span class='hs-layout'>,</span> <span class='hs-conid'>BoundedPrim</span>
<span class=hs-linenum> 43: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>boundedPrim</span>
<span class=hs-linenum> 44: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>sizeBound</span>
<span class=hs-linenum> 45: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>runB</span>
<span class=hs-linenum> 46: </span>
<span class=hs-linenum> 47: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>emptyB</span>
<span class=hs-linenum> 48: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>contramapB</span>
<span class=hs-linenum> 49: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>pairB</span>
<span class=hs-linenum> 50: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>eitherB</span>
<span class=hs-linenum> 51: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>condB</span>
<span class=hs-linenum> 52: </span>
<span class=hs-linenum> 53: </span>  <span class='hs-comment'>-- , liftIOB</span>
<span class=hs-linenum> 54: </span>
<span class=hs-linenum> 55: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>toB</span>
<span class=hs-linenum> 56: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>liftFixedToBounded</span>
<span class=hs-linenum> 57: </span>
<span class=hs-linenum> 58: </span>  <span class='hs-comment'>-- , withSizeFB</span>
<span class=hs-linenum> 59: </span>  <span class='hs-comment'>-- , withSizeBB</span>
<span class=hs-linenum> 60: </span>
<span class=hs-linenum> 61: </span>  <span class='hs-comment'>-- * Shared operators</span>
<span class=hs-linenum> 62: </span>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 63: </span>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 64: </span>
<span class=hs-linenum> 65: </span>  <span class='hs-comment'>-- * Helpers</span>
<span class=hs-linenum> 66: </span>  <span class='hs-comment'>-- , caseWordSize_32_64</span>
<span class=hs-linenum> 67: </span>
<span class=hs-linenum> 68: </span>  <span class='hs-comment'>-- * Deprecated</span>
<span class=hs-linenum> 69: </span>  <span class='hs-comment'>-- , boudedPrim</span>
<span class=hs-linenum> 70: </span>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 71: </span>
<span class=hs-linenum> 72: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign</span>
<span class=hs-linenum> 73: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>maxBound</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 74: </span>
<span class=hs-linenum> 75: </span><span class='hs-cpp'>#include "MachDeps.h"</span>
<span class=hs-linenum> 76: </span><span class='hs-cpp'>#include "bytestring-cpp-macros.h"</span>
<span class=hs-linenum> 77: </span>
<span class=hs-linenum> 78: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum> 79: </span><span class='hs-comment'>-- Supporting infrastructure</span>
<span class=hs-linenum> 80: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum> 81: </span>
<span class=hs-linenum> 82: </span><span class='hs-comment'>-- | Contravariant functors as in the @contravariant@ package.</span>
<span class=hs-linenum> 83: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>Contravariant</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 84: </span>    <span class='hs-varid'>contramap</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<span class=hs-linenum> 85: </span>
<span class=hs-linenum> 86: </span><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>&gt;$&lt;</span>
<span class=hs-linenum> 87: </span>
<span class=hs-linenum> 88: </span><span class='hs-comment'>-- | A fmap-like operator for builder primitives, both bounded and fixed size.</span>
<span class=hs-linenum> 89: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 90: </span><span class='hs-comment'>-- Builder primitives are contravariant so it's like the normal fmap, but</span>
<span class=hs-linenum> 91: </span><span class='hs-comment'>-- backwards (look at the type). (If it helps to remember, the operator symbol</span>
<span class=hs-linenum> 92: </span><span class='hs-comment'>-- is like (&lt;$&gt;) but backwards.)</span>
<span class=hs-linenum> 93: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 94: </span><span class='hs-comment'>-- We can use it for example to prepend and/or append fixed values to an</span>
<span class=hs-linenum> 95: </span><span class='hs-comment'>-- primitive.</span>
<span class=hs-linenum> 96: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 97: </span><span class='hs-comment'>-- &gt; import Data.ByteString.Builder.Prim as P</span>
<span class=hs-linenum> 98: </span><span class='hs-comment'>-- &gt;showEncoding ((\x -&gt; ('\'', (x, '\''))) &gt;$&lt; fixed3) 'x' = "'x'"</span>
<span class=hs-linenum> 99: </span><span class='hs-comment'>-- &gt;  where</span>
<span class=hs-linenum>100: </span><span class='hs-comment'>-- &gt;    fixed3 = P.char7 &gt;*&lt; P.char7 &gt;*&lt; P.char7</span>
<span class=hs-linenum>101: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>102: </span><span class='hs-comment'>-- Note that the rather verbose syntax for composition stems from the</span>
<span class=hs-linenum>103: </span><span class='hs-comment'>-- requirement to be able to compute the size / size bound at compile time.</span>
<span class=hs-linenum>104: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>105: </span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Contravariant</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>106: </span><a class=annot href="#"><span class=annottext>forall a b c .
(Data.ByteString.Builder.Prim.Internal.Contravariant&lt;[]&gt; a) =&gt;
(b -&gt; c) -&gt; a c -&gt; a b</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramap</span>
<span class=hs-linenum>107: </span>
<span class=hs-linenum>108: </span>
<span class=hs-linenum>109: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Contravariant Data.ByteString.Builder.Prim.Internal.FixedPrim)</span><span class='hs-conid'>Contravariant</span></a> <span class='hs-conid'>FixedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>110: </span>    <a class=annot href="#"><span class=annottext>forall a b .
(a -&gt; b) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-varid'>contramap</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramapF</span>
<span class=hs-linenum>111: </span>
<span class=hs-linenum>112: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Contravariant Data.ByteString.Builder.Prim.Internal.BoundedPrim)</span><span class='hs-conid'>Contravariant</span></a> <span class='hs-conid'>BoundedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>113: </span>    <a class=annot href="#"><span class=annottext>forall a b .
(a -&gt; b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>contramap</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramapB</span>
<span class=hs-linenum>114: </span>
<span class=hs-linenum>115: </span>
<span class=hs-linenum>116: </span><span class='hs-comment'>-- | Type-constructors supporting lifting of type-products.</span>
<span class=hs-linenum>117: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>Monoidal</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>118: </span>    <span class='hs-varid'>pair</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>119: </span>
<span class=hs-linenum>120: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Monoidal Data.ByteString.Builder.Prim.Internal.FixedPrim)</span><span class='hs-conid'>Monoidal</span></a> <span class='hs-conid'>FixedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>121: </span>    <a class=annot href="#"><span class=annottext>forall a b .
x1:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; x2:(Data.ByteString.Builder.Prim.Internal.FixedPrim b) -&gt; {v : (Data.ByteString.Builder.Prim.Internal.FixedPrim (a, b)) | size v == size x1 + size x2}</span><span class='hs-varid'>pair</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pairF</span>
<span class=hs-linenum>122: </span>
<span class=hs-linenum>123: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Monoidal Data.ByteString.Builder.Prim.Internal.BoundedPrim)</span><span class='hs-conid'>Monoidal</span></a> <span class='hs-conid'>BoundedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>124: </span>    <a class=annot href="#"><span class=annottext>forall a b .
(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (a, b))</span><span class='hs-varid'>pair</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pairB</span>
<span class=hs-linenum>125: </span>
<span class=hs-linenum>126: </span><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span> <span class='hs-varop'>&gt;*&lt;</span>
<span class=hs-linenum>127: </span>
<span class=hs-linenum>128: </span><span class='hs-comment'>-- | A pairing/concatenation operator for builder primitives, both bounded and</span>
<span class=hs-linenum>129: </span><span class='hs-comment'>-- fixed size.</span>
<span class=hs-linenum>130: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>131: </span><span class='hs-comment'>-- For example,</span>
<span class=hs-linenum>132: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>133: </span><span class='hs-comment'>-- &gt; toLazyByteString (primFixed (char7 &gt;*&lt; char7) ('x','y')) = "xy"</span>
<span class=hs-linenum>134: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>135: </span><span class='hs-comment'>-- We can combine multiple primitives using '&gt;*&lt;' multiple times.</span>
<span class=hs-linenum>136: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>137: </span><span class='hs-comment'>-- &gt; toLazyByteString (primFixed (char7 &gt;*&lt; char7 &gt;*&lt; char7) ('x',('y','z'))) = "xyz"</span>
<span class=hs-linenum>138: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>139: </span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monoidal</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>140: </span><a class=annot href="#"><span class=annottext>forall a b c .
(Data.ByteString.Builder.Prim.Internal.Monoidal&lt;[]&gt; a) =&gt;
a b -&gt; a c -&gt; a (b, c)</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pair</span>
<span class=hs-linenum>141: </span>
<span class=hs-linenum>142: </span>
<span class=hs-linenum>143: </span><span class='hs-comment'>-- | The type used for sizes and sizeBounds of sizes.</span>
<span class=hs-linenum>144: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Size</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>145: </span>
<span class=hs-linenum>146: </span>
<span class=hs-linenum>147: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>148: </span><span class='hs-comment'>-- Fixed-size builder primitives</span>
<span class=hs-linenum>149: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>150: </span>
<span class=hs-linenum>151: </span><span class='hs-comment'>-- | A builder primitive that always results in a sequence of bytes of a</span>
<span class=hs-linenum>152: </span><span class='hs-comment'>-- pre-determined, fixed size.</span>
<span class=hs-linenum>153: </span><span class='hs-comment'>-- ifdef LIQUID</span>
<span class=hs-linenum>154: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<span class=hs-linenum>155: </span><span class='hs-comment'>-- else </span>
<span class=hs-linenum>156: </span><span class='hs-comment'>-- data FixedPrim a = FP {-# UNPACK #-} !Int (a -&gt; Ptr Word8 -&gt; IO ())</span>
<span class=hs-linenum>157: </span><span class='hs-comment'>-- endif</span>
<span class=hs-linenum>158: </span>
<span class=hs-linenum>159: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PtrGN</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrV</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>N</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>plen</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>160: </span>
<span class=hs-linenum>161: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fpSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span><span class='hs-layout'>,</span> <span class='hs-varid'>fpFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>fpSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>162: </span>
<span class=hs-linenum>163: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fixedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>164: </span><span class='hs-definition'>fixedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>165: </span><a class=annot href="#"><span class=annottext>forall a .
x1:{VV : GHC.Types.Int | VV &gt;= 0} -&gt; (a -&gt; {VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                                                                &amp;&amp; x1 &lt;= plen VV} -&gt; (GHC.Types.IO ())) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>fixedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span>
<span class=hs-linenum>166: </span>
<span class=hs-linenum>167: </span><span class='hs-comment'>-- | The size of the sequences of bytes generated by this 'FixedPrim'.</span>
<span class=hs-linenum>168: </span><span class='hs-comment'>{-# INLINE CONLIKE size #-}</span>
<span class=hs-linenum>169: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>size</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>170: </span><span class='hs-definition'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>171: </span><a class=annot href="#"><span class=annottext>forall a .
x1:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; {VV : GHC.Types.Int | VV == size x1}</span><span class='hs-definition'>size</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>172: </span>
<span class=hs-linenum>173: </span>
<span class=hs-linenum>174: </span><span class='hs-comment'>{-# INLINE CONLIKE runF #-}</span>
<span class=hs-linenum>175: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>runF</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>fp</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>{size fp}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>176: </span><span class='hs-definition'>runF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>177: </span><a class=annot href="#"><span class=annottext>forall a .
x1:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; a -&gt; {VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                                                                                    &amp;&amp; size x1 &lt;= plen VV} -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>runF</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; {v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>io</span></a>
<span class=hs-linenum>178: </span>
<span class=hs-linenum>179: </span><span class='hs-comment'>-- | The 'FixedPrim' that always results in the zero-length sequence.</span>
<span class=hs-linenum>180: </span><span class='hs-comment'>{-# INLINE CONLIKE emptyF #-}</span>
<span class=hs-linenum>181: </span><span class='hs-definition'>emptyF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>182: </span><a class=annot href="#"><span class=annottext>forall a . (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>emptyF</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>{v : () | v == ()}</span><span class='hs-conid'>()</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>183: </span>
<span class=hs-linenum>184: </span><span class='hs-comment'>-- | Encode a pair by encoding its first component and then its second component.</span>
<span class=hs-linenum>185: </span><span class='hs-comment'>{-# INLINE CONLIKE pairF #-}</span>
<span class=hs-linenum>186: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>pairF</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>fpa</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fpb</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fpab:</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>| size fpab = size fpa + size fpb }</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>187: </span><span class='hs-definition'>pairF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>188: </span><a class=annot href="#"><span class=annottext>forall a b .
x1:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; x2:(Data.ByteString.Builder.Prim.Internal.FixedPrim b) -&gt; {fpab : (Data.ByteString.Builder.Prim.Internal.FixedPrim (a, b)) | size fpab == size x1 + size x2}</span><span class='hs-definition'>pairF</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>189: </span>    <a class=annot href="#"><span class=annottext>(a, b) -&gt; {VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                               &amp;&amp; l1 &lt;= plen VV
                                               &amp;&amp; l2 &lt;= plen VV} -&gt; (GHC.Types.IO ())</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l1 + l2}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l1
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>l1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l2
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>l2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(a, b)</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                     &amp;&amp; l1 &lt;= plen VV
                                     &amp;&amp; l2 &lt;= plen VV}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x1}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == op
                                    &amp;&amp; 0 &lt;= plen v
                                    &amp;&amp; l1 &lt;= plen v
                                    &amp;&amp; l2 &lt;= plen v}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x2}</span><span class='hs-varid'>x2</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | pbase v == pbase op
                                    &amp;&amp; plen v == plen op - l1
                                    &amp;&amp; 0 &lt;= plen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == op
                                    &amp;&amp; 0 &lt;= plen v
                                    &amp;&amp; l1 &lt;= plen v
                                    &amp;&amp; l2 &lt;= plen v}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`plusPtr`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l1
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>l1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-comment'>-- | Change a primitives such that it first applies a function to the value</span>
<span class=hs-linenum>192: </span><span class='hs-comment'>-- to be encoded.</span>
<span class=hs-linenum>193: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>194: </span><span class='hs-comment'>-- Note that primitives are 'Contravariant'</span>
<span class=hs-linenum>195: </span><span class='hs-comment'>-- &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a>&gt;. Hence, the following</span>
<span class=hs-linenum>196: </span><span class='hs-comment'>-- laws hold.</span>
<span class=hs-linenum>197: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>198: </span><span class='hs-comment'>-- &gt;contramapF id = id</span>
<span class=hs-linenum>199: </span><span class='hs-comment'>-- &gt;contramapF f . contramapF g = contramapF (g . f)</span>
<span class=hs-linenum>200: </span><span class='hs-comment'>{-# INLINE CONLIKE contramapF #-}</span>
<span class=hs-linenum>201: </span><span class='hs-definition'>contramapF</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>202: </span><a class=annot href="#"><span class=annottext>forall a b .
(a -&gt; b) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>contramapF</span></a> <a class=annot href="#"><span class=annottext>a -&gt; b</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; (a -&gt; {v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                                                                   &amp;&amp; x1 &lt;= plen v} -&gt; (GHC.Types.IO ())) -&gt; {v : (Data.ByteString.Builder.Prim.Internal.FixedPrim a) | fpSize v == x1
                                                                                                                                                                                        &amp;&amp; size v == x1} | VV == FP}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>a -&gt; {v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                         &amp;&amp; l &lt;= plen v} -&gt; (GHC.Types.IO ())</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>a -&gt; {v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                         &amp;&amp; l &lt;= plen v} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>io</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>a -&gt; b</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>203: </span>
<span class=hs-linenum>204: </span><span class='hs-comment'>-- | Convert a 'FixedPrim' to a 'BoundedPrim'.</span>
<span class=hs-linenum>205: </span><span class='hs-comment'>{-# INLINE CONLIKE toB #-}</span>
<span class=hs-linenum>206: </span><span class='hs-definition'>toB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>207: </span><a class=annot href="#"><span class=annottext>forall a .
(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>toB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; {VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                          &amp;&amp; l &lt;= plen VV} -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                     &amp;&amp; l &lt;= plen VV}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == op
                                    &amp;&amp; 0 &lt;= plen v
                                    &amp;&amp; l &lt;= plen v}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>forall a . a -&gt; (GHC.Types.IO a)</span><span class='hs-varid'>return</span></a> <span class='hs-varop'>$!</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == op
                                    &amp;&amp; 0 &lt;= plen v
                                    &amp;&amp; l &lt;= plen v}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`plusPtr`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == l
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>208: </span>
<span class=hs-linenum>209: </span><span class='hs-comment'>-- | Lift a 'FixedPrim' to a 'BoundedPrim'.</span>
<span class=hs-linenum>210: </span><span class='hs-comment'>{-# INLINE CONLIKE liftFixedToBounded #-}</span>
<span class=hs-linenum>211: </span><span class='hs-definition'>liftFixedToBounded</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>212: </span><a class=annot href="#"><span class=annottext>forall a .
(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>liftFixedToBounded</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toB</span>
<span class=hs-linenum>213: </span>
<span class=hs-linenum>214: </span><span class='hs-comment'>{-# INLINE CONLIKE storableToF #-}</span>
<span class=hs-linenum>215: </span><span class='hs-comment'>{-# DEPRECATED storableToF
     "Deprecated since @bytestring-0.12.1.0@.\n\nThis function is dangerous in the presence of internal padding\nand makes naive assumptions about alignment.\n\n * For a primitive Haskell type like 'Int64', use the\n   corresponding primitive like 'Data.ByteString.Builder.Prim.int64Host'.\n * For other types, it is recommended to manually write a small\n   function that performs the necessary unaligned write\n   and zeroes or removes any internal padding bits."
  #-}</span>
<span class=hs-linenum>218: </span><span class='hs-definition'>storableToF</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>219: </span><span class='hs-cpp'>#if HS_UNALIGNED_POKES_OK</span>
<span class=hs-linenum>220: </span><span class='hs-definition'>storableToF</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizeOf</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>op</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>poke</span> <span class='hs-layout'>(</span><span class='hs-varid'>castPtr</span> <span class='hs-varid'>op</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<span class=hs-linenum>221: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum>222: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
(Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>storableToF</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(a -&gt; (GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sizeOf</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Ptr.Ptr GHC.Word.Word8) | false}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>223: </span>    <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>Foreign.Ptr.WordPtr</span><span class='hs-varid'>ptrToWordPtr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | false}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`mod`</span> <a class=annot href="#"><span class=annottext>Foreign.Ptr.WordPtr</span><span class='hs-varid'>fromIntegral</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>alignment</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>Foreign.Ptr.WordPtr</span><span class='hs-num'>0</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{v : (Foreign.Storable.Storable a) | v == $dStorable_a1Wu}</span><span class='hs-varid'>poke</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | plen v == plen op
                       &amp;&amp; 0 &lt;= plen v}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>castPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | false}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>224: </span>    <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>((GHC.Ptr.Ptr a) -&gt; (GHC.Types.IO ())) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>with</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      (GHC.Ptr.Ptr a) -&gt; (GHC.Ptr.Ptr a) -&gt; GHC.Types.Int -&gt; (GHC.Types.IO ()) | VV == copyBytes}</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV : (GHC.Ptr.Ptr a) | false}</span><span class='hs-varid'>tp</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>copyBytes</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | false}</span><span class='hs-varid'>op</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | plen v == plen tp
                                    &amp;&amp; 0 &lt;= plen v}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>castPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr a) | false}</span><span class='hs-varid'>tp</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sizeOf</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>225: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum>226: </span>
<span class=hs-linenum>227: </span><span class='hs-comment'>{-
{-# INLINE CONLIKE liftIOF #-}
liftIOF :: FixedPrim a -&gt; FixedPrim (IO a)
liftIOF (FP l io) = FP l (\xWrapped op -&gt; do x &lt;- xWrapped; io x op)
-}</span>
<span class=hs-linenum>232: </span>
<span class=hs-linenum>233: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>234: </span><span class='hs-comment'>-- Bounded-size builder primitives</span>
<span class=hs-linenum>235: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>236: </span>
<span class=hs-linenum>237: </span><span class='hs-comment'>-- | A builder primitive that always results in sequence of bytes that is no longer</span>
<span class=hs-linenum>238: </span><span class='hs-comment'>-- than a pre-determined bound.</span>
<span class=hs-linenum>239: </span><span class='hs-comment'>-- #ifdef LIQUID</span>
<span class=hs-linenum>240: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>241: </span><span class='hs-comment'>-- #else </span>
<span class=hs-linenum>242: </span><span class='hs-comment'>-- data BoundedPrim a = BP {-# UNPACK #-} !Int (a -&gt; Ptr Word8 -&gt; IO (Ptr Word8))</span>
<span class=hs-linenum>243: </span><span class='hs-comment'>-- #endif </span>
<span class=hs-linenum>244: </span>
<span class=hs-linenum>245: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PtrS</span> <span class='hs-varid'>a</span> <span class='hs-conid'>Base</span> <span class='hs-conid'>Off</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrV</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>plen</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>plen</span> <span class='hs-conid'>Base</span><span class='hs-layout'>)</span> <span class='hs-comment'>-</span> <span class='hs-conid'>Off</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>246: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bpSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span><span class='hs-layout'>,</span> <span class='hs-varid'>bpFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>bpSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-varid'>bpSize</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>247: </span>
<span class=hs-linenum>248: </span><span class='hs-comment'>-- | The bound on the size of sequences of bytes generated by this 'BoundedPrim'.</span>
<span class=hs-linenum>249: </span><span class='hs-comment'>{-# INLINE CONLIKE sizeBound #-}</span>
<span class=hs-linenum>250: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>sizeBound</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>251: </span><span class='hs-definition'>sizeBound</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>252: </span><a class=annot href="#"><span class=annottext>forall a .
x1:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; {VV : GHC.Types.Int | VV == sizeBound x1}</span><span class='hs-definition'>sizeBound</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == b
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>b</span></a>
<span class=hs-linenum>253: </span>
<span class=hs-linenum>254: </span><span class='hs-comment'>-- | @since 0.10.12.0</span>
<span class=hs-linenum>255: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>boundedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>256: </span><span class='hs-definition'>boundedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>257: </span><a class=annot href="#"><span class=annottext>forall a .
x1:{VV : GHC.Types.Int | VV &gt;= 0} -&gt; (a -&gt; x4:{VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                                                                   &amp;&amp; x1 &lt;= plen VV} -&gt; (GHC.Types.IO {VV : (GHC.Ptr.Ptr GHC.Word.Word8) | plen VV &gt;= plen x4 - x1
                                                                                                                                                           &amp;&amp; 0 &lt;= plen VV})) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>boundedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span>
<span class=hs-linenum>258: </span>
<span class=hs-linenum>259: </span><span class='hs-comment'>-- {-# DEPRECATED boudedPrim "Use 'boundedPrim' instead" #-}</span>
<span class=hs-linenum>260: </span><span class='hs-comment'>-- boudedPrim :: Int -&gt; (a -&gt; Ptr Word8 -&gt; IO (Ptr Word8)) -&gt; BoundedPrim a</span>
<span class=hs-linenum>261: </span><span class='hs-comment'>-- boudedPrim = BP</span>
<span class=hs-linenum>262: </span>
<span class=hs-linenum>263: </span><span class='hs-comment'>{-# INLINE CONLIKE runB #-}</span>
<span class=hs-linenum>264: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>runB</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>bp</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-keyword'>{sizeBound bp}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizeBound</span> <span class='hs-varid'>bp</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>265: </span><span class='hs-definition'>runB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>266: </span><a class=annot href="#"><span class=annottext>forall a .
x1:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; a -&gt; x3:{VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                                                                                         &amp;&amp; sizeBound x1 &lt;= plen VV} -&gt; (GHC.Types.IO {VV : (GHC.Ptr.Ptr GHC.Word.Word8) | plen VV &gt;= plen x3 - sizeBound x1
                                                                                                                                                                                           &amp;&amp; 0 &lt;= plen VV})</span><span class='hs-definition'>runB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; {v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v} -&gt; (GHC.Types.IO {v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v})</span><span class='hs-varid'>io</span></a>
<span class=hs-linenum>267: </span>
<span class=hs-linenum>268: </span><span class='hs-comment'>-- | Change a 'BoundedPrim' such that it first applies a function to the</span>
<span class=hs-linenum>269: </span><span class='hs-comment'>-- value to be encoded.</span>
<span class=hs-linenum>270: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>271: </span><span class='hs-comment'>-- Note that 'BoundedPrim's are 'Contravariant'</span>
<span class=hs-linenum>272: </span><span class='hs-comment'>-- &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a>&gt;. Hence, the following</span>
<span class=hs-linenum>273: </span><span class='hs-comment'>-- laws hold.</span>
<span class=hs-linenum>274: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>275: </span><span class='hs-comment'>-- &gt;contramapB id = id</span>
<span class=hs-linenum>276: </span><span class='hs-comment'>-- &gt;contramapB f . contramapB g = contramapB (g . f)</span>
<span class=hs-linenum>277: </span><span class='hs-comment'>{-# INLINE CONLIKE contramapB #-}</span>
<span class=hs-linenum>278: </span><span class='hs-definition'>contramapB</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>279: </span><a class=annot href="#"><span class=annottext>forall a b .
(a -&gt; b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>contramapB</span></a> <a class=annot href="#"><span class=annottext>a -&gt; b</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; (a -&gt; x4:{v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                                                                      &amp;&amp; x1 &lt;= plen v} -&gt; (GHC.Types.IO {v : (GHC.Ptr.Ptr GHC.Word.Word8) | plen v &gt;= plen x4 - x1
                                                                                                                                                            &amp;&amp; 0 &lt;= plen v})) -&gt; {v : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | bpSize v == x1
                                                                                                                                                                                                                                              &amp;&amp; sizeBound v == x1} | VV == BP}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == b
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>a -&gt; x1:{v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                            &amp;&amp; b &lt;= plen v} -&gt; (GHC.Types.IO {v : (GHC.Ptr.Ptr GHC.Word.Word8) | plen v &gt;= plen x1 - b
                                                                                                                 &amp;&amp; 0 &lt;= plen v})</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>a -&gt; x2:{v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                            &amp;&amp; b &lt;= plen v} -&gt; (GHC.Types.IO {v : (GHC.Ptr.Ptr GHC.Word.Word8) | plen v &gt;= plen x2 - b
                                                                                                                 &amp;&amp; 0 &lt;= plen v})</span><span class='hs-varid'>io</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>a -&gt; b</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>280: </span>
<span class=hs-linenum>281: </span><span class='hs-comment'>-- | The 'BoundedPrim' that always results in the zero-length sequence.</span>
<span class=hs-linenum>282: </span><span class='hs-comment'>{-# INLINE CONLIKE emptyB #-}</span>
<span class=hs-linenum>283: </span><span class='hs-definition'>emptyB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>284: </span><a class=annot href="#"><span class=annottext>forall a . (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>emptyB</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == op
                                    &amp;&amp; 0 &lt;= plen v}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>285: </span>
<span class=hs-linenum>286: </span><span class='hs-comment'>-- | Encode a pair by encoding its first component and then its second component.</span>
<span class=hs-linenum>287: </span><span class='hs-comment'>{-# INLINE CONLIKE pairB #-}</span>
<span class=hs-linenum>288: </span><span class='hs-definition'>pairB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>289: </span><a class=annot href="#"><span class=annottext>forall a b .
(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (a, b))</span><span class='hs-definition'>pairB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>290: </span>    <a class=annot href="#"><span class=annottext>(a, b) -&gt; {VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                               &amp;&amp; b1 &lt;= plen VV
                                               &amp;&amp; b2 &lt;= plen VV} -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == b1 + b2}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == b1
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>b1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == b2
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>b2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(a, b)</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                     &amp;&amp; b1 &lt;= plen VV
                                     &amp;&amp; b2 &lt;= plen VV}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {v : (GHC.Ptr.Ptr GHC.Word.Word8) | plen v &gt;= plen op - b1
                                                  &amp;&amp; 0 &lt;= plen v})</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x1}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == op
                                    &amp;&amp; 0 &lt;= plen v
                                    &amp;&amp; b1 &lt;= plen v
                                    &amp;&amp; b2 &lt;= plen v}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;=</span> <a class=annot href="#"><span class=annottext>x1:{v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                       &amp;&amp; b2 &lt;= plen v} -&gt; (GHC.Types.IO {v : (GHC.Ptr.Ptr GHC.Word.Word8) | plen v &gt;= plen x1 - b2
                                                                                                             &amp;&amp; 0 &lt;= plen v})</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x2}</span><span class='hs-varid'>x2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>291: </span>
<span class=hs-linenum>292: </span><span class='hs-comment'>-- | Encode an 'Either' value using the first 'BoundedPrim' for 'Left'</span>
<span class=hs-linenum>293: </span><span class='hs-comment'>-- values and the second 'BoundedPrim' for 'Right' values.</span>
<span class=hs-linenum>294: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>295: </span><span class='hs-comment'>-- Note that the functions 'eitherB', 'pairB', and 'contramapB' (written below</span>
<span class=hs-linenum>296: </span><span class='hs-comment'>-- using '&gt;$&lt;') suffice to construct 'BoundedPrim's for all non-recursive</span>
<span class=hs-linenum>297: </span><span class='hs-comment'>-- algebraic datatypes. For example,</span>
<span class=hs-linenum>298: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>299: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>300: </span><span class='hs-comment'>--maybeB :: BoundedPrim () -&gt; BoundedPrim a -&gt; BoundedPrim (Maybe a)</span>
<span class=hs-linenum>301: </span><span class='hs-comment'>--maybeB nothing just = 'maybe' (Left ()) Right '&gt;$&lt;' eitherB nothing just</span>
<span class=hs-linenum>302: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>303: </span><span class='hs-comment'>{-# INLINE CONLIKE eitherB #-}</span>
<span class=hs-linenum>304: </span><span class='hs-definition'>eitherB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>305: </span><a class=annot href="#"><span class=annottext>forall a b .
(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (Data.Either.Either a b))</span><span class='hs-definition'>eitherB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>306: </span>    <span class='hs-conid'>BP</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (if b1 &gt; b2 then b1 else b2)
                     &amp;&amp; v &gt;= 0}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>max</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == b1
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>b1</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == b2
                     &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>b2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>307: </span>        <a class=annot href="#"><span class=annottext>{v : (Data.Either.Either a b) | v == x}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(Data.Either.Either a b)</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV
                                     &amp;&amp; b1 &lt;= plen VV
                                     &amp;&amp; b2 &lt;= plen VV}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : (Data.Either.Either a b) | v == x}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>of</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>a -&gt; x2:{v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                            &amp;&amp; b1 &lt;= plen v} -&gt; (GHC.Types.IO {v : (GHC.Ptr.Ptr GHC.Word.Word8) | plen v &gt;= plen x2 - b1
                                                                                                                  &amp;&amp; 0 &lt;= plen v})</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x1}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == op
                                    &amp;&amp; 0 &lt;= plen v
                                    &amp;&amp; b1 &lt;= plen v
                                    &amp;&amp; b2 &lt;= plen v}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>;</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>a -&gt; x2:{v : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen v
                                            &amp;&amp; b2 &lt;= plen v} -&gt; (GHC.Types.IO {v : (GHC.Ptr.Ptr GHC.Word.Word8) | plen v &gt;= plen x2 - b2
                                                                                                                  &amp;&amp; 0 &lt;= plen v})</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x2}</span><span class='hs-varid'>x2</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.Ptr.Ptr GHC.Word.Word8) | v == op
                                    &amp;&amp; 0 &lt;= plen v
                                    &amp;&amp; b1 &lt;= plen v
                                    &amp;&amp; b2 &lt;= plen v}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>308: </span>
<span class=hs-linenum>309: </span><span class='hs-comment'>-- | Conditionally select a 'BoundedPrim'.</span>
<span class=hs-linenum>310: </span><span class='hs-comment'>-- For example, we can implement the ASCII primitive that drops characters with</span>
<span class=hs-linenum>311: </span><span class='hs-comment'>-- Unicode codepoints above 127 as follows.</span>
<span class=hs-linenum>312: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>313: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>314: </span><span class='hs-comment'>--charASCIIDrop = 'condB' (&lt; \'\\128\') ('liftFixedToBounded' 'Data.ByteString.Builder.Prim.char7') 'emptyB'</span>
<span class=hs-linenum>315: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>316: </span><span class='hs-comment'>{-# INLINE CONLIKE condB #-}</span>
<span class=hs-linenum>317: </span><span class='hs-definition'>condB</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>318: </span><a class=annot href="#"><span class=annottext>forall a .
(a -&gt; GHC.Types.Bool) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>condB</span></a> <a class=annot href="#"><span class=annottext>a -&gt; GHC.Types.Bool</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>be1</span></a> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>be2</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>319: </span>    <span class='hs-varid'>contramapB</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      a -&gt; {v : (Data.Either.Either a b) | isLeft v} | VV == Left}</span><span class='hs-conid'>Left</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      b -&gt; {v : (Data.Either.Either a b) | not (isLeft v)} | VV == Right}</span><span class='hs-conid'>Right</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim (Data.Either.Either a a))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>eitherB</span> <a class=annot href="#"><span class=annottext>{v : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | v == be1}</span><span class='hs-varid'>be1</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | v == be2}</span><span class='hs-varid'>be2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>320: </span>
</pre>
</body>
</html>