<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>/Users/pratyushsahu/Desktop/Research/bytestring_lh-llm/Data/ByteString/Builder/Prim/Internal.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>  1: </span><a class=annot href="#"><span class=annottext>{VV##3961 : GHC.Types.Module | $k_##3962}</span><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables, CPP #-}</span></a>
<span class=hs-linenum>  2: </span><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<span class=hs-linenum>  3: </span><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<span class=hs-linenum>  4: </span><span class='hs-comment'>-- |</span>
<span class=hs-linenum>  5: </span><span class='hs-comment'>-- Copyright   : 2010-2011 Simon Meier, 2010 Jasper van der Jeugt</span>
<span class=hs-linenum>  6: </span><span class='hs-comment'>-- License     : BSD3-style (see LICENSE)</span>
<span class=hs-linenum>  7: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>  8: </span><span class='hs-comment'>-- Maintainer  : Simon Meier &lt;iridcode@gmail.com&gt;</span>
<span class=hs-linenum>  9: </span><span class='hs-comment'>-- Stability   : unstable, private</span>
<span class=hs-linenum> 10: </span><span class='hs-comment'>-- Portability : GHC</span>
<span class=hs-linenum> 11: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 12: </span><span class='hs-comment'>-- *Warning:* this module is internal. If you find that you need it please</span>
<span class=hs-linenum> 13: </span><span class='hs-comment'>-- contact the maintainers and explain what you are trying to do and discuss</span>
<span class=hs-linenum> 14: </span><span class='hs-comment'>-- what you would need in the public API. It is important that you do this as</span>
<span class=hs-linenum> 15: </span><span class='hs-comment'>-- the module may not be exposed at all in future releases.</span>
<span class=hs-linenum> 16: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 17: </span><span class='hs-comment'>-- The maintainers are glad to accept patches for further</span>
<span class=hs-linenum> 18: </span><span class='hs-comment'>-- standard encodings of standard Haskell values.</span>
<span class=hs-linenum> 19: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 20: </span><span class='hs-comment'>-- If you need to write your own builder primitives, then be aware that you are</span>
<span class=hs-linenum> 21: </span><span class='hs-comment'>-- writing code with /all safety belts off/; i.e.,</span>
<span class=hs-linenum> 22: </span><span class='hs-comment'>-- *this is the code that might make your application vulnerable to buffer-overflow attacks!*</span>
<span class=hs-linenum> 23: </span><span class='hs-comment'>-- The "Data.ByteString.Builder.Prim.Tests" module provides you with</span>
<span class=hs-linenum> 24: </span><span class='hs-comment'>-- utilities for testing your encodings thoroughly.</span>
<span class=hs-linenum> 25: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 26: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.ByteString.Builder.Prim.Internal</span> <span class='hs-layout'>(</span>
<span class=hs-linenum> 27: </span>  <span class='hs-comment'>-- * Fixed-size builder primitives</span>
<span class=hs-linenum> 28: </span>    <span class='hs-conid'>Size</span>
<span class=hs-linenum> 29: </span>  <span class='hs-layout'>,</span> <span class='hs-conid'>FixedPrim</span>
<span class=hs-linenum> 30: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>fixedPrim</span>
<span class=hs-linenum> 31: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>size</span>
<span class=hs-linenum> 32: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>runF</span>
<span class=hs-linenum> 33: </span>
<span class=hs-linenum> 34: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>emptyF</span>
<span class=hs-linenum> 35: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>contramapF</span>
<span class=hs-linenum> 36: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>pairF</span>
<span class=hs-linenum> 37: </span>  <span class='hs-comment'>-- , liftIOF</span>
<span class=hs-linenum> 38: </span>
<span class=hs-linenum> 39: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>storableToF</span>
<span class=hs-linenum> 40: </span>
<span class=hs-linenum> 41: </span>  <span class='hs-comment'>-- * Bounded-size builder primitives</span>
<span class=hs-linenum> 42: </span>  <span class='hs-layout'>,</span> <span class='hs-conid'>BoundedPrim</span>
<span class=hs-linenum> 43: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>boundedPrim</span>
<span class=hs-linenum> 44: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>sizeBound</span>
<span class=hs-linenum> 45: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>runB</span>
<span class=hs-linenum> 46: </span>
<span class=hs-linenum> 47: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>emptyB</span>
<span class=hs-linenum> 48: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>contramapB</span>
<span class=hs-linenum> 49: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>pairB</span>
<span class=hs-linenum> 50: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>eitherB</span>
<span class=hs-linenum> 51: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>condB</span>
<span class=hs-linenum> 52: </span>
<span class=hs-linenum> 53: </span>  <span class='hs-comment'>-- , liftIOB</span>
<span class=hs-linenum> 54: </span>
<span class=hs-linenum> 55: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>toB</span>
<span class=hs-linenum> 56: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>liftFixedToBounded</span>
<span class=hs-linenum> 57: </span>
<span class=hs-linenum> 58: </span>  <span class='hs-comment'>-- , withSizeFB</span>
<span class=hs-linenum> 59: </span>  <span class='hs-comment'>-- , withSizeBB</span>
<span class=hs-linenum> 60: </span>
<span class=hs-linenum> 61: </span>  <span class='hs-comment'>-- * Shared operators</span>
<span class=hs-linenum> 62: </span>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 63: </span>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 64: </span>
<span class=hs-linenum> 65: </span>  <span class='hs-comment'>-- * Helpers</span>
<span class=hs-linenum> 66: </span>  <span class='hs-comment'>-- , caseWordSize_32_64</span>
<span class=hs-linenum> 67: </span>
<span class=hs-linenum> 68: </span>  <span class='hs-comment'>-- * Deprecated</span>
<span class=hs-linenum> 69: </span>  <span class='hs-comment'>-- , boudedPrim</span>
<span class=hs-linenum> 70: </span>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 71: </span>
<span class=hs-linenum> 72: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign</span>
<span class=hs-linenum> 73: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>maxBound</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 74: </span>
<span class=hs-linenum> 75: </span><span class='hs-cpp'>#include "MachDeps.h"</span>
<span class=hs-linenum> 76: </span><span class='hs-cpp'>#include "bytestring-cpp-macros.h"</span>
<span class=hs-linenum> 77: </span>
<span class=hs-linenum> 78: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum> 79: </span><span class='hs-comment'>-- Supporting infrastructure</span>
<span class=hs-linenum> 80: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum> 81: </span>
<span class=hs-linenum> 82: </span><span class='hs-comment'>-- | Contravariant functors as in the @contravariant@ package.</span>
<span class=hs-linenum> 83: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>Contravariant</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 84: </span>    <span class='hs-varid'>contramap</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<span class=hs-linenum> 85: </span>
<span class=hs-linenum> 86: </span><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>&gt;$&lt;</span>
<span class=hs-linenum> 87: </span>
<span class=hs-linenum> 88: </span><span class='hs-comment'>-- | A fmap-like operator for builder primitives, both bounded and fixed size.</span>
<span class=hs-linenum> 89: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 90: </span><span class='hs-comment'>-- Builder primitives are contravariant so it's like the normal fmap, but</span>
<span class=hs-linenum> 91: </span><span class='hs-comment'>-- backwards (look at the type). (If it helps to remember, the operator symbol</span>
<span class=hs-linenum> 92: </span><span class='hs-comment'>-- is like (&lt;$&gt;) but backwards.)</span>
<span class=hs-linenum> 93: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 94: </span><span class='hs-comment'>-- We can use it for example to prepend and/or append fixed values to an</span>
<span class=hs-linenum> 95: </span><span class='hs-comment'>-- primitive.</span>
<span class=hs-linenum> 96: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 97: </span><span class='hs-comment'>-- &gt; import Data.ByteString.Builder.Prim as P</span>
<span class=hs-linenum> 98: </span><span class='hs-comment'>-- &gt;showEncoding ((\x -&gt; ('\'', (x, '\''))) &gt;$&lt; fixed3) 'x' = "'x'"</span>
<span class=hs-linenum> 99: </span><span class='hs-comment'>-- &gt;  where</span>
<span class=hs-linenum>100: </span><span class='hs-comment'>-- &gt;    fixed3 = P.char7 &gt;*&lt; P.char7 &gt;*&lt; P.char7</span>
<span class=hs-linenum>101: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>102: </span><span class='hs-comment'>-- Note that the rather verbose syntax for composition stems from the</span>
<span class=hs-linenum>103: </span><span class='hs-comment'>-- requirement to be able to compute the size / size bound at compile time.</span>
<span class=hs-linenum>104: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>105: </span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Contravariant</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>106: </span><a class=annot href="#"><span class=annottext>forall f b a .
(Data.ByteString.Builder.Prim.Internal.Contravariant&lt;[]&gt; f) =&gt;
lq_tmp$x##791:(lq_tmp$x##789:b -&gt; a) -&gt; lq_tmp$x##792:f a -&gt; f b</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramap</span>
<span class=hs-linenum>107: </span>
<span class=hs-linenum>108: </span>
<span class=hs-linenum>109: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Contravariant Data.ByteString.Builder.Prim.Internal.FixedPrim)</span><span class='hs-conid'>Contravariant</span></a> <span class='hs-conid'>FixedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>110: </span>    <a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##1548:(lq_tmp$x##1547:{lq_tmp$x##1552 : b | $k_##1551[VV##1550:=lq_tmp$x##1552]} -&gt; {lq_tmp$x##1555 : a | $k_##1554[VV##1553:=lq_tmp$x##1555]}) -&gt; lq_tmp$x##1549:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1555 : a | $k_##1554[VV##1553:=lq_tmp$x##1555]}) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1552 : b | $k_##1551[VV##1550:=lq_tmp$x##1552]})</span><span class='hs-varid'>contramap</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramapF</span>
<span class=hs-linenum>111: </span>
<span class=hs-linenum>112: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Contravariant Data.ByteString.Builder.Prim.Internal.BoundedPrim)</span><span class='hs-conid'>Contravariant</span></a> <span class='hs-conid'>BoundedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>113: </span>    <a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##3156:(lq_tmp$x##3155:{lq_tmp$x##3160 : b | $k_##3159[VV##3158:=lq_tmp$x##3160]} -&gt; {lq_tmp$x##3163 : a | $k_##3162[VV##3161:=lq_tmp$x##3163]}) -&gt; lq_tmp$x##3157:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3163 : a | $k_##3162[VV##3161:=lq_tmp$x##3163]}) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3160 : b | $k_##3159[VV##3158:=lq_tmp$x##3160]})</span><span class='hs-varid'>contramap</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramapB</span>
<span class=hs-linenum>114: </span>
<span class=hs-linenum>115: </span>
<span class=hs-linenum>116: </span><span class='hs-comment'>-- | Type-constructors supporting lifting of type-products.</span>
<span class=hs-linenum>117: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>Monoidal</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>118: </span>    <span class='hs-varid'>pair</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>119: </span>
<span class=hs-linenum>120: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Monoidal Data.ByteString.Builder.Prim.Internal.FixedPrim)</span><span class='hs-conid'>Monoidal</span></a> <span class='hs-conid'>FixedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>121: </span>    <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##1351:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1356 : a | $k_##1355[VV##1354:=lq_tmp$x##1356]}) -&gt; lq_tmp$x##1352:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1359 : b | $k_##1358[VV##1357:=lq_tmp$x##1359]}) -&gt; {lq_tmp$x##1348 : (Data.ByteString.Builder.Prim.Internal.FixedPrim ({lq_tmp$x##1356 : a | $k_##1355[VV##1354:=lq_tmp$x##1356]}, {lq_tmp$x##1359 : b | $k_##1358[VV##1357:=lq_tmp$x##1359]})) | Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1348 == Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1351 + Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1352}</span><span class='hs-varid'>pair</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pairF</span>
<span class=hs-linenum>122: </span>
<span class=hs-linenum>123: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Monoidal Data.ByteString.Builder.Prim.Internal.BoundedPrim)</span><span class='hs-conid'>Monoidal</span></a> <span class='hs-conid'>BoundedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>124: </span>    <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3563:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3568 : a | $k_##3567[VV##3566:=lq_tmp$x##3568]}) -&gt; lq_tmp$x##3564:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3571 : b | $k_##3570[VV##3569:=lq_tmp$x##3571]}) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim ({lq_tmp$x##3568 : a | $k_##3567[VV##3566:=lq_tmp$x##3568]}, {lq_tmp$x##3571 : b | $k_##3570[VV##3569:=lq_tmp$x##3571]}))</span><span class='hs-varid'>pair</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pairB</span>
<span class=hs-linenum>125: </span>
<span class=hs-linenum>126: </span><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span> <span class='hs-varop'>&gt;*&lt;</span>
<span class=hs-linenum>127: </span>
<span class=hs-linenum>128: </span><span class='hs-comment'>-- | A pairing/concatenation operator for builder primitives, both bounded and</span>
<span class=hs-linenum>129: </span><span class='hs-comment'>-- fixed size.</span>
<span class=hs-linenum>130: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>131: </span><span class='hs-comment'>-- For example,</span>
<span class=hs-linenum>132: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>133: </span><span class='hs-comment'>-- &gt; toLazyByteString (primFixed (char7 &gt;*&lt; char7) ('x','y')) = "xy"</span>
<span class=hs-linenum>134: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>135: </span><span class='hs-comment'>-- We can combine multiple primitives using '&gt;*&lt;' multiple times.</span>
<span class=hs-linenum>136: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>137: </span><span class='hs-comment'>-- &gt; toLazyByteString (primFixed (char7 &gt;*&lt; char7 &gt;*&lt; char7) ('x',('y','z'))) = "xyz"</span>
<span class=hs-linenum>138: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>139: </span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monoidal</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>140: </span><a class=annot href="#"><span class=annottext>forall f a b .
(Data.ByteString.Builder.Prim.Internal.Monoidal&lt;[]&gt; f) =&gt;
lq_tmp$x##823:f a -&gt; lq_tmp$x##824:f b -&gt; f (a, b)</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pair</span>
<span class=hs-linenum>141: </span>
<span class=hs-linenum>142: </span>
<span class=hs-linenum>143: </span><span class='hs-comment'>-- | The type used for sizes and sizeBounds of sizes.</span>
<span class=hs-linenum>144: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Size</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>145: </span>
<span class=hs-linenum>146: </span>
<span class=hs-linenum>147: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>148: </span><span class='hs-comment'>-- Fixed-size builder primitives</span>
<span class=hs-linenum>149: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>150: </span>
<span class=hs-linenum>151: </span><span class='hs-comment'>-- | A builder primitive that always results in a sequence of bytes of a</span>
<span class=hs-linenum>152: </span><span class='hs-comment'>-- pre-determined, fixed size.</span>
<span class=hs-linenum>153: </span><span class='hs-comment'>-- ifdef LIQUID</span>
<span class=hs-linenum>154: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<span class=hs-linenum>155: </span><span class='hs-comment'>-- else </span>
<span class=hs-linenum>156: </span><span class='hs-comment'>-- data FixedPrim a = FP {-# UNPACK #-} !Int (a -&gt; Ptr Word8 -&gt; IO ())</span>
<span class=hs-linenum>157: </span><span class='hs-comment'>-- endif</span>
<span class=hs-linenum>158: </span>
<span class=hs-linenum>159: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PtrGN</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrV</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>N</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>plen</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>160: </span>
<span class=hs-linenum>161: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fpSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span><span class='hs-layout'>,</span> <span class='hs-varid'>fpFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>fpSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>162: </span>
<span class=hs-linenum>163: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fixedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>164: </span><span class='hs-definition'>fixedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>165: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##861:{VV##0 : GHC.Types.Int | VV##0 &gt;= 0} -&gt; lq_tmp$x##862:(lq_tmp$x##859:a -&gt; lq_tmp$x##860:{VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV##0
                                                                                                                                              &amp;&amp; lq_tmp$x##861 &lt;= plen VV##0} -&gt; (GHC.Types.IO ())) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>fixedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span>
<span class=hs-linenum>166: </span>
<span class=hs-linenum>167: </span><span class='hs-comment'>-- | The size of the sequences of bytes generated by this 'FixedPrim'.</span>
<span class=hs-linenum>168: </span><span class='hs-comment'>{-# INLINE CONLIKE size #-}</span>
<span class=hs-linenum>169: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>size</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>170: </span><span class='hs-definition'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>171: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##900:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; {VV : GHC.Types.Int | VV == Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##900}</span><span class='hs-definition'>size</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##939 : GHC.Types.Int | lq_tmp$x##939 == l##a1Ob
                                 &amp;&amp; lq_tmp$x##939 &gt;= 0}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>172: </span>
<span class=hs-linenum>173: </span>
<span class=hs-linenum>174: </span><span class='hs-comment'>{-# INLINE CONLIKE runF #-}</span>
<span class=hs-linenum>175: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>runF</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>fp</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>{size fp}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>176: </span><span class='hs-definition'>runF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>177: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##941:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; lq_tmp$x##942:a -&gt; lq_tmp$x##943:{VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV##0
                                                                                                                                              &amp;&amp; Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##941 &lt;= plen VV##0} -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>runF</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##989:a -&gt; lq_tmp$x##990:{lq_tmp$x##984 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##984
                                                                                 &amp;&amp; ds_d2TI &lt;= plen lq_tmp$x##984} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>io</span></a>
<span class=hs-linenum>178: </span>
<span class=hs-linenum>179: </span><span class='hs-comment'>-- | The 'FixedPrim' that always results in the zero-length sequence.</span>
<span class=hs-linenum>180: </span><span class='hs-comment'>{-# INLINE CONLIKE emptyF #-}</span>
<span class=hs-linenum>181: </span><span class='hs-definition'>emptyF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>182: </span><a class=annot href="#"><span class=annottext>forall a . (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>emptyF</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1001 : GHC.Types.Int | lq_tmp$x##1001 == (lq_anf$##7205759403792804809##d2UN : int)}</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {lq_tmp$x##1028 : () | $k_##1027[VV##1026:=lq_tmp$x##1028][lq_tmp$x##14:=GHC.Tuple.$40$$41$]})</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1029 : () | lq_tmp$x##1029 == GHC.Tuple.()}</span><span class='hs-conid'>()</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>183: </span>
<span class=hs-linenum>184: </span><span class='hs-comment'>-- | Encode a pair by encoding its first component and then its second component.</span>
<span class=hs-linenum>185: </span><span class='hs-comment'>{-# INLINE CONLIKE pairF #-}</span>
<span class=hs-linenum>186: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>pairF</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>fpa</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fpb</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fpab:</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>| size fpab = size fpa + size fpb }</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>187: </span><span class='hs-definition'>pairF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>188: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##1064:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; lq_tmp$x##1065:(Data.ByteString.Builder.Prim.Internal.FixedPrim b) -&gt; {fpab : (Data.ByteString.Builder.Prim.Internal.FixedPrim (a, b)) | Data.ByteString.Builder.Prim.Internal.size fpab == Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1064 + Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1065}</span><span class='hs-definition'>pairF</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>189: </span>    <a class=annot href="#"><span class=annottext>ds_d2TB:{VV##1167 : ({VV##1160 : a | $k_##1161}, {VV##1162 : b | $k_##1163})&lt;\lq_tmp$x##1164 VV -&gt; {VV##1165 : b | $k_##1166}&gt; | $k_##1168} -&gt; op##a1Oj:{VV##1172 : (GHC.Ptr.Ptr {VV##1170 : GHC.Word.Word8 | $k_##1171}) | $k_##1173} -&gt; {VV##1177 : (GHC.Types.IO {VV##1175 : () | $k_##1176}) | $k_##1178}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1154 : GHC.Types.Int | lq_tmp$x##1154 == l1##a1Od + l2##a1Of}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1157 : GHC.Types.Int | lq_tmp$x##1157 == l1##a1Od
                                  &amp;&amp; lq_tmp$x##1157 &gt;= 0}</span><span class='hs-varid'>l1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1158 : GHC.Types.Int | lq_tmp$x##1158 == l2##a1Of
                                  &amp;&amp; lq_tmp$x##1158 &gt;= 0}</span><span class='hs-varid'>l2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1183 : ({lq_tmp$x##1179 : a | $k_##1161[VV##1160:=lq_tmp$x##1179][VV##1167:=lq_tmp$x##1183]}, {lq_tmp$x##1180 : b | $k_##1163[VV##1162:=lq_tmp$x##1180][VV##1167:=lq_tmp$x##1183]})&lt;\lq_tmp$x##1184 VV -&gt; {lq_tmp$x##1182 : b | $k_##1166[VV##1165:=lq_tmp$x##1182][VV##1167:=lq_tmp$x##1183][lq_tmp$x##1164:=lq_tmp$x##1184][lq_tmp$x##1181:=lq_tmp$x##1184]}&gt; | lq_tmp$x##1183 == ds_d2TB
                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##1168[VV##1167:=lq_tmp$x##1183]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV##1172 : (GHC.Ptr.Ptr {VV##1170 : GHC.Word.Word8 | $k_##1171}) | $k_##1173}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1226 : a | lq_tmp$x##1226 == x1##a1Oh
                      &amp;&amp; $k_##1161[VV##1160:=lq_tmp$x##1226][VV##1167:=lq_anf$##7205759403792804815##d2UT][liquid_internal_this:=lq_anf$##7205759403792804815##d2UT][lq_tmp$x##1179:=lq_tmp$x##1226][lq_tmp$x##1183:=lq_anf$##7205759403792804815##d2UT][lq_tmp$x##1186:=lq_tmp$x##1226][lq_tmp$x##1190:=lq_anf$##7205759403792804815##d2UT]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1228 : (GHC.Ptr.Ptr {lq_tmp$x##1227 : GHC.Word.Word8 | $k_##1171[VV##1170:=lq_tmp$x##1227][VV##1172:=lq_tmp$x##1228]}) | lq_tmp$x##1228 == op##a1Oj
                                                                                                                                    &amp;&amp; $k_##1173[VV##1172:=lq_tmp$x##1228]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1258 : b | lq_tmp$x##1258 == x2##a1Oi
                      &amp;&amp; $k_##1163[VV##1162:=lq_tmp$x##1258][VV##1167:=lq_anf$##7205759403792804815##d2UT][liquid_internal_this:=lq_anf$##7205759403792804815##d2UT][lq_tmp$x##1180:=lq_tmp$x##1258][lq_tmp$x##1183:=lq_anf$##7205759403792804815##d2UT][lq_tmp$x##1187:=lq_tmp$x##1258][lq_tmp$x##1190:=lq_anf$##7205759403792804815##d2UT][lq_tmp$x##1201:=x1##a1Oh]
                      &amp;&amp; $k_##1166[VV##1165:=lq_tmp$x##1258][VV##1167:=lq_anf$##7205759403792804815##d2UT][liquid_internal_this:=lq_anf$##7205759403792804815##d2UT][lq_tmp$x##1164:=x1##a1Oh][lq_tmp$x##1181:=x1##a1Oh][lq_tmp$x##1182:=lq_tmp$x##1258][lq_tmp$x##1183:=lq_anf$##7205759403792804815##d2UT][lq_tmp$x##1184:=x1##a1Oh][lq_tmp$x##1187:=lq_tmp$x##1258][lq_tmp$x##1188:=x1##a1Oh][lq_tmp$x##1189:=lq_tmp$x##1258][lq_tmp$x##1190:=lq_anf$##7205759403792804815##d2UT][lq_tmp$x##1191:=x1##a1Oh][lq_tmp$x##1201:=x1##a1Oh]}</span><span class='hs-varid'>x2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1234 : (GHC.Ptr.Ptr {lq_tmp$x##1244 : GHC.Word.Word8 | $k_##1243[VV##1242:=lq_tmp$x##1244][lq_tmp$x##1237:=op##a1Oj][lq_tmp$x##1238:=l1##a1Od]}) | pbase lq_tmp$x##1234 == pbase op##a1Oj
                                                                                                                                                              &amp;&amp; plen lq_tmp$x##1234 == plen op##a1Oj - l1##a1Od
                                                                                                                                                              &amp;&amp; 0 &lt;= plen lq_tmp$x##1234}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1246 : (GHC.Ptr.Ptr {lq_tmp$x##1245 : GHC.Word.Word8 | $k_##1171[VV##1170:=lq_tmp$x##1245][VV##1172:=lq_tmp$x##1246]}) | lq_tmp$x##1246 == op##a1Oj
                                                                                                                                    &amp;&amp; $k_##1173[VV##1172:=lq_tmp$x##1246]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`plusPtr`</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1247 : GHC.Types.Int | lq_tmp$x##1247 == l1##a1Od
                                  &amp;&amp; lq_tmp$x##1247 &gt;= 0}</span><span class='hs-varid'>l1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-comment'>-- | Change a primitives such that it first applies a function to the value</span>
<span class=hs-linenum>192: </span><span class='hs-comment'>-- to be encoded.</span>
<span class=hs-linenum>193: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>194: </span><span class='hs-comment'>-- Note that primitives are 'Contravariant'</span>
<span class=hs-linenum>195: </span><span class='hs-comment'>-- &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a>&gt;. Hence, the following</span>
<span class=hs-linenum>196: </span><span class='hs-comment'>-- laws hold.</span>
<span class=hs-linenum>197: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>198: </span><span class='hs-comment'>-- &gt;contramapF id = id</span>
<span class=hs-linenum>199: </span><span class='hs-comment'>-- &gt;contramapF f . contramapF g = contramapF (g . f)</span>
<span class=hs-linenum>200: </span><span class='hs-comment'>{-# INLINE CONLIKE contramapF #-}</span>
<span class=hs-linenum>201: </span><span class='hs-definition'>contramapF</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>202: </span><a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##1402:(lq_tmp$x##1401:b -&gt; a) -&gt; lq_tmp$x##1403:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim b)</span><span class='hs-definition'>contramapF</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##1401:b -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##1520:{lq_tmp$x##1506 : GHC.Types.Int | lq_tmp$x##1506 &gt;= 0} -&gt; lq_tmp$x##1521:(lq_tmp$x##1518:a -&gt; lq_tmp$x##1519:{lq_tmp$x##1509 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##1509
                                                                                                                                                                                   &amp;&amp; lq_tmp$x##1520 &lt;= plen lq_tmp$x##1509} -&gt; (GHC.Types.IO ())) -&gt; {lq_tmp$x##1515 : (Data.ByteString.Builder.Prim.Internal.FixedPrim a) | Data.ByteString.Builder.Prim.Internal.fpSize lq_tmp$x##1515 == lq_tmp$x##1520
                                                                                                                                                                                                                                                                                                                              &amp;&amp; Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1515 == lq_tmp$x##1520} | VV == Data.ByteString.Builder.Prim.Internal.FP}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1525 : GHC.Types.Int | lq_tmp$x##1525 == l##a1Ol
                                  &amp;&amp; lq_tmp$x##1525 &gt;= 0}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>xcmp:{lq_tmp$x##1463 : b | $k_##1462[VV##1461:=lq_tmp$x##1463][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok]} -&gt; lq_tmp$x##1464:{lq_tmp$x##1457 : (GHC.Ptr.Ptr {lq_tmp$x##1456 : GHC.Word.Word8 | $k_##1449[VV##1448:=lq_tmp$x##1456][VV##1450:=lq_tmp$x##1457][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok]
                                                                                                                                                                                                     &amp;&amp; $k_##1466[VV##1465:=lq_tmp$x##1456][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok][lq_tmp$x##1473:=xcmp]}) | $k_##1451[VV##1450:=lq_tmp$x##1457][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok]
                                                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##1468[VV##1467:=lq_tmp$x##1457][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok][lq_tmp$x##1473:=xcmp]} -&gt; {lq_tmp$x##1459 : (GHC.Types.IO {lq_tmp$x##1458 : () | $k_##1453[VV##1452:=lq_tmp$x##1458][VV##1454:=lq_tmp$x##1459][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok][lq_tmp$x##1447:=lq_tmp$x##1464]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &amp;&amp; $k_##1470[VV##1469:=lq_tmp$x##1458][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok][lq_tmp$x##1473:=xcmp]}) | $k_##1455[VV##1454:=lq_tmp$x##1459][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok][lq_tmp$x##1447:=lq_tmp$x##1464]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  &amp;&amp; $k_##1472[VV##1471:=lq_tmp$x##1459][lq_tmp$db##13:=io##a1Om][lq_tmp$db##15:=f##a1Ok][lq_tmp$x##1473:=xcmp]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>lq_tmp$x##1499:a -&gt; lq_tmp$x##1500:{lq_tmp$x##1494 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##1494
                                                                                    &amp;&amp; l##a1Ol &lt;= plen lq_tmp$x##1494} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>io</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##1504:b -&gt; a</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>203: </span>
<span class=hs-linenum>204: </span><span class='hs-comment'>-- | Convert a 'FixedPrim' to a 'BoundedPrim'.</span>
<span class=hs-linenum>205: </span><span class='hs-comment'>{-# INLINE CONLIKE toB #-}</span>
<span class=hs-linenum>206: </span><span class='hs-definition'>toB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>207: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1589:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>toB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x##a1Op:{VV##1628 : a | $k_##1629} -&gt; op##a1Oq:{VV##1633 : (GHC.Ptr.Ptr {VV##1631 : GHC.Word.Word8 | $k_##1632}) | $k_##1634} -&gt; {VV##1640 : (GHC.Types.IO {VV##1638 : (GHC.Ptr.Ptr {VV##1636 : GHC.Word.Word8 | $k_##1637}) | $k_##1639}) | $k_##1641}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1787 : GHC.Types.Int | lq_tmp$x##1787 == l##a1On
                                  &amp;&amp; lq_tmp$x##1787 &gt;= 0}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1751 : (GHC.Base.Monad GHC.Types.IO) | lq_tmp$x##1751 == GHC.Base.$fMonadIO}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##1628 : a | $k_##1629}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##1633 : (GHC.Ptr.Ptr {VV##1631 : GHC.Word.Word8 | $k_##1632}) | $k_##1634}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1651 : a | lq_tmp$x##1651 == x##a1Op
                      &amp;&amp; $k_##1629[VV##1628:=lq_tmp$x##1651]}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1653 : (GHC.Ptr.Ptr {lq_tmp$x##1652 : GHC.Word.Word8 | $k_##1632[VV##1631:=lq_tmp$x##1652][VV##1633:=lq_tmp$x##1653]}) | lq_tmp$x##1653 == op##a1Oq
                                                                                                                                    &amp;&amp; $k_##1634[VV##1633:=lq_tmp$x##1653]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1723 : (GHC.Types.IO {lq_tmp$x##1722 : (GHC.Ptr.Ptr {lq_tmp$x##1721 : GHC.Word.Word8 | $k_##1716[VV##1715:=lq_tmp$x##1721][VV##1717:=lq_tmp$x##1722][VV##1719:=lq_tmp$x##1723][lq_tmp$x##1701:=lq_anf$##7205759403792804824##d2V2][lq_tmp$x##1702:=lq_anf$##7205759403792804825##d2V3]}) | $k_##1718[VV##1717:=lq_tmp$x##1722][VV##1719:=lq_tmp$x##1723][lq_tmp$x##1701:=lq_anf$##7205759403792804824##d2V2][lq_tmp$x##1702:=lq_anf$##7205759403792804825##d2V3]}) | $k_##1720[VV##1719:=lq_tmp$x##1723][lq_tmp$x##1701:=lq_anf$##7205759403792804824##d2V2][lq_tmp$x##1702:=lq_anf$##7205759403792804825##d2V3]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>forall a . lq_tmp$x##14:a -&gt; (GHC.Types.IO a)</span><span class='hs-varid'>return</span></a> <span class='hs-varop'>$!</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1690 : (GHC.Ptr.Ptr {lq_tmp$x##1689 : GHC.Word.Word8 | $k_##1632[VV##1631:=lq_tmp$x##1689][VV##1633:=lq_tmp$x##1690]}) | lq_tmp$x##1690 == op##a1Oq
                                                                                                                                    &amp;&amp; $k_##1634[VV##1633:=lq_tmp$x##1690]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`plusPtr`</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1691 : GHC.Types.Int | lq_tmp$x##1691 == l##a1On
                                  &amp;&amp; lq_tmp$x##1691 &gt;= 0}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>208: </span>
<span class=hs-linenum>209: </span><span class='hs-comment'>-- | Lift a 'FixedPrim' to a 'BoundedPrim'.</span>
<span class=hs-linenum>210: </span><span class='hs-comment'>{-# INLINE CONLIKE liftFixedToBounded #-}</span>
<span class=hs-linenum>211: </span><span class='hs-definition'>liftFixedToBounded</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>212: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1799:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>liftFixedToBounded</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toB</span>
<span class=hs-linenum>213: </span>
<span class=hs-linenum>214: </span><span class='hs-comment'>{-# INLINE CONLIKE storableToF #-}</span>
<span class=hs-linenum>215: </span><span class='hs-comment'>{-# DEPRECATED storableToF
     "Deprecated since @bytestring-0.12.1.0@.\n\nThis function is dangerous in the presence of internal padding\nand makes naive assumptions about alignment.\n\n * For a primitive Haskell type like 'Int64', use the\n   corresponding primitive like 'Data.ByteString.Builder.Prim.int64Host'.\n * For other types, it is recommended to manually write a small\n   function that performs the necessary unaligned write\n   and zeroes or removes any internal padding bits."
  #-}</span>
<span class=hs-linenum>218: </span><span class='hs-definition'>storableToF</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>219: </span><span class='hs-cpp'>#if HS_UNALIGNED_POKES_OK</span>
<span class=hs-linenum>220: </span><span class='hs-definition'>storableToF</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizeOf</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>op</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>poke</span> <span class='hs-layout'>(</span><span class='hs-varid'>castPtr</span> <span class='hs-varid'>op</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<span class=hs-linenum>221: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum>222: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
(Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>storableToF</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>ds_d2Tq:(lq_tmp$x##2803:{VV##2804 : a | $k_##2805} -&gt; lq_tmp$x##2806:{VV##2809 : (GHC.Ptr.Ptr {VV##2807 : GHC.Word.Word8 | $k_##2808}) | $k_##2810} -&gt; {VV##2813 : (GHC.Types.IO {VV##2811 : () | $k_##2812}) | $k_##2814}) -&gt; {lq_tmp$x##2825 : (Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##2834 : a | $k_##2833[VV##2832:=lq_tmp$x##2834][lq_tmp$x##2830:=ds_d2Tp][lq_tmp$x##2831:=ds_d2Tq]}) | Data.ByteString.Builder.Prim.Internal.fpSize lq_tmp$x##2825 == ds_d2Tp
                                                                                                                                                                                                                                                                                                                                                                                                                  &amp;&amp; Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##2825 == ds_d2Tp}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sizeOf</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2482 : a | $k_##2481[VV##2480:=lq_tmp$x##2482][lq_tmp$x##2472:=fix$36$$36$dIP_a1WL]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##2504 : a | $k_##2505}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##2509 : (GHC.Ptr.Ptr {VV##2507 : GHC.Word.Word8 | $k_##2508}) | $k_##2510}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>223: </span>    <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>Foreign.Ptr.WordPtr</span><span class='hs-varid'>ptrToWordPtr</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2525 : (GHC.Ptr.Ptr {lq_tmp$x##2524 : GHC.Word.Word8 | $k_##2508[VV##2507:=lq_tmp$x##2524][VV##2509:=lq_tmp$x##2525]}) | lq_tmp$x##2525 == op##a1Os
                                                                                                                                    &amp;&amp; $k_##2510[VV##2509:=lq_tmp$x##2525]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`mod`</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2581 : Foreign.Ptr.WordPtr | lq_tmp$x##2581 == lq_anf$##7205759403792804888##d2W4}</span><span class='hs-varid'>fromIntegral</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>alignment</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2546 : a | $k_##2545[VV##2544:=lq_tmp$x##2546][lq_tmp$x##2536:=fix$36$$36$dIP_a1X5]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2615 : Foreign.Ptr.WordPtr | lq_tmp$x##2615 == lq_anf$##7205759403792804891##d2W7}</span><span class='hs-num'>0</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2798 : (Foreign.Storable.Storable a) | lq_tmp$x##2798 == $dStorable_a1Wu}</span><span class='hs-varid'>poke</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2771 : (GHC.Ptr.Ptr {lq_tmp$x##2779 : a | $k_##2778[VV##2777:=lq_tmp$x##2779][lq_tmp$x##2773:=op##a1Os]}) | plen lq_tmp$x##2771 == plen op##a1Os
                                                                                                                       &amp;&amp; 0 &lt;= plen lq_tmp$x##2771}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>castPtr</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2781 : (GHC.Ptr.Ptr {lq_tmp$x##2780 : GHC.Word.Word8 | $k_##2508[VV##2507:=lq_tmp$x##2780][VV##2509:=lq_tmp$x##2781]}) | lq_tmp$x##2781 == op##a1Os
                                                                                                                                    &amp;&amp; $k_##2510[VV##2509:=lq_tmp$x##2781]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2801 : a | lq_tmp$x##2801 == x##a1Or
                      &amp;&amp; $k_##2505[VV##2504:=lq_tmp$x##2801]}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>224: </span>    <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##2749:(lq_tmp$x##2746:(GHC.Ptr.Ptr a) -&gt; (GHC.Types.IO {lq_tmp$x##2753 : () | $k_##2752[VV##2751:=lq_tmp$x##2753][lq_tmp$x##2747:=fix$36$$36$dStorable_a1Wu][lq_tmp$x##2748:=x##a1Or]})) -&gt; (GHC.Types.IO {lq_tmp$x##2753 : () | $k_##2752[VV##2751:=lq_tmp$x##2753][lq_tmp$x##2747:=fix$36$$36$dStorable_a1Wu][lq_tmp$x##2748:=x##a1Or]})</span><span class='hs-varid'>with</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2756 : a | lq_tmp$x##2756 == x##a1Or
                      &amp;&amp; $k_##2505[VV##2504:=lq_tmp$x##2756]}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##2721:(GHC.Ptr.Ptr a) -&gt; lq_tmp$x##2722:(GHC.Ptr.Ptr a) -&gt; lq_tmp$x##2723:GHC.Types.Int -&gt; (GHC.Types.IO ()) | VV == Foreign.Marshal.Utils.copyBytes}</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV##2648 : (GHC.Ptr.Ptr {VV##2646 : a | $k_##2647}) | $k_##2649}</span><span class='hs-varid'>tp</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>copyBytes</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2728 : (GHC.Ptr.Ptr {lq_tmp$x##2727 : GHC.Word.Word8 | $k_##2508[VV##2507:=lq_tmp$x##2727][VV##2509:=lq_tmp$x##2728]}) | lq_tmp$x##2728 == op##a1Os
                                                                                                                                    &amp;&amp; $k_##2510[VV##2509:=lq_tmp$x##2728]}</span><span class='hs-varid'>op</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2658 : (GHC.Ptr.Ptr {lq_tmp$x##2666 : GHC.Word.Word8 | $k_##2665[VV##2664:=lq_tmp$x##2666][lq_tmp$x##2660:=tp##a1Ot]}) | plen lq_tmp$x##2658 == plen tp##a1Ot
                                                                                                                                    &amp;&amp; 0 &lt;= plen lq_tmp$x##2658}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>castPtr</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2668 : (GHC.Ptr.Ptr {lq_tmp$x##2667 : a | $k_##2647[VV##2646:=lq_tmp$x##2667][VV##2648:=lq_tmp$x##2668]}) | lq_tmp$x##2668 == tp##a1Ot
                                                                                                                       &amp;&amp; $k_##2649[VV##2648:=lq_tmp$x##2668]}</span><span class='hs-varid'>tp</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sizeOf</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2689 : a | $k_##2688[VV##2687:=lq_tmp$x##2689][lq_tmp$x##2679:=fix$36$$36$dIP_a1Xv]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>225: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum>226: </span>
<span class=hs-linenum>227: </span><span class='hs-comment'>{-
{-# INLINE CONLIKE liftIOF #-}
liftIOF :: FixedPrim a -&gt; FixedPrim (IO a)
liftIOF (FP l io) = FP l (\xWrapped op -&gt; do x &lt;- xWrapped; io x op)
-}</span>
<span class=hs-linenum>232: </span>
<span class=hs-linenum>233: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>234: </span><span class='hs-comment'>-- Bounded-size builder primitives</span>
<span class=hs-linenum>235: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>236: </span>
<span class=hs-linenum>237: </span><span class='hs-comment'>-- | A builder primitive that always results in sequence of bytes that is no longer</span>
<span class=hs-linenum>238: </span><span class='hs-comment'>-- than a pre-determined bound.</span>
<span class=hs-linenum>239: </span><span class='hs-comment'>-- #ifdef LIQUID</span>
<span class=hs-linenum>240: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>241: </span><span class='hs-comment'>-- #else </span>
<span class=hs-linenum>242: </span><span class='hs-comment'>-- data BoundedPrim a = BP {-# UNPACK #-} !Int (a -&gt; Ptr Word8 -&gt; IO (Ptr Word8))</span>
<span class=hs-linenum>243: </span><span class='hs-comment'>-- #endif </span>
<span class=hs-linenum>244: </span>
<span class=hs-linenum>245: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PtrS</span> <span class='hs-varid'>a</span> <span class='hs-conid'>Base</span> <span class='hs-conid'>Off</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrV</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>plen</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>plen</span> <span class='hs-conid'>Base</span><span class='hs-layout'>)</span> <span class='hs-comment'>-</span> <span class='hs-conid'>Off</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>246: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bpSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span><span class='hs-layout'>,</span> <span class='hs-varid'>bpFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>bpSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-varid'>bpSize</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>247: </span>
<span class=hs-linenum>248: </span><span class='hs-comment'>-- | The bound on the size of sequences of bytes generated by this 'BoundedPrim'.</span>
<span class=hs-linenum>249: </span><span class='hs-comment'>{-# INLINE CONLIKE sizeBound #-}</span>
<span class=hs-linenum>250: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>sizeBound</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>251: </span><span class='hs-definition'>sizeBound</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>252: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2855:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; {VV : GHC.Types.Int | VV == Data.ByteString.Builder.Prim.Internal.sizeBound lq_tmp$x##2855}</span><span class='hs-definition'>sizeBound</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2896 : GHC.Types.Int | lq_tmp$x##2896 == b##a1Ou
                                  &amp;&amp; lq_tmp$x##2896 &gt;= 0}</span><span class='hs-varid'>b</span></a>
<span class=hs-linenum>253: </span>
<span class=hs-linenum>254: </span><span class='hs-comment'>-- | @since 0.10.12.0</span>
<span class=hs-linenum>255: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>boundedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>256: </span><span class='hs-definition'>boundedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>257: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2900:{VV##0 : GHC.Types.Int | VV##0 &gt;= 0} -&gt; lq_tmp$x##2901:(lq_tmp$x##2898:a -&gt; lq_tmp$x##2899:{VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV##0
                                                                                                                                                  &amp;&amp; lq_tmp$x##2900 &lt;= plen VV##0} -&gt; (GHC.Types.IO {VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen VV##0 &gt;= plen lq_tmp$x##2899 - lq_tmp$x##2900
                                                                                                                                                                                                                                            &amp;&amp; 0 &lt;= plen VV##0})) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>boundedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span>
<span class=hs-linenum>258: </span>
<span class=hs-linenum>259: </span><span class='hs-comment'>-- {-# DEPRECATED boudedPrim "Use 'boundedPrim' instead" #-}</span>
<span class=hs-linenum>260: </span><span class='hs-comment'>-- boudedPrim :: Int -&gt; (a -&gt; Ptr Word8 -&gt; IO (Ptr Word8)) -&gt; BoundedPrim a</span>
<span class=hs-linenum>261: </span><span class='hs-comment'>-- boudedPrim = BP</span>
<span class=hs-linenum>262: </span>
<span class=hs-linenum>263: </span><span class='hs-comment'>{-# INLINE CONLIKE runB #-}</span>
<span class=hs-linenum>264: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>runB</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>bp</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-keyword'>{sizeBound bp}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizeBound</span> <span class='hs-varid'>bp</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>265: </span><span class='hs-definition'>runB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>266: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2941:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##2942:a -&gt; lq_tmp$x##2943:{VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV##0
                                                                                                                                                   &amp;&amp; Data.ByteString.Builder.Prim.Internal.sizeBound lq_tmp$x##2941 &lt;= plen VV##0} -&gt; (GHC.Types.IO {VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen VV##0 &gt;= plen lq_tmp$x##2943 - Data.ByteString.Builder.Prim.Internal.sizeBound lq_tmp$x##2941
                                                                                                                                                                                                                                                                                             &amp;&amp; 0 &lt;= plen VV##0})</span><span class='hs-definition'>runB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##2992:a -&gt; lq_tmp$x##2993:{lq_tmp$x##2986 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##2986
                                                                                    &amp;&amp; ds_d2Th &lt;= plen lq_tmp$x##2986} -&gt; (GHC.Types.IO {lq_tmp$x##2988 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##2988 &gt;= plen lq_tmp$x##2993 - ds_d2Th
                                                                                                                                                                                         &amp;&amp; 0 &lt;= plen lq_tmp$x##2988})</span><span class='hs-varid'>io</span></a>
<span class=hs-linenum>267: </span>
<span class=hs-linenum>268: </span><span class='hs-comment'>-- | Change a 'BoundedPrim' such that it first applies a function to the</span>
<span class=hs-linenum>269: </span><span class='hs-comment'>-- value to be encoded.</span>
<span class=hs-linenum>270: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>271: </span><span class='hs-comment'>-- Note that 'BoundedPrim's are 'Contravariant'</span>
<span class=hs-linenum>272: </span><span class='hs-comment'>-- &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a>&gt;. Hence, the following</span>
<span class=hs-linenum>273: </span><span class='hs-comment'>-- laws hold.</span>
<span class=hs-linenum>274: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>275: </span><span class='hs-comment'>-- &gt;contramapB id = id</span>
<span class=hs-linenum>276: </span><span class='hs-comment'>-- &gt;contramapB f . contramapB g = contramapB (g . f)</span>
<span class=hs-linenum>277: </span><span class='hs-comment'>{-# INLINE CONLIKE contramapB #-}</span>
<span class=hs-linenum>278: </span><span class='hs-definition'>contramapB</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>279: </span><a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##2998:(lq_tmp$x##2997:b -&gt; a) -&gt; lq_tmp$x##2999:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim b)</span><span class='hs-definition'>contramapB</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##2997:b -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##3127:{lq_tmp$x##3112 : GHC.Types.Int | lq_tmp$x##3112 &gt;= 0} -&gt; lq_tmp$x##3128:(lq_tmp$x##3125:a -&gt; lq_tmp$x##3126:{lq_tmp$x##3115 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3115
                                                                                                                                                                                   &amp;&amp; lq_tmp$x##3127 &lt;= plen lq_tmp$x##3115} -&gt; (GHC.Types.IO {lq_tmp$x##3117 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3117 &gt;= plen lq_tmp$x##3126 - lq_tmp$x##3127
                                                                                                                                                                                                                                                                                               &amp;&amp; 0 &lt;= plen lq_tmp$x##3117})) -&gt; {lq_tmp$x##3122 : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | Data.ByteString.Builder.Prim.Internal.bpSize lq_tmp$x##3122 == lq_tmp$x##3127
                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; Data.ByteString.Builder.Prim.Internal.sizeBound lq_tmp$x##3122 == lq_tmp$x##3127} | VV == Data.ByteString.Builder.Prim.Internal.BP}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3132 : GHC.Types.Int | lq_tmp$x##3132 == b##a1Ox
                                  &amp;&amp; lq_tmp$x##3132 &gt;= 0}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>xcmp:{lq_tmp$x##3064 : b | $k_##3063[VV##3062:=lq_tmp$x##3064][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow]} -&gt; lq_tmp$x##3065:{lq_tmp$x##3057 : (GHC.Ptr.Ptr {lq_tmp$x##3056 : GHC.Word.Word8 | $k_##3047[VV##3046:=lq_tmp$x##3056][VV##3048:=lq_tmp$x##3057][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow]
                                                                                                                                                                                                     &amp;&amp; $k_##3067[VV##3066:=lq_tmp$x##3056][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow][lq_tmp$x##3076:=xcmp]}) | $k_##3049[VV##3048:=lq_tmp$x##3057][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow]
                                                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##3069[VV##3068:=lq_tmp$x##3057][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow][lq_tmp$x##3076:=xcmp]} -&gt; {lq_tmp$x##3060 : (GHC.Types.IO {lq_tmp$x##3059 : (GHC.Ptr.Ptr {lq_tmp$x##3058 : GHC.Word.Word8 | $k_##3051[VV##3050:=lq_tmp$x##3058][VV##3052:=lq_tmp$x##3059][VV##3054:=lq_tmp$x##3060][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow][lq_tmp$x##3045:=lq_tmp$x##3065]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; $k_##3071[VV##3070:=lq_tmp$x##3058][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow][lq_tmp$x##3076:=xcmp]}) | $k_##3053[VV##3052:=lq_tmp$x##3059][VV##3054:=lq_tmp$x##3060][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow][lq_tmp$x##3045:=lq_tmp$x##3065]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##3073[VV##3072:=lq_tmp$x##3059][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow][lq_tmp$x##3076:=xcmp]}) | $k_##3055[VV##3054:=lq_tmp$x##3060][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow][lq_tmp$x##3045:=lq_tmp$x##3065]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; $k_##3075[VV##3074:=lq_tmp$x##3060][lq_tmp$db##13:=io##a1Oy][lq_tmp$db##15:=f##a1Ow][lq_tmp$x##3076:=xcmp]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>lq_tmp$x##3105:a -&gt; lq_tmp$x##3106:{lq_tmp$x##3099 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3099
                                                                                    &amp;&amp; b##a1Ox &lt;= plen lq_tmp$x##3099} -&gt; (GHC.Types.IO {lq_tmp$x##3101 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3101 &gt;= plen lq_tmp$x##3106 - b##a1Ox
                                                                                                                                                                                         &amp;&amp; 0 &lt;= plen lq_tmp$x##3101})</span><span class='hs-varid'>io</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3110:b -&gt; a</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>280: </span>
<span class=hs-linenum>281: </span><span class='hs-comment'>-- | The 'BoundedPrim' that always results in the zero-length sequence.</span>
<span class=hs-linenum>282: </span><span class='hs-comment'>{-# INLINE CONLIKE emptyB #-}</span>
<span class=hs-linenum>283: </span><span class='hs-definition'>emptyB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>284: </span><a class=annot href="#"><span class=annottext>forall a . (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>emptyB</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3204 : GHC.Types.Int | lq_tmp$x##3204 == (lq_anf$##7205759403792804905##d2Wl : int)}</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {lq_tmp$x##3234 : (GHC.Ptr.Ptr {lq_tmp$x##3233 : GHC.Word.Word8 | $k_##3230[VV##3229:=lq_tmp$x##3233][VV##3231:=lq_tmp$x##3234][lq_tmp$x##14:=op##a1Oz]}) | $k_##3232[VV##3231:=lq_tmp$x##3234][lq_tmp$x##14:=op##a1Oz]})</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{VV##3214 : (GHC.Ptr.Ptr {VV##3212 : GHC.Word.Word8 | $k_##3213}) | $k_##3215}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3236 : (GHC.Ptr.Ptr {lq_tmp$x##3235 : GHC.Word.Word8 | $k_##3213[VV##3212:=lq_tmp$x##3235][VV##3214:=lq_tmp$x##3236]}) | lq_tmp$x##3236 == op##a1Oz
                                                                                                                                    &amp;&amp; $k_##3215[VV##3214:=lq_tmp$x##3236]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>285: </span>
<span class=hs-linenum>286: </span><span class='hs-comment'>-- | Encode a pair by encoding its first component and then its second component.</span>
<span class=hs-linenum>287: </span><span class='hs-comment'>{-# INLINE CONLIKE pairB #-}</span>
<span class=hs-linenum>288: </span><span class='hs-definition'>pairB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>289: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3273:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3274:(Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (a, b))</span><span class='hs-definition'>pairB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>290: </span>    <a class=annot href="#"><span class=annottext>ds_d2T6:{VV##3380 : ({VV##3373 : a | $k_##3374}, {VV##3375 : b | $k_##3376})&lt;\lq_tmp$x##3377 VV -&gt; {VV##3378 : b | $k_##3379}&gt; | $k_##3381} -&gt; op##a1OG:{VV##3385 : (GHC.Ptr.Ptr {VV##3383 : GHC.Word.Word8 | $k_##3384}) | $k_##3386} -&gt; {VV##3392 : (GHC.Types.IO {VV##3390 : (GHC.Ptr.Ptr {VV##3388 : GHC.Word.Word8 | $k_##3389}) | $k_##3391}) | $k_##3393}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3367 : GHC.Types.Int | lq_tmp$x##3367 == b1##a1OA + b2##a1OC}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##3370 : GHC.Types.Int | lq_tmp$x##3370 == b1##a1OA
                                  &amp;&amp; lq_tmp$x##3370 &gt;= 0}</span><span class='hs-varid'>b1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3371 : GHC.Types.Int | lq_tmp$x##3371 == b2##a1OC
                                  &amp;&amp; lq_tmp$x##3371 &gt;= 0}</span><span class='hs-varid'>b2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3398 : ({lq_tmp$x##3394 : a | $k_##3374[VV##3373:=lq_tmp$x##3394][VV##3380:=lq_tmp$x##3398]}, {lq_tmp$x##3395 : b | $k_##3376[VV##3375:=lq_tmp$x##3395][VV##3380:=lq_tmp$x##3398]})&lt;\lq_tmp$x##3399 VV -&gt; {lq_tmp$x##3397 : b | $k_##3379[VV##3378:=lq_tmp$x##3397][VV##3380:=lq_tmp$x##3398][lq_tmp$x##3377:=lq_tmp$x##3399][lq_tmp$x##3396:=lq_tmp$x##3399]}&gt; | lq_tmp$x##3398 == ds_d2T6
                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##3381[VV##3380:=lq_tmp$x##3398]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV##3385 : (GHC.Ptr.Ptr {VV##3383 : GHC.Word.Word8 | $k_##3384}) | $k_##3386}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {lq_tmp$x##3436 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3436 &gt;= plen op##a1OG - b1##a1OA
                                                               &amp;&amp; 0 &lt;= plen lq_tmp$x##3436})</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3442 : a | lq_tmp$x##3442 == x1##a1OE
                      &amp;&amp; $k_##3374[VV##3373:=lq_tmp$x##3442][VV##3380:=lq_anf$##7205759403792804911##d2Wr][liquid_internal_this:=lq_anf$##7205759403792804911##d2Wr][lq_tmp$x##3394:=lq_tmp$x##3442][lq_tmp$x##3398:=lq_anf$##7205759403792804911##d2Wr][lq_tmp$x##3401:=lq_tmp$x##3442][lq_tmp$x##3405:=lq_anf$##7205759403792804911##d2Wr]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3444 : (GHC.Ptr.Ptr {lq_tmp$x##3443 : GHC.Word.Word8 | $k_##3384[VV##3383:=lq_tmp$x##3443][VV##3385:=lq_tmp$x##3444]}) | lq_tmp$x##3444 == op##a1OG
                                                                                                                                    &amp;&amp; $k_##3386[VV##3385:=lq_tmp$x##3444]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3455:{lq_tmp$x##3448 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3448
                                                                &amp;&amp; b2##a1OC &lt;= plen lq_tmp$x##3448} -&gt; (GHC.Types.IO {lq_tmp$x##3450 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3450 &gt;= plen lq_tmp$x##3455 - b2##a1OC
                                                                                                                                                                      &amp;&amp; 0 &lt;= plen lq_tmp$x##3450})</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3456 : b | lq_tmp$x##3456 == x2##a1OF
                      &amp;&amp; $k_##3376[VV##3375:=lq_tmp$x##3456][VV##3380:=lq_anf$##7205759403792804911##d2Wr][liquid_internal_this:=lq_anf$##7205759403792804911##d2Wr][lq_tmp$x##3395:=lq_tmp$x##3456][lq_tmp$x##3398:=lq_anf$##7205759403792804911##d2Wr][lq_tmp$x##3402:=lq_tmp$x##3456][lq_tmp$x##3405:=lq_anf$##7205759403792804911##d2Wr][lq_tmp$x##3416:=x1##a1OE]
                      &amp;&amp; $k_##3379[VV##3378:=lq_tmp$x##3456][VV##3380:=lq_anf$##7205759403792804911##d2Wr][liquid_internal_this:=lq_anf$##7205759403792804911##d2Wr][lq_tmp$x##3377:=x1##a1OE][lq_tmp$x##3396:=x1##a1OE][lq_tmp$x##3397:=lq_tmp$x##3456][lq_tmp$x##3398:=lq_anf$##7205759403792804911##d2Wr][lq_tmp$x##3399:=x1##a1OE][lq_tmp$x##3402:=lq_tmp$x##3456][lq_tmp$x##3403:=x1##a1OE][lq_tmp$x##3404:=lq_tmp$x##3456][lq_tmp$x##3405:=lq_anf$##7205759403792804911##d2Wr][lq_tmp$x##3406:=x1##a1OE][lq_tmp$x##3416:=x1##a1OE]}</span><span class='hs-varid'>x2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>291: </span>
<span class=hs-linenum>292: </span><span class='hs-comment'>-- | Encode an 'Either' value using the first 'BoundedPrim' for 'Left'</span>
<span class=hs-linenum>293: </span><span class='hs-comment'>-- values and the second 'BoundedPrim' for 'Right' values.</span>
<span class=hs-linenum>294: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>295: </span><span class='hs-comment'>-- Note that the functions 'eitherB', 'pairB', and 'contramapB' (written below</span>
<span class=hs-linenum>296: </span><span class='hs-comment'>-- using '&gt;$&lt;') suffice to construct 'BoundedPrim's for all non-recursive</span>
<span class=hs-linenum>297: </span><span class='hs-comment'>-- algebraic datatypes. For example,</span>
<span class=hs-linenum>298: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>299: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>300: </span><span class='hs-comment'>--maybeB :: BoundedPrim () -&gt; BoundedPrim a -&gt; BoundedPrim (Maybe a)</span>
<span class=hs-linenum>301: </span><span class='hs-comment'>--maybeB nothing just = 'maybe' (Left ()) Right '&gt;$&lt;' eitherB nothing just</span>
<span class=hs-linenum>302: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>303: </span><span class='hs-comment'>{-# INLINE CONLIKE eitherB #-}</span>
<span class=hs-linenum>304: </span><span class='hs-definition'>eitherB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>305: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3613:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3614:(Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (Data.Either.Either a b))</span><span class='hs-definition'>eitherB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>306: </span>    <span class='hs-conid'>BP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3708 : GHC.Types.Int | lq_tmp$x##3708 == (if b1##a1OH &gt; b2##a1OJ then b1##a1OH else b2##a1OJ)
                                  &amp;&amp; $k_##3707[VV##3706:=lq_tmp$x##3708][lq_tmp$x##3703:=GHC.Classes.$fOrdInt][lq_tmp$x##3704:=b1##a1OH][lq_tmp$x##3705:=b2##a1OJ]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>max</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3711 : GHC.Types.Int | lq_tmp$x##3711 == b1##a1OH
                                  &amp;&amp; lq_tmp$x##3711 &gt;= 0}</span><span class='hs-varid'>b1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3712 : GHC.Types.Int | lq_tmp$x##3712 == b2##a1OJ
                                  &amp;&amp; lq_tmp$x##3712 &gt;= 0}</span><span class='hs-varid'>b2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>307: </span>        <a class=annot href="#"><span class=annottext>{lq_tmp$x##3734 : (Data.Either.Either {lq_tmp$x##3732 : a | $k_##3715[VV##3714:=lq_tmp$x##3732][VV##3718:=lq_tmp$x##3734]} {lq_tmp$x##3733 : b | $k_##3717[VV##3716:=lq_tmp$x##3733][VV##3718:=lq_tmp$x##3734]}) | lq_tmp$x##3734 == x##a1OL
                                                                                                                                                                                                                   &amp;&amp; $k_##3719[VV##3718:=lq_tmp$x##3734]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##3718 : (Data.Either.Either {VV##3714 : a | $k_##3715} {VV##3716 : b | $k_##3717}) | $k_##3719}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##3723 : (GHC.Ptr.Ptr {VV##3721 : GHC.Word.Word8 | $k_##3722}) | $k_##3724}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3734 : (Data.Either.Either {lq_tmp$x##3732 : a | $k_##3715[VV##3714:=lq_tmp$x##3732][VV##3718:=lq_tmp$x##3734]} {lq_tmp$x##3733 : b | $k_##3717[VV##3716:=lq_tmp$x##3733][VV##3718:=lq_tmp$x##3734]}) | lq_tmp$x##3734 == x##a1OL
                                                                                                                                                                                                                   &amp;&amp; $k_##3719[VV##3718:=lq_tmp$x##3734]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>of</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3761:a -&gt; lq_tmp$x##3762:{lq_tmp$x##3755 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3755
                                                                                    &amp;&amp; b1##a1OH &lt;= plen lq_tmp$x##3755} -&gt; (GHC.Types.IO {lq_tmp$x##3757 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3757 &gt;= plen lq_tmp$x##3762 - b1##a1OH
                                                                                                                                                                                          &amp;&amp; 0 &lt;= plen lq_tmp$x##3757})</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3763 : a | lq_tmp$x##3763 == x1##a1ON
                      &amp;&amp; $k_##3715[VV##3714:=lq_tmp$x##3763][VV##3718:=lq_anf$##7205759403792804918##d2Wy][liquid_internal_this:=lq_anf$##7205759403792804918##d2Wy][lq_tmp$x##3732:=lq_tmp$x##3763][lq_tmp$x##3734:=lq_anf$##7205759403792804918##d2Wy][lq_tmp$x##3736:=lq_tmp$x##3763][lq_tmp$x##3738:=lq_anf$##7205759403792804918##d2Wy]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3765 : (GHC.Ptr.Ptr {lq_tmp$x##3764 : GHC.Word.Word8 | $k_##3722[VV##3721:=lq_tmp$x##3764][VV##3723:=lq_tmp$x##3765]}) | lq_tmp$x##3765 == op##a1OM
                                                                                                                                    &amp;&amp; $k_##3724[VV##3723:=lq_tmp$x##3765]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>;</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3791:b -&gt; lq_tmp$x##3792:{lq_tmp$x##3785 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3785
                                                                                    &amp;&amp; b2##a1OJ &lt;= plen lq_tmp$x##3785} -&gt; (GHC.Types.IO {lq_tmp$x##3787 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3787 &gt;= plen lq_tmp$x##3792 - b2##a1OJ
                                                                                                                                                                                          &amp;&amp; 0 &lt;= plen lq_tmp$x##3787})</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3793 : b | lq_tmp$x##3793 == x2##a1OO
                      &amp;&amp; $k_##3717[VV##3716:=lq_tmp$x##3793][VV##3718:=lq_anf$##7205759403792804918##d2Wy][liquid_internal_this:=lq_anf$##7205759403792804918##d2Wy][lq_tmp$x##3733:=lq_tmp$x##3793][lq_tmp$x##3734:=lq_anf$##7205759403792804918##d2Wy][lq_tmp$x##3767:=lq_tmp$x##3793][lq_tmp$x##3768:=lq_anf$##7205759403792804918##d2Wy]}</span><span class='hs-varid'>x2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3795 : (GHC.Ptr.Ptr {lq_tmp$x##3794 : GHC.Word.Word8 | $k_##3722[VV##3721:=lq_tmp$x##3794][VV##3723:=lq_tmp$x##3795]}) | lq_tmp$x##3795 == op##a1OM
                                                                                                                                    &amp;&amp; $k_##3724[VV##3723:=lq_tmp$x##3795]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>308: </span>
<span class=hs-linenum>309: </span><span class='hs-comment'>-- | Conditionally select a 'BoundedPrim'.</span>
<span class=hs-linenum>310: </span><span class='hs-comment'>-- For example, we can implement the ASCII primitive that drops characters with</span>
<span class=hs-linenum>311: </span><span class='hs-comment'>-- Unicode codepoints above 127 as follows.</span>
<span class=hs-linenum>312: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>313: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>314: </span><span class='hs-comment'>--charASCIIDrop = 'condB' (&lt; \'\\128\') ('liftFixedToBounded' 'Data.ByteString.Builder.Prim.char7') 'emptyB'</span>
<span class=hs-linenum>315: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>316: </span><span class='hs-comment'>{-# INLINE CONLIKE condB #-}</span>
<span class=hs-linenum>317: </span><span class='hs-definition'>condB</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>318: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##3839:(lq_tmp$x##3838:a -&gt; GHC.Types.Bool) -&gt; lq_tmp$x##3840:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3841:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>condB</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3838:a -&gt; GHC.Types.Bool</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>be1</span></a> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>be2</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>319: </span>    <span class='hs-varid'>contramapB</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3860 : GHC.Types.Bool | lq_tmp$x##3860 == lq_anf$##7205759403792804920##d2WA}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##3845 : a | $k_##3846}</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3858 : a | lq_tmp$x##3858 == x##a1OS
                      &amp;&amp; $k_##3846[VV##3845:=lq_tmp$x##3858]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      lq_tmp$x##3890:a -&gt; {lq_tmp$x##3888 : (Data.Either.Either a b) | isLeft lq_tmp$x##3888} | VV == Data.Either.Left}</span><span class='hs-conid'>Left</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3897 : a | lq_tmp$x##3897 == x##a1OS
                      &amp;&amp; $k_##3846[VV##3845:=lq_tmp$x##3897]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      lq_tmp$x##3872:b -&gt; {lq_tmp$x##3870 : (Data.Either.Either a b) | not (isLeft lq_tmp$x##3870)} | VV == Data.Either.Right}</span><span class='hs-conid'>Right</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3879 : a | lq_tmp$x##3879 == x##a1OS
                      &amp;&amp; $k_##3846[VV##3845:=lq_tmp$x##3879]}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim (Data.Either.Either {lq_tmp$x##3913 : a | $k_##3912[VV##3911:=lq_tmp$x##3913][lq_tmp$x##3909:=be1##a1OQ][lq_tmp$x##3910:=be2##a1OR]} {lq_tmp$x##3916 : a | $k_##3915[VV##3914:=lq_tmp$x##3916][lq_tmp$x##3909:=be1##a1OQ][lq_tmp$x##3910:=be2##a1OR]}))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>eitherB</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3918 : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | lq_tmp$x##3918 == be1##a1OQ}</span><span class='hs-varid'>be1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3920 : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | lq_tmp$x##3920 == be2##a1OR}</span><span class='hs-varid'>be2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>320: </span>
</pre>
</body>
</html>