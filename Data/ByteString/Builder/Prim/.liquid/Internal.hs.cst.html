<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>./Data/ByteString/Builder/Prim/Internal.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>  1: </span><a class=annot href="#"><span class=annottext>{VV##3977 : GHC.Types.Module | $k_##3978}</span><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables, CPP #-}</span></a>
<span class=hs-linenum>  2: </span><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<span class=hs-linenum>  3: </span><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<span class=hs-linenum>  4: </span><span class='hs-comment'>-- |</span>
<span class=hs-linenum>  5: </span><span class='hs-comment'>-- Copyright   : 2010-2011 Simon Meier, 2010 Jasper van der Jeugt</span>
<span class=hs-linenum>  6: </span><span class='hs-comment'>-- License     : BSD3-style (see LICENSE)</span>
<span class=hs-linenum>  7: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>  8: </span><span class='hs-comment'>-- Maintainer  : Simon Meier &lt;iridcode@gmail.com&gt;</span>
<span class=hs-linenum>  9: </span><span class='hs-comment'>-- Stability   : unstable, private</span>
<span class=hs-linenum> 10: </span><span class='hs-comment'>-- Portability : GHC</span>
<span class=hs-linenum> 11: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 12: </span><span class='hs-comment'>-- *Warning:* this module is internal. If you find that you need it please</span>
<span class=hs-linenum> 13: </span><span class='hs-comment'>-- contact the maintainers and explain what you are trying to do and discuss</span>
<span class=hs-linenum> 14: </span><span class='hs-comment'>-- what you would need in the public API. It is important that you do this as</span>
<span class=hs-linenum> 15: </span><span class='hs-comment'>-- the module may not be exposed at all in future releases.</span>
<span class=hs-linenum> 16: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 17: </span><span class='hs-comment'>-- The maintainers are glad to accept patches for further</span>
<span class=hs-linenum> 18: </span><span class='hs-comment'>-- standard encodings of standard Haskell values.</span>
<span class=hs-linenum> 19: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 20: </span><span class='hs-comment'>-- If you need to write your own builder primitives, then be aware that you are</span>
<span class=hs-linenum> 21: </span><span class='hs-comment'>-- writing code with /all safety belts off/; i.e.,</span>
<span class=hs-linenum> 22: </span><span class='hs-comment'>-- *this is the code that might make your application vulnerable to buffer-overflow attacks!*</span>
<span class=hs-linenum> 23: </span><span class='hs-comment'>-- The "Data.ByteString.Builder.Prim.Tests" module provides you with</span>
<span class=hs-linenum> 24: </span><span class='hs-comment'>-- utilities for testing your encodings thoroughly.</span>
<span class=hs-linenum> 25: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 26: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.ByteString.Builder.Prim.Internal</span> <span class='hs-layout'>(</span>
<span class=hs-linenum> 27: </span>  <span class='hs-comment'>-- * Fixed-size builder primitives</span>
<span class=hs-linenum> 28: </span>    <span class='hs-conid'>Size</span>
<span class=hs-linenum> 29: </span>  <span class='hs-layout'>,</span> <span class='hs-conid'>FixedPrim</span>
<span class=hs-linenum> 30: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>fixedPrim</span>
<span class=hs-linenum> 31: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>size</span>
<span class=hs-linenum> 32: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>runF</span>
<span class=hs-linenum> 33: </span>
<span class=hs-linenum> 34: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>emptyF</span>
<span class=hs-linenum> 35: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>contramapF</span>
<span class=hs-linenum> 36: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>pairF</span>
<span class=hs-linenum> 37: </span>  <span class='hs-comment'>-- , liftIOF</span>
<span class=hs-linenum> 38: </span>
<span class=hs-linenum> 39: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>storableToF</span>
<span class=hs-linenum> 40: </span>
<span class=hs-linenum> 41: </span>  <span class='hs-comment'>-- * Bounded-size builder primitives</span>
<span class=hs-linenum> 42: </span>  <span class='hs-layout'>,</span> <span class='hs-conid'>BoundedPrim</span>
<span class=hs-linenum> 43: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>boundedPrim</span>
<span class=hs-linenum> 44: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>sizeBound</span>
<span class=hs-linenum> 45: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>runB</span>
<span class=hs-linenum> 46: </span>
<span class=hs-linenum> 47: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>emptyB</span>
<span class=hs-linenum> 48: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>contramapB</span>
<span class=hs-linenum> 49: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>pairB</span>
<span class=hs-linenum> 50: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>eitherB</span>
<span class=hs-linenum> 51: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>condB</span>
<span class=hs-linenum> 52: </span>
<span class=hs-linenum> 53: </span>  <span class='hs-comment'>-- , liftIOB</span>
<span class=hs-linenum> 54: </span>
<span class=hs-linenum> 55: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>toB</span>
<span class=hs-linenum> 56: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>liftFixedToBounded</span>
<span class=hs-linenum> 57: </span>
<span class=hs-linenum> 58: </span>  <span class='hs-comment'>-- , withSizeFB</span>
<span class=hs-linenum> 59: </span>  <span class='hs-comment'>-- , withSizeBB</span>
<span class=hs-linenum> 60: </span>
<span class=hs-linenum> 61: </span>  <span class='hs-comment'>-- * Shared operators</span>
<span class=hs-linenum> 62: </span>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 63: </span>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 64: </span>
<span class=hs-linenum> 65: </span>  <span class='hs-comment'>-- * Helpers</span>
<span class=hs-linenum> 66: </span>  <span class='hs-comment'>-- , caseWordSize_32_64</span>
<span class=hs-linenum> 67: </span>
<span class=hs-linenum> 68: </span>  <span class='hs-comment'>-- * Deprecated</span>
<span class=hs-linenum> 69: </span>  <span class='hs-comment'>-- , boudedPrim</span>
<span class=hs-linenum> 70: </span>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 71: </span>
<span class=hs-linenum> 72: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign</span>
<span class=hs-linenum> 73: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>maxBound</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 74: </span>
<span class=hs-linenum> 75: </span><span class='hs-cpp'>#include "MachDeps.h"</span>
<span class=hs-linenum> 76: </span><span class='hs-cpp'>#include "bytestring-cpp-macros.h"</span>
<span class=hs-linenum> 77: </span>
<span class=hs-linenum> 78: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum> 79: </span><span class='hs-comment'>-- Supporting infrastructure</span>
<span class=hs-linenum> 80: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum> 81: </span>
<span class=hs-linenum> 82: </span><span class='hs-comment'>-- | Contravariant functors as in the @contravariant@ package.</span>
<span class=hs-linenum> 83: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>Contravariant</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 84: </span>    <span class='hs-varid'>contramap</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<span class=hs-linenum> 85: </span>
<span class=hs-linenum> 86: </span><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>&gt;$&lt;</span>
<span class=hs-linenum> 87: </span>
<span class=hs-linenum> 88: </span><span class='hs-comment'>-- | A fmap-like operator for builder primitives, both bounded and fixed size.</span>
<span class=hs-linenum> 89: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 90: </span><span class='hs-comment'>-- Builder primitives are contravariant so it's like the normal fmap, but</span>
<span class=hs-linenum> 91: </span><span class='hs-comment'>-- backwards (look at the type). (If it helps to remember, the operator symbol</span>
<span class=hs-linenum> 92: </span><span class='hs-comment'>-- is like (&lt;$&gt;) but backwards.)</span>
<span class=hs-linenum> 93: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 94: </span><span class='hs-comment'>-- We can use it for example to prepend and/or append fixed values to an</span>
<span class=hs-linenum> 95: </span><span class='hs-comment'>-- primitive.</span>
<span class=hs-linenum> 96: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 97: </span><span class='hs-comment'>-- &gt; import Data.ByteString.Builder.Prim as P</span>
<span class=hs-linenum> 98: </span><span class='hs-comment'>-- &gt;showEncoding ((\x -&gt; ('\'', (x, '\''))) &gt;$&lt; fixed3) 'x' = "'x'"</span>
<span class=hs-linenum> 99: </span><span class='hs-comment'>-- &gt;  where</span>
<span class=hs-linenum>100: </span><span class='hs-comment'>-- &gt;    fixed3 = P.char7 &gt;*&lt; P.char7 &gt;*&lt; P.char7</span>
<span class=hs-linenum>101: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>102: </span><span class='hs-comment'>-- Note that the rather verbose syntax for composition stems from the</span>
<span class=hs-linenum>103: </span><span class='hs-comment'>-- requirement to be able to compute the size / size bound at compile time.</span>
<span class=hs-linenum>104: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>105: </span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Contravariant</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>106: </span><a class=annot href="#"><span class=annottext>forall f b a .
(Data.ByteString.Builder.Prim.Internal.Contravariant&lt;[]&gt; f) =&gt;
lq_tmp$x##803:(lq_tmp$x##801:b -&gt; a) -&gt; lq_tmp$x##804:f a -&gt; f b</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramap</span>
<span class=hs-linenum>107: </span>
<span class=hs-linenum>108: </span>
<span class=hs-linenum>109: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Contravariant Data.ByteString.Builder.Prim.Internal.FixedPrim)</span><span class='hs-conid'>Contravariant</span></a> <span class='hs-conid'>FixedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>110: </span>    <a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##1560:(lq_tmp$x##1559:{lq_tmp$x##1564 : b | $k_##1563[VV##1562:=lq_tmp$x##1564]} -&gt; {lq_tmp$x##1567 : a | $k_##1566[VV##1565:=lq_tmp$x##1567]}) -&gt; lq_tmp$x##1561:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1567 : a | $k_##1566[VV##1565:=lq_tmp$x##1567]}) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1564 : b | $k_##1563[VV##1562:=lq_tmp$x##1564]})</span><span class='hs-varid'>contramap</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramapF</span>
<span class=hs-linenum>111: </span>
<span class=hs-linenum>112: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Contravariant Data.ByteString.Builder.Prim.Internal.BoundedPrim)</span><span class='hs-conid'>Contravariant</span></a> <span class='hs-conid'>BoundedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>113: </span>    <a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##3172:(lq_tmp$x##3171:{lq_tmp$x##3176 : b | $k_##3175[VV##3174:=lq_tmp$x##3176]} -&gt; {lq_tmp$x##3179 : a | $k_##3178[VV##3177:=lq_tmp$x##3179]}) -&gt; lq_tmp$x##3173:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3179 : a | $k_##3178[VV##3177:=lq_tmp$x##3179]}) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3176 : b | $k_##3175[VV##3174:=lq_tmp$x##3176]})</span><span class='hs-varid'>contramap</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramapB</span>
<span class=hs-linenum>114: </span>
<span class=hs-linenum>115: </span>
<span class=hs-linenum>116: </span><span class='hs-comment'>-- | Type-constructors supporting lifting of type-products.</span>
<span class=hs-linenum>117: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>Monoidal</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>118: </span>    <span class='hs-varid'>pair</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>119: </span>
<span class=hs-linenum>120: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Monoidal Data.ByteString.Builder.Prim.Internal.FixedPrim)</span><span class='hs-conid'>Monoidal</span></a> <span class='hs-conid'>FixedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>121: </span>    <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##1363:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1368 : a | $k_##1367[VV##1366:=lq_tmp$x##1368]}) -&gt; lq_tmp$x##1364:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1371 : b | $k_##1370[VV##1369:=lq_tmp$x##1371]}) -&gt; {lq_tmp$x##1360 : (Data.ByteString.Builder.Prim.Internal.FixedPrim ({lq_tmp$x##1368 : a | $k_##1367[VV##1366:=lq_tmp$x##1368]}, {lq_tmp$x##1371 : b | $k_##1370[VV##1369:=lq_tmp$x##1371]})) | Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1360 == Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1363 + Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1364}</span><span class='hs-varid'>pair</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pairF</span>
<span class=hs-linenum>122: </span>
<span class=hs-linenum>123: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Monoidal Data.ByteString.Builder.Prim.Internal.BoundedPrim)</span><span class='hs-conid'>Monoidal</span></a> <span class='hs-conid'>BoundedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>124: </span>    <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3579:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3584 : a | $k_##3583[VV##3582:=lq_tmp$x##3584]}) -&gt; lq_tmp$x##3580:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3587 : b | $k_##3586[VV##3585:=lq_tmp$x##3587]}) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim ({lq_tmp$x##3584 : a | $k_##3583[VV##3582:=lq_tmp$x##3584]}, {lq_tmp$x##3587 : b | $k_##3586[VV##3585:=lq_tmp$x##3587]}))</span><span class='hs-varid'>pair</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pairB</span>
<span class=hs-linenum>125: </span>
<span class=hs-linenum>126: </span><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span> <span class='hs-varop'>&gt;*&lt;</span>
<span class=hs-linenum>127: </span>
<span class=hs-linenum>128: </span><span class='hs-comment'>-- | A pairing/concatenation operator for builder primitives, both bounded and</span>
<span class=hs-linenum>129: </span><span class='hs-comment'>-- fixed size.</span>
<span class=hs-linenum>130: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>131: </span><span class='hs-comment'>-- For example,</span>
<span class=hs-linenum>132: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>133: </span><span class='hs-comment'>-- &gt; toLazyByteString (primFixed (char7 &gt;*&lt; char7) ('x','y')) = "xy"</span>
<span class=hs-linenum>134: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>135: </span><span class='hs-comment'>-- We can combine multiple primitives using '&gt;*&lt;' multiple times.</span>
<span class=hs-linenum>136: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>137: </span><span class='hs-comment'>-- &gt; toLazyByteString (primFixed (char7 &gt;*&lt; char7 &gt;*&lt; char7) ('x',('y','z'))) = "xyz"</span>
<span class=hs-linenum>138: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>139: </span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monoidal</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>140: </span><a class=annot href="#"><span class=annottext>forall f a b .
(Data.ByteString.Builder.Prim.Internal.Monoidal&lt;[]&gt; f) =&gt;
lq_tmp$x##835:f a -&gt; lq_tmp$x##836:f b -&gt; f (a, b)</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pair</span>
<span class=hs-linenum>141: </span>
<span class=hs-linenum>142: </span>
<span class=hs-linenum>143: </span><span class='hs-comment'>-- | The type used for sizes and sizeBounds of sizes.</span>
<span class=hs-linenum>144: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Size</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>145: </span>
<span class=hs-linenum>146: </span>
<span class=hs-linenum>147: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>148: </span><span class='hs-comment'>-- Fixed-size builder primitives</span>
<span class=hs-linenum>149: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>150: </span>
<span class=hs-linenum>151: </span><span class='hs-comment'>-- | A builder primitive that always results in a sequence of bytes of a</span>
<span class=hs-linenum>152: </span><span class='hs-comment'>-- pre-determined, fixed size.</span>
<span class=hs-linenum>153: </span><span class='hs-comment'>-- ifdef LIQUID</span>
<span class=hs-linenum>154: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<span class=hs-linenum>155: </span><span class='hs-comment'>-- else </span>
<span class=hs-linenum>156: </span><span class='hs-comment'>-- data FixedPrim a = FP {-# UNPACK #-} !Int (a -&gt; Ptr Word8 -&gt; IO ())</span>
<span class=hs-linenum>157: </span><span class='hs-comment'>-- endif</span>
<span class=hs-linenum>158: </span>
<span class=hs-linenum>159: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PtrGN</span> <span class='hs-varid'>a</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrV</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>N</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>plen</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>160: </span>
<span class=hs-linenum>161: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fpSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span><span class='hs-layout'>,</span> <span class='hs-varid'>fpFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>fpSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>162: </span>
<span class=hs-linenum>163: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fixedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>164: </span><span class='hs-definition'>fixedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>165: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##873:{VV##0 : GHC.Types.Int | VV##0 &gt;= 0} -&gt; lq_tmp$x##874:(lq_tmp$x##871:a -&gt; lq_tmp$x##872:{VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV##0
                                                                                                                                              &amp;&amp; lq_tmp$x##873 &lt;= plen VV##0} -&gt; (GHC.Types.IO ())) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>fixedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span>
<span class=hs-linenum>166: </span>
<span class=hs-linenum>167: </span><span class='hs-comment'>-- | The size of the sequences of bytes generated by this 'FixedPrim'.</span>
<span class=hs-linenum>168: </span><span class='hs-comment'>{-# INLINE CONLIKE size #-}</span>
<span class=hs-linenum>169: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>size</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>170: </span><span class='hs-definition'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>171: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##912:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; {VV : GHC.Types.Int | VV == Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##912}</span><span class='hs-definition'>size</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##951 : GHC.Types.Int | lq_tmp$x##951 == l##a1K4
                                 &amp;&amp; lq_tmp$x##951 &gt;= 0}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>172: </span>
<span class=hs-linenum>173: </span>
<span class=hs-linenum>174: </span><span class='hs-comment'>{-# INLINE CONLIKE runF #-}</span>
<span class=hs-linenum>175: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>runF</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>fp</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PtrGN</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>{size fp}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>176: </span><span class='hs-definition'>runF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>177: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##953:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; lq_tmp$x##954:a -&gt; lq_tmp$x##955:{VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV##0
                                                                                                                                              &amp;&amp; Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##953 &lt;= plen VV##0} -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>runF</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##1001:a -&gt; lq_tmp$x##1002:{lq_tmp$x##996 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##996
                                                                                   &amp;&amp; ds_d2Qs &lt;= plen lq_tmp$x##996} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>io</span></a>
<span class=hs-linenum>178: </span>
<span class=hs-linenum>179: </span><span class='hs-comment'>-- | The 'FixedPrim' that always results in the zero-length sequence.</span>
<span class=hs-linenum>180: </span><span class='hs-comment'>{-# INLINE CONLIKE emptyF #-}</span>
<span class=hs-linenum>181: </span><span class='hs-definition'>emptyF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>182: </span><a class=annot href="#"><span class=annottext>forall a . (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>emptyF</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1013 : GHC.Types.Int | lq_tmp$x##1013 == (lq_anf$##7205759403792804607##d2Rx : int)}</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {lq_tmp$x##1040 : () | $k_##1039[VV##1038:=lq_tmp$x##1040][lq_tmp$x##14:=GHC.Tuple.$40$$41$]})</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1041 : () | lq_tmp$x##1041 == GHC.Tuple.()}</span><span class='hs-conid'>()</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>183: </span>
<span class=hs-linenum>184: </span><span class='hs-comment'>-- | Encode a pair by encoding its first component and then its second component.</span>
<span class=hs-linenum>185: </span><span class='hs-comment'>{-# INLINE CONLIKE pairF #-}</span>
<span class=hs-linenum>186: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>pairF</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>fpa</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fpb</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fpab:</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>| size fpab = size fpa + size fpb }</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>187: </span><span class='hs-definition'>pairF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>188: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##1076:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; lq_tmp$x##1077:(Data.ByteString.Builder.Prim.Internal.FixedPrim b) -&gt; {fpab : (Data.ByteString.Builder.Prim.Internal.FixedPrim (a, b)) | Data.ByteString.Builder.Prim.Internal.size fpab == Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1076 + Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1077}</span><span class='hs-definition'>pairF</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>189: </span>    <a class=annot href="#"><span class=annottext>ds_d2Ql:{VV##1179 : ({VV##1172 : a | $k_##1173}, {VV##1174 : b | $k_##1175})&lt;\lq_tmp$x##1176 VV -&gt; {VV##1177 : b | $k_##1178}&gt; | $k_##1180} -&gt; op##a1Kc:{VV##1184 : (GHC.Ptr.Ptr {VV##1182 : GHC.Word.Word8 | $k_##1183}) | $k_##1185} -&gt; {VV##1189 : (GHC.Types.IO {VV##1187 : () | $k_##1188}) | $k_##1190}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1166 : GHC.Types.Int | lq_tmp$x##1166 == l1##a1K6 + l2##a1K8}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1169 : GHC.Types.Int | lq_tmp$x##1169 == l1##a1K6
                                  &amp;&amp; lq_tmp$x##1169 &gt;= 0}</span><span class='hs-varid'>l1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1170 : GHC.Types.Int | lq_tmp$x##1170 == l2##a1K8
                                  &amp;&amp; lq_tmp$x##1170 &gt;= 0}</span><span class='hs-varid'>l2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1195 : ({lq_tmp$x##1191 : a | $k_##1173[VV##1172:=lq_tmp$x##1191][VV##1179:=lq_tmp$x##1195]}, {lq_tmp$x##1192 : b | $k_##1175[VV##1174:=lq_tmp$x##1192][VV##1179:=lq_tmp$x##1195]})&lt;\lq_tmp$x##1196 VV -&gt; {lq_tmp$x##1194 : b | $k_##1178[VV##1177:=lq_tmp$x##1194][VV##1179:=lq_tmp$x##1195][lq_tmp$x##1176:=lq_tmp$x##1196][lq_tmp$x##1193:=lq_tmp$x##1196]}&gt; | lq_tmp$x##1195 == ds_d2Ql
                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##1180[VV##1179:=lq_tmp$x##1195]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV##1184 : (GHC.Ptr.Ptr {VV##1182 : GHC.Word.Word8 | $k_##1183}) | $k_##1185}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1238 : a | lq_tmp$x##1238 == x1##a1Ka
                      &amp;&amp; $k_##1173[VV##1172:=lq_tmp$x##1238][VV##1179:=lq_anf$##7205759403792804613##d2RD][liquid_internal_this:=lq_anf$##7205759403792804613##d2RD][lq_tmp$x##1191:=lq_tmp$x##1238][lq_tmp$x##1195:=lq_anf$##7205759403792804613##d2RD][lq_tmp$x##1198:=lq_tmp$x##1238][lq_tmp$x##1202:=lq_anf$##7205759403792804613##d2RD]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1240 : (GHC.Ptr.Ptr {lq_tmp$x##1239 : GHC.Word.Word8 | $k_##1183[VV##1182:=lq_tmp$x##1239][VV##1184:=lq_tmp$x##1240]}) | lq_tmp$x##1240 == op##a1Kc
                                                                                                                                    &amp;&amp; $k_##1185[VV##1184:=lq_tmp$x##1240]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1270 : b | lq_tmp$x##1270 == x2##a1Kb
                      &amp;&amp; $k_##1175[VV##1174:=lq_tmp$x##1270][VV##1179:=lq_anf$##7205759403792804613##d2RD][liquid_internal_this:=lq_anf$##7205759403792804613##d2RD][lq_tmp$x##1192:=lq_tmp$x##1270][lq_tmp$x##1195:=lq_anf$##7205759403792804613##d2RD][lq_tmp$x##1199:=lq_tmp$x##1270][lq_tmp$x##1202:=lq_anf$##7205759403792804613##d2RD][lq_tmp$x##1213:=x1##a1Ka]
                      &amp;&amp; $k_##1178[VV##1177:=lq_tmp$x##1270][VV##1179:=lq_anf$##7205759403792804613##d2RD][liquid_internal_this:=lq_anf$##7205759403792804613##d2RD][lq_tmp$x##1176:=x1##a1Ka][lq_tmp$x##1193:=x1##a1Ka][lq_tmp$x##1194:=lq_tmp$x##1270][lq_tmp$x##1195:=lq_anf$##7205759403792804613##d2RD][lq_tmp$x##1196:=x1##a1Ka][lq_tmp$x##1199:=lq_tmp$x##1270][lq_tmp$x##1200:=x1##a1Ka][lq_tmp$x##1201:=lq_tmp$x##1270][lq_tmp$x##1202:=lq_anf$##7205759403792804613##d2RD][lq_tmp$x##1203:=x1##a1Ka][lq_tmp$x##1213:=x1##a1Ka]}</span><span class='hs-varid'>x2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1246 : (GHC.Ptr.Ptr {lq_tmp$x##1256 : GHC.Word.Word8 | $k_##1255[VV##1254:=lq_tmp$x##1256][lq_tmp$x##1249:=op##a1Kc][lq_tmp$x##1250:=l1##a1K6]}) | pbase lq_tmp$x##1246 == pbase op##a1Kc
                                                                                                                                                              &amp;&amp; plen lq_tmp$x##1246 == plen op##a1Kc - l1##a1K6
                                                                                                                                                              &amp;&amp; 0 &lt;= plen lq_tmp$x##1246}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1258 : (GHC.Ptr.Ptr {lq_tmp$x##1257 : GHC.Word.Word8 | $k_##1183[VV##1182:=lq_tmp$x##1257][VV##1184:=lq_tmp$x##1258]}) | lq_tmp$x##1258 == op##a1Kc
                                                                                                                                    &amp;&amp; $k_##1185[VV##1184:=lq_tmp$x##1258]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`plusPtr`</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1259 : GHC.Types.Int | lq_tmp$x##1259 == l1##a1K6
                                  &amp;&amp; lq_tmp$x##1259 &gt;= 0}</span><span class='hs-varid'>l1</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-comment'>-- | Change a primitives such that it first applies a function to the value</span>
<span class=hs-linenum>192: </span><span class='hs-comment'>-- to be encoded.</span>
<span class=hs-linenum>193: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>194: </span><span class='hs-comment'>-- Note that primitives are 'Contravariant'</span>
<span class=hs-linenum>195: </span><span class='hs-comment'>-- &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a>&gt;. Hence, the following</span>
<span class=hs-linenum>196: </span><span class='hs-comment'>-- laws hold.</span>
<span class=hs-linenum>197: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>198: </span><span class='hs-comment'>-- &gt;contramapF id = id</span>
<span class=hs-linenum>199: </span><span class='hs-comment'>-- &gt;contramapF f . contramapF g = contramapF (g . f)</span>
<span class=hs-linenum>200: </span><span class='hs-comment'>{-# INLINE CONLIKE contramapF #-}</span>
<span class=hs-linenum>201: </span><span class='hs-definition'>contramapF</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>202: </span><a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##1414:(lq_tmp$x##1413:b -&gt; a) -&gt; lq_tmp$x##1415:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim b)</span><span class='hs-definition'>contramapF</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##1413:b -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##1532:{lq_tmp$x##1518 : GHC.Types.Int | lq_tmp$x##1518 &gt;= 0} -&gt; lq_tmp$x##1533:(lq_tmp$x##1530:a -&gt; lq_tmp$x##1531:{lq_tmp$x##1521 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##1521
                                                                                                                                                                                   &amp;&amp; lq_tmp$x##1532 &lt;= plen lq_tmp$x##1521} -&gt; (GHC.Types.IO ())) -&gt; {lq_tmp$x##1527 : (Data.ByteString.Builder.Prim.Internal.FixedPrim a) | Data.ByteString.Builder.Prim.Internal.fpSize lq_tmp$x##1527 == lq_tmp$x##1532
                                                                                                                                                                                                                                                                                                                              &amp;&amp; Data.ByteString.Builder.Prim.Internal.size lq_tmp$x##1527 == lq_tmp$x##1532} | VV == Data.ByteString.Builder.Prim.Internal.FP}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1537 : GHC.Types.Int | lq_tmp$x##1537 == l##a1Ke
                                  &amp;&amp; lq_tmp$x##1537 &gt;= 0}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>xcmp:{lq_tmp$x##1475 : b | $k_##1474[VV##1473:=lq_tmp$x##1475][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd]} -&gt; lq_tmp$x##1476:{lq_tmp$x##1469 : (GHC.Ptr.Ptr {lq_tmp$x##1468 : GHC.Word.Word8 | $k_##1461[VV##1460:=lq_tmp$x##1468][VV##1462:=lq_tmp$x##1469][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd]
                                                                                                                                                                                                     &amp;&amp; $k_##1478[VV##1477:=lq_tmp$x##1468][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd][lq_tmp$x##1485:=xcmp]}) | $k_##1463[VV##1462:=lq_tmp$x##1469][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd]
                                                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##1480[VV##1479:=lq_tmp$x##1469][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd][lq_tmp$x##1485:=xcmp]} -&gt; {lq_tmp$x##1471 : (GHC.Types.IO {lq_tmp$x##1470 : () | $k_##1465[VV##1464:=lq_tmp$x##1470][VV##1466:=lq_tmp$x##1471][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd][lq_tmp$x##1459:=lq_tmp$x##1476]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &amp;&amp; $k_##1482[VV##1481:=lq_tmp$x##1470][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd][lq_tmp$x##1485:=xcmp]}) | $k_##1467[VV##1466:=lq_tmp$x##1471][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd][lq_tmp$x##1459:=lq_tmp$x##1476]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  &amp;&amp; $k_##1484[VV##1483:=lq_tmp$x##1471][lq_tmp$db##13:=io##a1Kf][lq_tmp$db##15:=f##a1Kd][lq_tmp$x##1485:=xcmp]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>lq_tmp$x##1511:a -&gt; lq_tmp$x##1512:{lq_tmp$x##1506 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##1506
                                                                                    &amp;&amp; l##a1Ke &lt;= plen lq_tmp$x##1506} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>io</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##1516:b -&gt; a</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>203: </span>
<span class=hs-linenum>204: </span><span class='hs-comment'>-- | Convert a 'FixedPrim' to a 'BoundedPrim'.</span>
<span class=hs-linenum>205: </span><span class='hs-comment'>{-# INLINE CONLIKE toB #-}</span>
<span class=hs-linenum>206: </span><span class='hs-definition'>toB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>207: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1601:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>toB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x##a1Ki:{VV##1640 : a | $k_##1641} -&gt; op##a1Kj:{VV##1645 : (GHC.Ptr.Ptr {VV##1643 : GHC.Word.Word8 | $k_##1644}) | $k_##1646} -&gt; {VV##1652 : (GHC.Types.IO {VV##1650 : (GHC.Ptr.Ptr {VV##1648 : GHC.Word.Word8 | $k_##1649}) | $k_##1651}) | $k_##1653}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1799 : GHC.Types.Int | lq_tmp$x##1799 == l##a1Kg
                                  &amp;&amp; lq_tmp$x##1799 &gt;= 0}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1763 : (GHC.Base.Monad GHC.Types.IO) | lq_tmp$x##1763 == GHC.Base.$fMonadIO}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##1640 : a | $k_##1641}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##1645 : (GHC.Ptr.Ptr {VV##1643 : GHC.Word.Word8 | $k_##1644}) | $k_##1646}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1663 : a | lq_tmp$x##1663 == x##a1Ki
                      &amp;&amp; $k_##1641[VV##1640:=lq_tmp$x##1663]}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1665 : (GHC.Ptr.Ptr {lq_tmp$x##1664 : GHC.Word.Word8 | $k_##1644[VV##1643:=lq_tmp$x##1664][VV##1645:=lq_tmp$x##1665]}) | lq_tmp$x##1665 == op##a1Kj
                                                                                                                                    &amp;&amp; $k_##1646[VV##1645:=lq_tmp$x##1665]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1735 : (GHC.Types.IO {lq_tmp$x##1734 : (GHC.Ptr.Ptr {lq_tmp$x##1733 : GHC.Word.Word8 | $k_##1728[VV##1727:=lq_tmp$x##1733][VV##1729:=lq_tmp$x##1734][VV##1731:=lq_tmp$x##1735][lq_tmp$x##1713:=lq_anf$##7205759403792804622##d2RM][lq_tmp$x##1714:=lq_anf$##7205759403792804623##d2RN]}) | $k_##1730[VV##1729:=lq_tmp$x##1734][VV##1731:=lq_tmp$x##1735][lq_tmp$x##1713:=lq_anf$##7205759403792804622##d2RM][lq_tmp$x##1714:=lq_anf$##7205759403792804623##d2RN]}) | $k_##1732[VV##1731:=lq_tmp$x##1735][lq_tmp$x##1713:=lq_anf$##7205759403792804622##d2RM][lq_tmp$x##1714:=lq_anf$##7205759403792804623##d2RN]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>forall a . lq_tmp$x##14:a -&gt; (GHC.Types.IO a)</span><span class='hs-varid'>return</span></a> <span class='hs-varop'>$!</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1702 : (GHC.Ptr.Ptr {lq_tmp$x##1701 : GHC.Word.Word8 | $k_##1644[VV##1643:=lq_tmp$x##1701][VV##1645:=lq_tmp$x##1702]}) | lq_tmp$x##1702 == op##a1Kj
                                                                                                                                    &amp;&amp; $k_##1646[VV##1645:=lq_tmp$x##1702]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`plusPtr`</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1703 : GHC.Types.Int | lq_tmp$x##1703 == l##a1Kg
                                  &amp;&amp; lq_tmp$x##1703 &gt;= 0}</span><span class='hs-varid'>l</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>208: </span>
<span class=hs-linenum>209: </span><span class='hs-comment'>-- | Lift a 'FixedPrim' to a 'BoundedPrim'.</span>
<span class=hs-linenum>210: </span><span class='hs-comment'>{-# INLINE CONLIKE liftFixedToBounded #-}</span>
<span class=hs-linenum>211: </span><span class='hs-definition'>liftFixedToBounded</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>212: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1811:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>liftFixedToBounded</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toB</span>
<span class=hs-linenum>213: </span>
<span class=hs-linenum>214: </span><span class='hs-comment'>{-# INLINE CONLIKE storableToF #-}</span>
<span class=hs-linenum>215: </span><span class='hs-comment'>{-# DEPRECATED storableToF
     "Deprecated since @bytestring-0.12.1.0@.\n\nThis function is dangerous in the presence of internal padding\nand makes naive assumptions about alignment.\n\n * For a primitive Haskell type like 'Int64', use the\n   corresponding primitive like 'Data.ByteString.Builder.Prim.int64Host'.\n * For other types, it is recommended to manually write a small\n   function that performs the necessary unaligned write\n   and zeroes or removes any internal padding bits."
  #-}</span>
<span class=hs-linenum>218: </span><span class='hs-definition'>storableToF</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>219: </span><span class='hs-cpp'>#if HS_UNALIGNED_POKES_OK</span>
<span class=hs-linenum>220: </span><span class='hs-definition'>storableToF</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizeOf</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>op</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>poke</span> <span class='hs-layout'>(</span><span class='hs-varid'>castPtr</span> <span class='hs-varid'>op</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<span class=hs-linenum>221: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum>222: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
(Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>storableToF</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##2859:{lq_tmp$x##2852 : a | $k_##2776[VV##2775:=lq_tmp$x##2852]} -&gt; lq_tmp$x##2860:{lq_tmp$x##2854 : (GHC.Ptr.Ptr {lq_tmp$x##2853 : GHC.Word.Word8 | $k_##2779[VV##2778:=lq_tmp$x##2853][VV##2780:=lq_tmp$x##2854][lq_tmp$x##2774:=lq_tmp$x##2859]}) | $k_##2781[VV##2780:=lq_tmp$x##2854][lq_tmp$x##2774:=lq_tmp$x##2859]} -&gt; {lq_tmp$x##2856 : (GHC.Types.IO {lq_tmp$x##2855 : () | $k_##2783[VV##2782:=lq_tmp$x##2855][VV##2784:=lq_tmp$x##2856][lq_tmp$x##2774:=lq_tmp$x##2859][lq_tmp$x##2777:=lq_tmp$x##2860]}) | $k_##2785[VV##2784:=lq_tmp$x##2856][lq_tmp$x##2774:=lq_tmp$x##2859][lq_tmp$x##2777:=lq_tmp$x##2860]}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sizeOf</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2810 : a | $k_##2809[VV##2808:=lq_tmp$x##2810][lq_tmp$x##2800:=fix$36$$36$dIP_a1SE]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##2475 : a | $k_##2476}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##2480 : (GHC.Ptr.Ptr {VV##2478 : GHC.Word.Word8 | $k_##2479}) | $k_##2481}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>223: </span>    <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>Foreign.Ptr.WordPtr</span><span class='hs-varid'>ptrToWordPtr</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2496 : (GHC.Ptr.Ptr {lq_tmp$x##2495 : GHC.Word.Word8 | $k_##2479[VV##2478:=lq_tmp$x##2495][VV##2480:=lq_tmp$x##2496]}) | lq_tmp$x##2496 == op##a1Kl
                                                                                                                                    &amp;&amp; $k_##2481[VV##2480:=lq_tmp$x##2496]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`mod`</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2552 : Foreign.Ptr.WordPtr | lq_tmp$x##2552 == lq_anf$##7205759403792804696##d2SY}</span><span class='hs-varid'>fromIntegral</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>alignment</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2517 : a | $k_##2516[VV##2515:=lq_tmp$x##2517][lq_tmp$x##2507:=fix$36$$36$dIP_a1SY]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2586 : Foreign.Ptr.WordPtr | lq_tmp$x##2586 == lq_anf$##7205759403792804699##d2T1}</span><span class='hs-num'>0</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2769 : (Foreign.Storable.Storable a) | lq_tmp$x##2769 == $dStorable_a1Sn}</span><span class='hs-varid'>poke</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2742 : (GHC.Ptr.Ptr {lq_tmp$x##2750 : a | $k_##2749[VV##2748:=lq_tmp$x##2750][lq_tmp$x##2744:=op##a1Kl]}) | plen lq_tmp$x##2742 == plen op##a1Kl
                                                                                                                       &amp;&amp; 0 &lt;= plen lq_tmp$x##2742}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>castPtr</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2752 : (GHC.Ptr.Ptr {lq_tmp$x##2751 : GHC.Word.Word8 | $k_##2479[VV##2478:=lq_tmp$x##2751][VV##2480:=lq_tmp$x##2752]}) | lq_tmp$x##2752 == op##a1Kl
                                                                                                                                    &amp;&amp; $k_##2481[VV##2480:=lq_tmp$x##2752]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2772 : a | lq_tmp$x##2772 == x##a1Kk
                      &amp;&amp; $k_##2476[VV##2475:=lq_tmp$x##2772]}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>224: </span>    <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##2720:(lq_tmp$x##2717:(GHC.Ptr.Ptr a) -&gt; (GHC.Types.IO {lq_tmp$x##2724 : () | $k_##2723[VV##2722:=lq_tmp$x##2724][lq_tmp$x##2718:=fix$36$$36$dStorable_a1Sn][lq_tmp$x##2719:=x##a1Kk]})) -&gt; (GHC.Types.IO {lq_tmp$x##2724 : () | $k_##2723[VV##2722:=lq_tmp$x##2724][lq_tmp$x##2718:=fix$36$$36$dStorable_a1Sn][lq_tmp$x##2719:=x##a1Kk]})</span><span class='hs-varid'>with</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2727 : a | lq_tmp$x##2727 == x##a1Kk
                      &amp;&amp; $k_##2476[VV##2475:=lq_tmp$x##2727]}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##2692:(GHC.Ptr.Ptr a) -&gt; lq_tmp$x##2693:(GHC.Ptr.Ptr a) -&gt; lq_tmp$x##2694:GHC.Types.Int -&gt; (GHC.Types.IO ()) | VV == Foreign.Marshal.Utils.copyBytes}</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV##2619 : (GHC.Ptr.Ptr {VV##2617 : a | $k_##2618}) | $k_##2620}</span><span class='hs-varid'>tp</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>copyBytes</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2699 : (GHC.Ptr.Ptr {lq_tmp$x##2698 : GHC.Word.Word8 | $k_##2479[VV##2478:=lq_tmp$x##2698][VV##2480:=lq_tmp$x##2699]}) | lq_tmp$x##2699 == op##a1Kl
                                                                                                                                    &amp;&amp; $k_##2481[VV##2480:=lq_tmp$x##2699]}</span><span class='hs-varid'>op</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2629 : (GHC.Ptr.Ptr {lq_tmp$x##2637 : GHC.Word.Word8 | $k_##2636[VV##2635:=lq_tmp$x##2637][lq_tmp$x##2631:=tp##a1Km]}) | plen lq_tmp$x##2629 == plen tp##a1Km
                                                                                                                                    &amp;&amp; 0 &lt;= plen lq_tmp$x##2629}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>castPtr</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2639 : (GHC.Ptr.Ptr {lq_tmp$x##2638 : a | $k_##2618[VV##2617:=lq_tmp$x##2638][VV##2619:=lq_tmp$x##2639]}) | lq_tmp$x##2639 == tp##a1Km
                                                                                                                       &amp;&amp; $k_##2620[VV##2619:=lq_tmp$x##2639]}</span><span class='hs-varid'>tp</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sizeOf</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2660 : a | $k_##2659[VV##2658:=lq_tmp$x##2660][lq_tmp$x##2650:=fix$36$$36$dIP_a1To]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>225: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum>226: </span>
<span class=hs-linenum>227: </span><span class='hs-comment'>{-
{-# INLINE CONLIKE liftIOF #-}
liftIOF :: FixedPrim a -&gt; FixedPrim (IO a)
liftIOF (FP l io) = FP l (\xWrapped op -&gt; do x &lt;- xWrapped; io x op)
-}</span>
<span class=hs-linenum>232: </span>
<span class=hs-linenum>233: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>234: </span><span class='hs-comment'>-- Bounded-size builder primitives</span>
<span class=hs-linenum>235: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>236: </span>
<span class=hs-linenum>237: </span><span class='hs-comment'>-- | A builder primitive that always results in sequence of bytes that is no longer</span>
<span class=hs-linenum>238: </span><span class='hs-comment'>-- than a pre-determined bound.</span>
<span class=hs-linenum>239: </span><span class='hs-comment'>-- #ifdef LIQUID</span>
<span class=hs-linenum>240: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>241: </span><span class='hs-comment'>-- #else </span>
<span class=hs-linenum>242: </span><span class='hs-comment'>-- data BoundedPrim a = BP {-# UNPACK #-} !Int (a -&gt; Ptr Word8 -&gt; IO (Ptr Word8))</span>
<span class=hs-linenum>243: </span><span class='hs-comment'>-- #endif </span>
<span class=hs-linenum>244: </span>
<span class=hs-linenum>245: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PtrS</span> <span class='hs-varid'>a</span> <span class='hs-conid'>Base</span> <span class='hs-conid'>Off</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrV</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>plen</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>plen</span> <span class='hs-conid'>Base</span><span class='hs-layout'>)</span> <span class='hs-comment'>-</span> <span class='hs-conid'>Off</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>246: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <span class='hs-layout'>{</span> <span class='hs-varid'>bpSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span><span class='hs-layout'>,</span> <span class='hs-varid'>bpFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>bpSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-varid'>bpSize</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>247: </span>
<span class=hs-linenum>248: </span><span class='hs-comment'>-- | The bound on the size of sequences of bytes generated by this 'BoundedPrim'.</span>
<span class=hs-linenum>249: </span><span class='hs-comment'>{-# INLINE CONLIKE sizeBound #-}</span>
<span class=hs-linenum>250: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>sizeBound</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>251: </span><span class='hs-definition'>sizeBound</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>252: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2871:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; {VV : GHC.Types.Int | VV == Data.ByteString.Builder.Prim.Internal.sizeBound lq_tmp$x##2871}</span><span class='hs-definition'>sizeBound</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2912 : GHC.Types.Int | lq_tmp$x##2912 == b##a1Kn
                                  &amp;&amp; lq_tmp$x##2912 &gt;= 0}</span><span class='hs-varid'>b</span></a>
<span class=hs-linenum>253: </span>
<span class=hs-linenum>254: </span><span class='hs-comment'>-- | @since 0.10.12.0</span>
<span class=hs-linenum>255: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>boundedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>256: </span><span class='hs-definition'>boundedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>257: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2916:{VV##0 : GHC.Types.Int | VV##0 &gt;= 0} -&gt; lq_tmp$x##2917:(lq_tmp$x##2914:a -&gt; lq_tmp$x##2915:{VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV##0
                                                                                                                                                  &amp;&amp; lq_tmp$x##2916 &lt;= plen VV##0} -&gt; (GHC.Types.IO {VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen VV##0 &gt;= plen lq_tmp$x##2915 - lq_tmp$x##2916
                                                                                                                                                                                                                                            &amp;&amp; 0 &lt;= plen VV##0})) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>boundedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span>
<span class=hs-linenum>258: </span>
<span class=hs-linenum>259: </span><span class='hs-comment'>-- {-# DEPRECATED boudedPrim "Use 'boundedPrim' instead" #-}</span>
<span class=hs-linenum>260: </span><span class='hs-comment'>-- boudedPrim :: Int -&gt; (a -&gt; Ptr Word8 -&gt; IO (Ptr Word8)) -&gt; BoundedPrim a</span>
<span class=hs-linenum>261: </span><span class='hs-comment'>-- boudedPrim = BP</span>
<span class=hs-linenum>262: </span>
<span class=hs-linenum>263: </span><span class='hs-comment'>{-# INLINE CONLIKE runB #-}</span>
<span class=hs-linenum>264: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>runB</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>bp</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>p</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>PtrGN</span> <span class='hs-conid'>Word8</span> <span class='hs-keyword'>{sizeBound bp}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>PtrS</span> <span class='hs-conid'>Word8</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizeBound</span> <span class='hs-varid'>bp</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>265: </span><span class='hs-definition'>runB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>266: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2957:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##2958:a -&gt; lq_tmp$x##2959:{VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen VV##0
                                                                                                                                                   &amp;&amp; Data.ByteString.Builder.Prim.Internal.sizeBound lq_tmp$x##2957 &lt;= plen VV##0} -&gt; (GHC.Types.IO {VV##0 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen VV##0 &gt;= plen lq_tmp$x##2959 - Data.ByteString.Builder.Prim.Internal.sizeBound lq_tmp$x##2957
                                                                                                                                                                                                                                                                                             &amp;&amp; 0 &lt;= plen VV##0})</span><span class='hs-definition'>runB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3008:a -&gt; lq_tmp$x##3009:{lq_tmp$x##3002 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3002
                                                                                    &amp;&amp; ds_d2Pm &lt;= plen lq_tmp$x##3002} -&gt; (GHC.Types.IO {lq_tmp$x##3004 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3004 &gt;= plen lq_tmp$x##3009 - ds_d2Pm
                                                                                                                                                                                         &amp;&amp; 0 &lt;= plen lq_tmp$x##3004})</span><span class='hs-varid'>io</span></a>
<span class=hs-linenum>267: </span>
<span class=hs-linenum>268: </span><span class='hs-comment'>-- | Change a 'BoundedPrim' such that it first applies a function to the</span>
<span class=hs-linenum>269: </span><span class='hs-comment'>-- value to be encoded.</span>
<span class=hs-linenum>270: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>271: </span><span class='hs-comment'>-- Note that 'BoundedPrim's are 'Contravariant'</span>
<span class=hs-linenum>272: </span><span class='hs-comment'>-- &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a>&gt;. Hence, the following</span>
<span class=hs-linenum>273: </span><span class='hs-comment'>-- laws hold.</span>
<span class=hs-linenum>274: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>275: </span><span class='hs-comment'>-- &gt;contramapB id = id</span>
<span class=hs-linenum>276: </span><span class='hs-comment'>-- &gt;contramapB f . contramapB g = contramapB (g . f)</span>
<span class=hs-linenum>277: </span><span class='hs-comment'>{-# INLINE CONLIKE contramapB #-}</span>
<span class=hs-linenum>278: </span><span class='hs-definition'>contramapB</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>279: </span><a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##3014:(lq_tmp$x##3013:b -&gt; a) -&gt; lq_tmp$x##3015:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim b)</span><span class='hs-definition'>contramapB</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3013:b -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##3143:{lq_tmp$x##3128 : GHC.Types.Int | lq_tmp$x##3128 &gt;= 0} -&gt; lq_tmp$x##3144:(lq_tmp$x##3141:a -&gt; lq_tmp$x##3142:{lq_tmp$x##3131 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3131
                                                                                                                                                                                   &amp;&amp; lq_tmp$x##3143 &lt;= plen lq_tmp$x##3131} -&gt; (GHC.Types.IO {lq_tmp$x##3133 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3133 &gt;= plen lq_tmp$x##3142 - lq_tmp$x##3143
                                                                                                                                                                                                                                                                                               &amp;&amp; 0 &lt;= plen lq_tmp$x##3133})) -&gt; {lq_tmp$x##3138 : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | Data.ByteString.Builder.Prim.Internal.bpSize lq_tmp$x##3138 == lq_tmp$x##3143
                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; Data.ByteString.Builder.Prim.Internal.sizeBound lq_tmp$x##3138 == lq_tmp$x##3143} | VV == Data.ByteString.Builder.Prim.Internal.BP}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3148 : GHC.Types.Int | lq_tmp$x##3148 == b##a1Kq
                                  &amp;&amp; lq_tmp$x##3148 &gt;= 0}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>xcmp:{lq_tmp$x##3080 : b | $k_##3079[VV##3078:=lq_tmp$x##3080][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp]} -&gt; lq_tmp$x##3081:{lq_tmp$x##3073 : (GHC.Ptr.Ptr {lq_tmp$x##3072 : GHC.Word.Word8 | $k_##3063[VV##3062:=lq_tmp$x##3072][VV##3064:=lq_tmp$x##3073][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp]
                                                                                                                                                                                                     &amp;&amp; $k_##3083[VV##3082:=lq_tmp$x##3072][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp][lq_tmp$x##3092:=xcmp]}) | $k_##3065[VV##3064:=lq_tmp$x##3073][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp]
                                                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##3085[VV##3084:=lq_tmp$x##3073][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp][lq_tmp$x##3092:=xcmp]} -&gt; {lq_tmp$x##3076 : (GHC.Types.IO {lq_tmp$x##3075 : (GHC.Ptr.Ptr {lq_tmp$x##3074 : GHC.Word.Word8 | $k_##3067[VV##3066:=lq_tmp$x##3074][VV##3068:=lq_tmp$x##3075][VV##3070:=lq_tmp$x##3076][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp][lq_tmp$x##3061:=lq_tmp$x##3081]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; $k_##3087[VV##3086:=lq_tmp$x##3074][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp][lq_tmp$x##3092:=xcmp]}) | $k_##3069[VV##3068:=lq_tmp$x##3075][VV##3070:=lq_tmp$x##3076][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp][lq_tmp$x##3061:=lq_tmp$x##3081]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##3089[VV##3088:=lq_tmp$x##3075][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp][lq_tmp$x##3092:=xcmp]}) | $k_##3071[VV##3070:=lq_tmp$x##3076][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp][lq_tmp$x##3061:=lq_tmp$x##3081]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; $k_##3091[VV##3090:=lq_tmp$x##3076][lq_tmp$db##13:=io##a1Kr][lq_tmp$db##15:=f##a1Kp][lq_tmp$x##3092:=xcmp]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>lq_tmp$x##3121:a -&gt; lq_tmp$x##3122:{lq_tmp$x##3115 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3115
                                                                                    &amp;&amp; b##a1Kq &lt;= plen lq_tmp$x##3115} -&gt; (GHC.Types.IO {lq_tmp$x##3117 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3117 &gt;= plen lq_tmp$x##3122 - b##a1Kq
                                                                                                                                                                                         &amp;&amp; 0 &lt;= plen lq_tmp$x##3117})</span><span class='hs-varid'>io</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3126:b -&gt; a</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>280: </span>
<span class=hs-linenum>281: </span><span class='hs-comment'>-- | The 'BoundedPrim' that always results in the zero-length sequence.</span>
<span class=hs-linenum>282: </span><span class='hs-comment'>{-# INLINE CONLIKE emptyB #-}</span>
<span class=hs-linenum>283: </span><span class='hs-definition'>emptyB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>284: </span><a class=annot href="#"><span class=annottext>forall a . (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>emptyB</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3220 : GHC.Types.Int | lq_tmp$x##3220 == (lq_anf$##7205759403792804713##d2Tf : int)}</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {lq_tmp$x##3250 : (GHC.Ptr.Ptr {lq_tmp$x##3249 : GHC.Word.Word8 | $k_##3246[VV##3245:=lq_tmp$x##3249][VV##3247:=lq_tmp$x##3250][lq_tmp$x##14:=op##a1Ks]}) | $k_##3248[VV##3247:=lq_tmp$x##3250][lq_tmp$x##14:=op##a1Ks]})</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{VV##3230 : (GHC.Ptr.Ptr {VV##3228 : GHC.Word.Word8 | $k_##3229}) | $k_##3231}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3252 : (GHC.Ptr.Ptr {lq_tmp$x##3251 : GHC.Word.Word8 | $k_##3229[VV##3228:=lq_tmp$x##3251][VV##3230:=lq_tmp$x##3252]}) | lq_tmp$x##3252 == op##a1Ks
                                                                                                                                    &amp;&amp; $k_##3231[VV##3230:=lq_tmp$x##3252]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>285: </span>
<span class=hs-linenum>286: </span><span class='hs-comment'>-- | Encode a pair by encoding its first component and then its second component.</span>
<span class=hs-linenum>287: </span><span class='hs-comment'>{-# INLINE CONLIKE pairB #-}</span>
<span class=hs-linenum>288: </span><span class='hs-definition'>pairB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>289: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3289:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3290:(Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (a, b))</span><span class='hs-definition'>pairB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>290: </span>    <a class=annot href="#"><span class=annottext>ds_d2P5:{VV##3396 : ({VV##3389 : a | $k_##3390}, {VV##3391 : b | $k_##3392})&lt;\lq_tmp$x##3393 VV -&gt; {VV##3394 : b | $k_##3395}&gt; | $k_##3397} -&gt; op##a1Kz:{VV##3401 : (GHC.Ptr.Ptr {VV##3399 : GHC.Word.Word8 | $k_##3400}) | $k_##3402} -&gt; {VV##3408 : (GHC.Types.IO {VV##3406 : (GHC.Ptr.Ptr {VV##3404 : GHC.Word.Word8 | $k_##3405}) | $k_##3407}) | $k_##3409}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3383 : GHC.Types.Int | lq_tmp$x##3383 == b1##a1Kt + b2##a1Kv}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##3386 : GHC.Types.Int | lq_tmp$x##3386 == b1##a1Kt
                                  &amp;&amp; lq_tmp$x##3386 &gt;= 0}</span><span class='hs-varid'>b1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3387 : GHC.Types.Int | lq_tmp$x##3387 == b2##a1Kv
                                  &amp;&amp; lq_tmp$x##3387 &gt;= 0}</span><span class='hs-varid'>b2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3414 : ({lq_tmp$x##3410 : a | $k_##3390[VV##3389:=lq_tmp$x##3410][VV##3396:=lq_tmp$x##3414]}, {lq_tmp$x##3411 : b | $k_##3392[VV##3391:=lq_tmp$x##3411][VV##3396:=lq_tmp$x##3414]})&lt;\lq_tmp$x##3415 VV -&gt; {lq_tmp$x##3413 : b | $k_##3395[VV##3394:=lq_tmp$x##3413][VV##3396:=lq_tmp$x##3414][lq_tmp$x##3393:=lq_tmp$x##3415][lq_tmp$x##3412:=lq_tmp$x##3415]}&gt; | lq_tmp$x##3414 == ds_d2P5
                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##3397[VV##3396:=lq_tmp$x##3414]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV##3401 : (GHC.Ptr.Ptr {VV##3399 : GHC.Word.Word8 | $k_##3400}) | $k_##3402}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {lq_tmp$x##3452 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3452 &gt;= plen op##a1Kz - b1##a1Kt
                                                               &amp;&amp; 0 &lt;= plen lq_tmp$x##3452})</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3458 : a | lq_tmp$x##3458 == x1##a1Kx
                      &amp;&amp; $k_##3390[VV##3389:=lq_tmp$x##3458][VV##3396:=lq_anf$##7205759403792804719##d2Tl][liquid_internal_this:=lq_anf$##7205759403792804719##d2Tl][lq_tmp$x##3410:=lq_tmp$x##3458][lq_tmp$x##3414:=lq_anf$##7205759403792804719##d2Tl][lq_tmp$x##3417:=lq_tmp$x##3458][lq_tmp$x##3421:=lq_anf$##7205759403792804719##d2Tl]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3460 : (GHC.Ptr.Ptr {lq_tmp$x##3459 : GHC.Word.Word8 | $k_##3400[VV##3399:=lq_tmp$x##3459][VV##3401:=lq_tmp$x##3460]}) | lq_tmp$x##3460 == op##a1Kz
                                                                                                                                    &amp;&amp; $k_##3402[VV##3401:=lq_tmp$x##3460]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3471:{lq_tmp$x##3464 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3464
                                                                &amp;&amp; b2##a1Kv &lt;= plen lq_tmp$x##3464} -&gt; (GHC.Types.IO {lq_tmp$x##3466 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3466 &gt;= plen lq_tmp$x##3471 - b2##a1Kv
                                                                                                                                                                      &amp;&amp; 0 &lt;= plen lq_tmp$x##3466})</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3472 : b | lq_tmp$x##3472 == x2##a1Ky
                      &amp;&amp; $k_##3392[VV##3391:=lq_tmp$x##3472][VV##3396:=lq_anf$##7205759403792804719##d2Tl][liquid_internal_this:=lq_anf$##7205759403792804719##d2Tl][lq_tmp$x##3411:=lq_tmp$x##3472][lq_tmp$x##3414:=lq_anf$##7205759403792804719##d2Tl][lq_tmp$x##3418:=lq_tmp$x##3472][lq_tmp$x##3421:=lq_anf$##7205759403792804719##d2Tl][lq_tmp$x##3432:=x1##a1Kx]
                      &amp;&amp; $k_##3395[VV##3394:=lq_tmp$x##3472][VV##3396:=lq_anf$##7205759403792804719##d2Tl][liquid_internal_this:=lq_anf$##7205759403792804719##d2Tl][lq_tmp$x##3393:=x1##a1Kx][lq_tmp$x##3412:=x1##a1Kx][lq_tmp$x##3413:=lq_tmp$x##3472][lq_tmp$x##3414:=lq_anf$##7205759403792804719##d2Tl][lq_tmp$x##3415:=x1##a1Kx][lq_tmp$x##3418:=lq_tmp$x##3472][lq_tmp$x##3419:=x1##a1Kx][lq_tmp$x##3420:=lq_tmp$x##3472][lq_tmp$x##3421:=lq_anf$##7205759403792804719##d2Tl][lq_tmp$x##3422:=x1##a1Kx][lq_tmp$x##3432:=x1##a1Kx]}</span><span class='hs-varid'>x2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>291: </span>
<span class=hs-linenum>292: </span><span class='hs-comment'>-- | Encode an 'Either' value using the first 'BoundedPrim' for 'Left'</span>
<span class=hs-linenum>293: </span><span class='hs-comment'>-- values and the second 'BoundedPrim' for 'Right' values.</span>
<span class=hs-linenum>294: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>295: </span><span class='hs-comment'>-- Note that the functions 'eitherB', 'pairB', and 'contramapB' (written below</span>
<span class=hs-linenum>296: </span><span class='hs-comment'>-- using '&gt;$&lt;') suffice to construct 'BoundedPrim's for all non-recursive</span>
<span class=hs-linenum>297: </span><span class='hs-comment'>-- algebraic datatypes. For example,</span>
<span class=hs-linenum>298: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>299: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>300: </span><span class='hs-comment'>--maybeB :: BoundedPrim () -&gt; BoundedPrim a -&gt; BoundedPrim (Maybe a)</span>
<span class=hs-linenum>301: </span><span class='hs-comment'>--maybeB nothing just = 'maybe' (Left ()) Right '&gt;$&lt;' eitherB nothing just</span>
<span class=hs-linenum>302: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>303: </span><span class='hs-comment'>{-# INLINE CONLIKE eitherB #-}</span>
<span class=hs-linenum>304: </span><span class='hs-definition'>eitherB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>305: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3629:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3630:(Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (Data.Either.Either a b))</span><span class='hs-definition'>eitherB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>306: </span>    <span class='hs-conid'>BP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3724 : GHC.Types.Int | lq_tmp$x##3724 == (if b1##a1KA &gt; b2##a1KC then b1##a1KA else b2##a1KC)
                                  &amp;&amp; $k_##3723[VV##3722:=lq_tmp$x##3724][lq_tmp$x##3719:=GHC.Classes.$fOrdInt][lq_tmp$x##3720:=b1##a1KA][lq_tmp$x##3721:=b2##a1KC]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>max</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3727 : GHC.Types.Int | lq_tmp$x##3727 == b1##a1KA
                                  &amp;&amp; lq_tmp$x##3727 &gt;= 0}</span><span class='hs-varid'>b1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3728 : GHC.Types.Int | lq_tmp$x##3728 == b2##a1KC
                                  &amp;&amp; lq_tmp$x##3728 &gt;= 0}</span><span class='hs-varid'>b2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>307: </span>        <a class=annot href="#"><span class=annottext>{lq_tmp$x##3750 : (Data.Either.Either {lq_tmp$x##3748 : a | $k_##3731[VV##3730:=lq_tmp$x##3748][VV##3734:=lq_tmp$x##3750]} {lq_tmp$x##3749 : b | $k_##3733[VV##3732:=lq_tmp$x##3749][VV##3734:=lq_tmp$x##3750]}) | lq_tmp$x##3750 == x##a1KE
                                                                                                                                                                                                                   &amp;&amp; $k_##3735[VV##3734:=lq_tmp$x##3750]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##3734 : (Data.Either.Either {VV##3730 : a | $k_##3731} {VV##3732 : b | $k_##3733}) | $k_##3735}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##3739 : (GHC.Ptr.Ptr {VV##3737 : GHC.Word.Word8 | $k_##3738}) | $k_##3740}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3750 : (Data.Either.Either {lq_tmp$x##3748 : a | $k_##3731[VV##3730:=lq_tmp$x##3748][VV##3734:=lq_tmp$x##3750]} {lq_tmp$x##3749 : b | $k_##3733[VV##3732:=lq_tmp$x##3749][VV##3734:=lq_tmp$x##3750]}) | lq_tmp$x##3750 == x##a1KE
                                                                                                                                                                                                                   &amp;&amp; $k_##3735[VV##3734:=lq_tmp$x##3750]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>of</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3777:a -&gt; lq_tmp$x##3778:{lq_tmp$x##3771 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3771
                                                                                    &amp;&amp; b1##a1KA &lt;= plen lq_tmp$x##3771} -&gt; (GHC.Types.IO {lq_tmp$x##3773 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3773 &gt;= plen lq_tmp$x##3778 - b1##a1KA
                                                                                                                                                                                          &amp;&amp; 0 &lt;= plen lq_tmp$x##3773})</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3779 : a | lq_tmp$x##3779 == x1##a1KG
                      &amp;&amp; $k_##3731[VV##3730:=lq_tmp$x##3779][VV##3734:=lq_anf$##7205759403792804726##d2Ts][liquid_internal_this:=lq_anf$##7205759403792804726##d2Ts][lq_tmp$x##3748:=lq_tmp$x##3779][lq_tmp$x##3750:=lq_anf$##7205759403792804726##d2Ts][lq_tmp$x##3752:=lq_tmp$x##3779][lq_tmp$x##3754:=lq_anf$##7205759403792804726##d2Ts]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3781 : (GHC.Ptr.Ptr {lq_tmp$x##3780 : GHC.Word.Word8 | $k_##3738[VV##3737:=lq_tmp$x##3780][VV##3739:=lq_tmp$x##3781]}) | lq_tmp$x##3781 == op##a1KF
                                                                                                                                    &amp;&amp; $k_##3740[VV##3739:=lq_tmp$x##3781]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>;</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3807:b -&gt; lq_tmp$x##3808:{lq_tmp$x##3801 : (GHC.Ptr.Ptr GHC.Word.Word8) | 0 &lt;= plen lq_tmp$x##3801
                                                                                    &amp;&amp; b2##a1KC &lt;= plen lq_tmp$x##3801} -&gt; (GHC.Types.IO {lq_tmp$x##3803 : (GHC.Ptr.Ptr GHC.Word.Word8) | plen lq_tmp$x##3803 &gt;= plen lq_tmp$x##3808 - b2##a1KC
                                                                                                                                                                                          &amp;&amp; 0 &lt;= plen lq_tmp$x##3803})</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3809 : b | lq_tmp$x##3809 == x2##a1KH
                      &amp;&amp; $k_##3733[VV##3732:=lq_tmp$x##3809][VV##3734:=lq_anf$##7205759403792804726##d2Ts][liquid_internal_this:=lq_anf$##7205759403792804726##d2Ts][lq_tmp$x##3749:=lq_tmp$x##3809][lq_tmp$x##3750:=lq_anf$##7205759403792804726##d2Ts][lq_tmp$x##3783:=lq_tmp$x##3809][lq_tmp$x##3784:=lq_anf$##7205759403792804726##d2Ts]}</span><span class='hs-varid'>x2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3811 : (GHC.Ptr.Ptr {lq_tmp$x##3810 : GHC.Word.Word8 | $k_##3738[VV##3737:=lq_tmp$x##3810][VV##3739:=lq_tmp$x##3811]}) | lq_tmp$x##3811 == op##a1KF
                                                                                                                                    &amp;&amp; $k_##3740[VV##3739:=lq_tmp$x##3811]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>308: </span>
<span class=hs-linenum>309: </span><span class='hs-comment'>-- | Conditionally select a 'BoundedPrim'.</span>
<span class=hs-linenum>310: </span><span class='hs-comment'>-- For example, we can implement the ASCII primitive that drops characters with</span>
<span class=hs-linenum>311: </span><span class='hs-comment'>-- Unicode codepoints above 127 as follows.</span>
<span class=hs-linenum>312: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>313: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>314: </span><span class='hs-comment'>--charASCIIDrop = 'condB' (&lt; \'\\128\') ('liftFixedToBounded' 'Data.ByteString.Builder.Prim.char7') 'emptyB'</span>
<span class=hs-linenum>315: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>316: </span><span class='hs-comment'>{-# INLINE CONLIKE condB #-}</span>
<span class=hs-linenum>317: </span><span class='hs-definition'>condB</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>318: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##3855:(lq_tmp$x##3854:a -&gt; GHC.Types.Bool) -&gt; lq_tmp$x##3856:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3857:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>condB</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3854:a -&gt; GHC.Types.Bool</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>be1</span></a> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>be2</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>319: </span>    <span class='hs-varid'>contramapB</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3876 : GHC.Types.Bool | lq_tmp$x##3876 == lq_anf$##7205759403792804728##d2Tu}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##3861 : a | $k_##3862}</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3874 : a | lq_tmp$x##3874 == x##a1KL
                      &amp;&amp; $k_##3862[VV##3861:=lq_tmp$x##3874]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      lq_tmp$x##3906:a -&gt; {lq_tmp$x##3904 : (Data.Either.Either a b) | isLeft lq_tmp$x##3904} | VV == Data.Either.Left}</span><span class='hs-conid'>Left</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3913 : a | lq_tmp$x##3913 == x##a1KL
                      &amp;&amp; $k_##3862[VV##3861:=lq_tmp$x##3913]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      lq_tmp$x##3888:b -&gt; {lq_tmp$x##3886 : (Data.Either.Either a b) | not (isLeft lq_tmp$x##3886)} | VV == Data.Either.Right}</span><span class='hs-conid'>Right</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3895 : a | lq_tmp$x##3895 == x##a1KL
                      &amp;&amp; $k_##3862[VV##3861:=lq_tmp$x##3895]}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim (Data.Either.Either {lq_tmp$x##3929 : a | $k_##3928[VV##3927:=lq_tmp$x##3929][lq_tmp$x##3925:=be1##a1KJ][lq_tmp$x##3926:=be2##a1KK]} {lq_tmp$x##3932 : a | $k_##3931[VV##3930:=lq_tmp$x##3932][lq_tmp$x##3925:=be1##a1KJ][lq_tmp$x##3926:=be2##a1KK]}))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>eitherB</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3934 : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | lq_tmp$x##3934 == be1##a1KJ}</span><span class='hs-varid'>be1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3936 : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | lq_tmp$x##3936 == be2##a1KK}</span><span class='hs-varid'>be2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>320: </span>
</pre>
</body>
</html>