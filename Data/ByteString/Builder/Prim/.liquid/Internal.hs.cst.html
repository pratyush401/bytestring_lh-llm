<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>./Data/ByteString/Builder/Prim/Internal.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>  1: </span><a class=annot href="#"><span class=annottext>{VV##4155 : GHC.Types.Module | $k_##4156}</span><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables, CPP #-}</span></a>
<span class=hs-linenum>  2: </span><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<span class=hs-linenum>  3: </span><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<span class=hs-linenum>  4: </span><span class='hs-comment'>-- |</span>
<span class=hs-linenum>  5: </span><span class='hs-comment'>-- Copyright   : 2010-2011 Simon Meier, 2010 Jasper van der Jeugt</span>
<span class=hs-linenum>  6: </span><span class='hs-comment'>-- License     : BSD3-style (see LICENSE)</span>
<span class=hs-linenum>  7: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>  8: </span><span class='hs-comment'>-- Maintainer  : Simon Meier &lt;iridcode@gmail.com&gt;</span>
<span class=hs-linenum>  9: </span><span class='hs-comment'>-- Stability   : unstable, private</span>
<span class=hs-linenum> 10: </span><span class='hs-comment'>-- Portability : GHC</span>
<span class=hs-linenum> 11: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 12: </span><span class='hs-comment'>-- *Warning:* this module is internal. If you find that you need it please</span>
<span class=hs-linenum> 13: </span><span class='hs-comment'>-- contact the maintainers and explain what you are trying to do and discuss</span>
<span class=hs-linenum> 14: </span><span class='hs-comment'>-- what you would need in the public API. It is important that you do this as</span>
<span class=hs-linenum> 15: </span><span class='hs-comment'>-- the module may not be exposed at all in future releases.</span>
<span class=hs-linenum> 16: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 17: </span><span class='hs-comment'>-- The maintainers are glad to accept patches for further</span>
<span class=hs-linenum> 18: </span><span class='hs-comment'>-- standard encodings of standard Haskell values.</span>
<span class=hs-linenum> 19: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 20: </span><span class='hs-comment'>-- If you need to write your own builder primitives, then be aware that you are</span>
<span class=hs-linenum> 21: </span><span class='hs-comment'>-- writing code with /all safety belts off/; i.e.,</span>
<span class=hs-linenum> 22: </span><span class='hs-comment'>-- *this is the code that might make your application vulnerable to buffer-overflow attacks!*</span>
<span class=hs-linenum> 23: </span><span class='hs-comment'>-- The "Data.ByteString.Builder.Prim.Tests" module provides you with</span>
<span class=hs-linenum> 24: </span><span class='hs-comment'>-- utilities for testing your encodings thoroughly.</span>
<span class=hs-linenum> 25: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 26: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.ByteString.Builder.Prim.Internal</span> <span class='hs-layout'>(</span>
<span class=hs-linenum> 27: </span>  <span class='hs-comment'>-- * Fixed-size builder primitives</span>
<span class=hs-linenum> 28: </span>    <span class='hs-conid'>Size</span>
<span class=hs-linenum> 29: </span>  <span class='hs-layout'>,</span> <span class='hs-conid'>FixedPrim</span>
<span class=hs-linenum> 30: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>fixedPrim</span>
<span class=hs-linenum> 31: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>size</span>
<span class=hs-linenum> 32: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>runF</span>
<span class=hs-linenum> 33: </span>
<span class=hs-linenum> 34: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>emptyF</span>
<span class=hs-linenum> 35: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>contramapF</span>
<span class=hs-linenum> 36: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>pairF</span>
<span class=hs-linenum> 37: </span>  <span class='hs-comment'>-- , liftIOF</span>
<span class=hs-linenum> 38: </span>
<span class=hs-linenum> 39: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>storableToF</span>
<span class=hs-linenum> 40: </span>
<span class=hs-linenum> 41: </span>  <span class='hs-comment'>-- * Bounded-size builder primitives</span>
<span class=hs-linenum> 42: </span>  <span class='hs-layout'>,</span> <span class='hs-conid'>BoundedPrim</span>
<span class=hs-linenum> 43: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>boundedPrim</span>
<span class=hs-linenum> 44: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>sizeBound</span>
<span class=hs-linenum> 45: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>runB</span>
<span class=hs-linenum> 46: </span>
<span class=hs-linenum> 47: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>emptyB</span>
<span class=hs-linenum> 48: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>contramapB</span>
<span class=hs-linenum> 49: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>pairB</span>
<span class=hs-linenum> 50: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>eitherB</span>
<span class=hs-linenum> 51: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>condB</span>
<span class=hs-linenum> 52: </span>
<span class=hs-linenum> 53: </span>  <span class='hs-comment'>-- , liftIOB</span>
<span class=hs-linenum> 54: </span>
<span class=hs-linenum> 55: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>toB</span>
<span class=hs-linenum> 56: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>liftFixedToBounded</span>
<span class=hs-linenum> 57: </span>
<span class=hs-linenum> 58: </span>  <span class='hs-comment'>-- , withSizeFB</span>
<span class=hs-linenum> 59: </span>  <span class='hs-comment'>-- , withSizeBB</span>
<span class=hs-linenum> 60: </span>
<span class=hs-linenum> 61: </span>  <span class='hs-comment'>-- * Shared operators</span>
<span class=hs-linenum> 62: </span>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 63: </span>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 64: </span>
<span class=hs-linenum> 65: </span>  <span class='hs-comment'>-- * Helpers</span>
<span class=hs-linenum> 66: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>caseWordSize_32_64</span>
<span class=hs-linenum> 67: </span>
<span class=hs-linenum> 68: </span>  <span class='hs-comment'>-- * Deprecated</span>
<span class=hs-linenum> 69: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>boudedPrim</span>
<span class=hs-linenum> 70: </span>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 71: </span>
<span class=hs-linenum> 72: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign</span>
<span class=hs-linenum> 73: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>maxBound</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 74: </span>
<span class=hs-linenum> 75: </span><span class='hs-cpp'>#include "MachDeps.h"</span>
<span class=hs-linenum> 76: </span><span class='hs-cpp'>#include "bytestring-cpp-macros.h"</span>
<span class=hs-linenum> 77: </span>
<span class=hs-linenum> 78: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum> 79: </span><span class='hs-comment'>-- Supporting infrastructure</span>
<span class=hs-linenum> 80: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum> 81: </span>
<span class=hs-linenum> 82: </span><span class='hs-comment'>-- | Contravariant functors as in the @contravariant@ package.</span>
<span class=hs-linenum> 83: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>Contravariant</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 84: </span>    <span class='hs-varid'>contramap</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<span class=hs-linenum> 85: </span>
<span class=hs-linenum> 86: </span><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>&gt;$&lt;</span>
<span class=hs-linenum> 87: </span>
<span class=hs-linenum> 88: </span><span class='hs-comment'>-- | A fmap-like operator for builder primitives, both bounded and fixed size.</span>
<span class=hs-linenum> 89: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 90: </span><span class='hs-comment'>-- Builder primitives are contravariant so it's like the normal fmap, but</span>
<span class=hs-linenum> 91: </span><span class='hs-comment'>-- backwards (look at the type). (If it helps to remember, the operator symbol</span>
<span class=hs-linenum> 92: </span><span class='hs-comment'>-- is like (&lt;$&gt;) but backwards.)</span>
<span class=hs-linenum> 93: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 94: </span><span class='hs-comment'>-- We can use it for example to prepend and/or append fixed values to an</span>
<span class=hs-linenum> 95: </span><span class='hs-comment'>-- primitive.</span>
<span class=hs-linenum> 96: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 97: </span><span class='hs-comment'>-- &gt; import Data.ByteString.Builder.Prim as P</span>
<span class=hs-linenum> 98: </span><span class='hs-comment'>-- &gt;showEncoding ((\x -&gt; ('\'', (x, '\''))) &gt;$&lt; fixed3) 'x' = "'x'"</span>
<span class=hs-linenum> 99: </span><span class='hs-comment'>-- &gt;  where</span>
<span class=hs-linenum>100: </span><span class='hs-comment'>-- &gt;    fixed3 = P.char7 &gt;*&lt; P.char7 &gt;*&lt; P.char7</span>
<span class=hs-linenum>101: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>102: </span><span class='hs-comment'>-- Note that the rather verbose syntax for composition stems from the</span>
<span class=hs-linenum>103: </span><span class='hs-comment'>-- requirement to be able to compute the size / size bound at compile time.</span>
<span class=hs-linenum>104: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>105: </span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Contravariant</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>106: </span><a class=annot href="#"><span class=annottext>forall f b a .
(Data.ByteString.Builder.Prim.Internal.Contravariant&lt;[]&gt; f) =&gt;
lq_tmp$x##894:(lq_tmp$x##892:b -&gt; a) -&gt; lq_tmp$x##895:f a -&gt; f b</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&gt;$&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramap</span>
<span class=hs-linenum>107: </span>
<span class=hs-linenum>108: </span>
<span class=hs-linenum>109: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Contravariant Data.ByteString.Builder.Prim.Internal.FixedPrim)</span><span class='hs-conid'>Contravariant</span></a> <span class='hs-conid'>FixedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>110: </span>    <a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##1651:(lq_tmp$x##1650:{lq_tmp$x##1655 : b | $k_##1654[VV##1653:=lq_tmp$x##1655]} -&gt; {lq_tmp$x##1658 : a | $k_##1657[VV##1656:=lq_tmp$x##1658]}) -&gt; lq_tmp$x##1652:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1658 : a | $k_##1657[VV##1656:=lq_tmp$x##1658]}) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1655 : b | $k_##1654[VV##1653:=lq_tmp$x##1655]})</span><span class='hs-varid'>contramap</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramapF</span>
<span class=hs-linenum>111: </span>
<span class=hs-linenum>112: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Contravariant Data.ByteString.Builder.Prim.Internal.BoundedPrim)</span><span class='hs-conid'>Contravariant</span></a> <span class='hs-conid'>BoundedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>113: </span>    <a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##3306:(lq_tmp$x##3305:{lq_tmp$x##3310 : b | $k_##3309[VV##3308:=lq_tmp$x##3310]} -&gt; {lq_tmp$x##3313 : a | $k_##3312[VV##3311:=lq_tmp$x##3313]}) -&gt; lq_tmp$x##3307:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3313 : a | $k_##3312[VV##3311:=lq_tmp$x##3313]}) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3310 : b | $k_##3309[VV##3308:=lq_tmp$x##3310]})</span><span class='hs-varid'>contramap</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contramapB</span>
<span class=hs-linenum>114: </span>
<span class=hs-linenum>115: </span>
<span class=hs-linenum>116: </span><span class='hs-comment'>-- | Type-constructors supporting lifting of type-products.</span>
<span class=hs-linenum>117: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>Monoidal</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>118: </span>    <span class='hs-varid'>pair</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>119: </span>
<span class=hs-linenum>120: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Monoidal Data.ByteString.Builder.Prim.Internal.FixedPrim)</span><span class='hs-conid'>Monoidal</span></a> <span class='hs-conid'>FixedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>121: </span>    <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##1454:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1459 : a | $k_##1458[VV##1457:=lq_tmp$x##1459]}) -&gt; lq_tmp$x##1455:(Data.ByteString.Builder.Prim.Internal.FixedPrim {lq_tmp$x##1462 : b | $k_##1461[VV##1460:=lq_tmp$x##1462]}) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim ({lq_tmp$x##1459 : a | $k_##1458[VV##1457:=lq_tmp$x##1459]}, {lq_tmp$x##1462 : b | $k_##1461[VV##1460:=lq_tmp$x##1462]}))</span><span class='hs-varid'>pair</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pairF</span>
<span class=hs-linenum>122: </span>
<span class=hs-linenum>123: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.Monoidal Data.ByteString.Builder.Prim.Internal.BoundedPrim)</span><span class='hs-conid'>Monoidal</span></a> <span class='hs-conid'>BoundedPrim</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>124: </span>    <a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3713:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3718 : a | $k_##3717[VV##3716:=lq_tmp$x##3718]}) -&gt; lq_tmp$x##3714:(Data.ByteString.Builder.Prim.Internal.BoundedPrim {lq_tmp$x##3721 : b | $k_##3720[VV##3719:=lq_tmp$x##3721]}) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim ({lq_tmp$x##3718 : a | $k_##3717[VV##3716:=lq_tmp$x##3718]}, {lq_tmp$x##3721 : b | $k_##3720[VV##3719:=lq_tmp$x##3721]}))</span><span class='hs-varid'>pair</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pairB</span>
<span class=hs-linenum>125: </span>
<span class=hs-linenum>126: </span><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span> <span class='hs-varop'>&gt;*&lt;</span>
<span class=hs-linenum>127: </span>
<span class=hs-linenum>128: </span><span class='hs-comment'>-- | A pairing/concatenation operator for builder primitives, both bounded and</span>
<span class=hs-linenum>129: </span><span class='hs-comment'>-- fixed size.</span>
<span class=hs-linenum>130: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>131: </span><span class='hs-comment'>-- For example,</span>
<span class=hs-linenum>132: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>133: </span><span class='hs-comment'>-- &gt; toLazyByteString (primFixed (char7 &gt;*&lt; char7) ('x','y')) = "xy"</span>
<span class=hs-linenum>134: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>135: </span><span class='hs-comment'>-- We can combine multiple primitives using '&gt;*&lt;' multiple times.</span>
<span class=hs-linenum>136: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>137: </span><span class='hs-comment'>-- &gt; toLazyByteString (primFixed (char7 &gt;*&lt; char7 &gt;*&lt; char7) ('x',('y','z'))) = "xyz"</span>
<span class=hs-linenum>138: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>139: </span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monoidal</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>140: </span><a class=annot href="#"><span class=annottext>forall f a b .
(Data.ByteString.Builder.Prim.Internal.Monoidal&lt;[]&gt; f) =&gt;
lq_tmp$x##926:f a -&gt; lq_tmp$x##927:f b -&gt; f (a, b)</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&gt;*&lt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pair</span>
<span class=hs-linenum>141: </span>
<span class=hs-linenum>142: </span>
<span class=hs-linenum>143: </span><span class='hs-comment'>-- | The type used for sizes and sizeBounds of sizes.</span>
<span class=hs-linenum>144: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Size</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>145: </span>
<span class=hs-linenum>146: </span>
<span class=hs-linenum>147: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>148: </span><span class='hs-comment'>-- Fixed-size builder primitives</span>
<span class=hs-linenum>149: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>150: </span>
<span class=hs-linenum>151: </span><span class='hs-comment'>-- | A builder primitive that always results in a sequence of bytes of a</span>
<span class=hs-linenum>152: </span><span class='hs-comment'>-- pre-determined, fixed size.</span>
<span class=hs-linenum>153: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<span class=hs-linenum>154: </span>
<span class=hs-linenum>155: </span><span class='hs-definition'>fixedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>156: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##964:GHC.Types.Int -&gt; lq_tmp$x##965:(lq_tmp$x##962:a -&gt; lq_tmp$x##963:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>fixedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span>
<span class=hs-linenum>157: </span>
<span class=hs-linenum>158: </span><span class='hs-comment'>-- | The size of the sequences of bytes generated by this 'FixedPrim'.</span>
<span class=hs-linenum>159: </span><span class='hs-comment'>{-# INLINE CONLIKE size #-}</span>
<span class=hs-linenum>160: </span><span class='hs-definition'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>161: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1003:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; GHC.Types.Int</span><span class='hs-definition'>size</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1042 : GHC.Types.Int | lq_tmp$x##1042 == l##a1KZ}</span><span class='hs-varid'>l</span></a>
<span class=hs-linenum>162: </span>
<span class=hs-linenum>163: </span><span class='hs-comment'>{-# INLINE CONLIKE runF #-}</span>
<span class=hs-linenum>164: </span><span class='hs-definition'>runF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>165: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1044:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; lq_tmp$x##1045:a -&gt; lq_tmp$x##1046:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-definition'>runF</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##1092:a -&gt; lq_tmp$x##1093:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>io</span></a>
<span class=hs-linenum>166: </span>
<span class=hs-linenum>167: </span><span class='hs-comment'>-- | The 'FixedPrim' that always results in the zero-length sequence.</span>
<span class=hs-linenum>168: </span><span class='hs-comment'>{-# INLINE CONLIKE emptyF #-}</span>
<span class=hs-linenum>169: </span><span class='hs-definition'>emptyF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>170: </span><a class=annot href="#"><span class=annottext>forall a . (Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>emptyF</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1104 : GHC.Types.Int | lq_tmp$x##1104 == (lq_anf$##7205759403792804718##d2Tk : int)}</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {lq_tmp$x##1131 : () | $k_##1130[VV##1129:=lq_tmp$x##1131][lq_tmp$x##14:=GHC.Tuple.$40$$41$]})</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1132 : () | lq_tmp$x##1132 == GHC.Tuple.()}</span><span class='hs-conid'>()</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>171: </span>
<span class=hs-linenum>172: </span><span class='hs-comment'>-- | Encode a pair by encoding its first component and then its second component.</span>
<span class=hs-linenum>173: </span><span class='hs-comment'>{-# INLINE CONLIKE pairF #-}</span>
<span class=hs-linenum>174: </span><span class='hs-definition'>pairF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>175: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##1167:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; lq_tmp$x##1168:(Data.ByteString.Builder.Prim.Internal.FixedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim (a, b))</span><span class='hs-definition'>pairF</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>176: </span>    <a class=annot href="#"><span class=annottext>ds_d2S8:{VV##1270 : ({VV##1263 : a | $k_##1264}, {VV##1265 : b | $k_##1266})&lt;\lq_tmp$x##1267 VV -&gt; {VV##1268 : b | $k_##1269}&gt; | $k_##1271} -&gt; op##a1L7:{VV##1275 : (GHC.Ptr.Ptr {VV##1273 : GHC.Word.Word8 | $k_##1274}) | $k_##1276} -&gt; {VV##1280 : (GHC.Types.IO {VV##1278 : () | $k_##1279}) | $k_##1281}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1257 : GHC.Types.Int | lq_tmp$x##1257 == l1##a1L1 + l2##a1L3}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##1260 : GHC.Types.Int | lq_tmp$x##1260 == l1##a1L1}</span><span class='hs-varid'>l1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1261 : GHC.Types.Int | lq_tmp$x##1261 == l2##a1L3}</span><span class='hs-varid'>l2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1286 : ({lq_tmp$x##1282 : a | $k_##1264[VV##1263:=lq_tmp$x##1282][VV##1270:=lq_tmp$x##1286]}, {lq_tmp$x##1283 : b | $k_##1266[VV##1265:=lq_tmp$x##1283][VV##1270:=lq_tmp$x##1286]})&lt;\lq_tmp$x##1287 VV -&gt; {lq_tmp$x##1285 : b | $k_##1269[VV##1268:=lq_tmp$x##1285][VV##1270:=lq_tmp$x##1286][lq_tmp$x##1267:=lq_tmp$x##1287][lq_tmp$x##1284:=lq_tmp$x##1287]}&gt; | lq_tmp$x##1286 == ds_d2S8
                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##1271[VV##1270:=lq_tmp$x##1286]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV##1275 : (GHC.Ptr.Ptr {VV##1273 : GHC.Word.Word8 | $k_##1274}) | $k_##1276}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1329 : a | lq_tmp$x##1329 == x1##a1L5
                      &amp;&amp; $k_##1264[VV##1263:=lq_tmp$x##1329][VV##1270:=lq_anf$##7205759403792804724##d2Tq][liquid_internal_this:=lq_anf$##7205759403792804724##d2Tq][lq_tmp$x##1282:=lq_tmp$x##1329][lq_tmp$x##1286:=lq_anf$##7205759403792804724##d2Tq][lq_tmp$x##1289:=lq_tmp$x##1329][lq_tmp$x##1293:=lq_anf$##7205759403792804724##d2Tq]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1331 : (GHC.Ptr.Ptr {lq_tmp$x##1330 : GHC.Word.Word8 | $k_##1274[VV##1273:=lq_tmp$x##1330][VV##1275:=lq_tmp$x##1331]}) | lq_tmp$x##1331 == op##a1L7
                                                                                                                                    &amp;&amp; $k_##1276[VV##1275:=lq_tmp$x##1331]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1361 : b | lq_tmp$x##1361 == x2##a1L6
                      &amp;&amp; $k_##1266[VV##1265:=lq_tmp$x##1361][VV##1270:=lq_anf$##7205759403792804724##d2Tq][liquid_internal_this:=lq_anf$##7205759403792804724##d2Tq][lq_tmp$x##1283:=lq_tmp$x##1361][lq_tmp$x##1286:=lq_anf$##7205759403792804724##d2Tq][lq_tmp$x##1290:=lq_tmp$x##1361][lq_tmp$x##1293:=lq_anf$##7205759403792804724##d2Tq][lq_tmp$x##1304:=x1##a1L5]
                      &amp;&amp; $k_##1269[VV##1268:=lq_tmp$x##1361][VV##1270:=lq_anf$##7205759403792804724##d2Tq][liquid_internal_this:=lq_anf$##7205759403792804724##d2Tq][lq_tmp$x##1267:=x1##a1L5][lq_tmp$x##1284:=x1##a1L5][lq_tmp$x##1285:=lq_tmp$x##1361][lq_tmp$x##1286:=lq_anf$##7205759403792804724##d2Tq][lq_tmp$x##1287:=x1##a1L5][lq_tmp$x##1290:=lq_tmp$x##1361][lq_tmp$x##1291:=x1##a1L5][lq_tmp$x##1292:=lq_tmp$x##1361][lq_tmp$x##1293:=lq_anf$##7205759403792804724##d2Tq][lq_tmp$x##1294:=x1##a1L5][lq_tmp$x##1304:=x1##a1L5]}</span><span class='hs-varid'>x2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1337 : (GHC.Ptr.Ptr {lq_tmp$x##1347 : GHC.Word.Word8 | $k_##1346[VV##1345:=lq_tmp$x##1347][lq_tmp$x##1340:=op##a1L7][lq_tmp$x##1341:=l1##a1L1]}) | pbase lq_tmp$x##1337 == pbase op##a1L7
                                                                                                                                                              &amp;&amp; plen lq_tmp$x##1337 == plen op##a1L7 - l1##a1L1
                                                                                                                                                              &amp;&amp; 0 &lt;= plen lq_tmp$x##1337}</span><span class='hs-layout'>(</span></a><span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp$x##1349 : (GHC.Ptr.Ptr {lq_tmp$x##1348 : GHC.Word.Word8 | $k_##1274[VV##1273:=lq_tmp$x##1348][VV##1275:=lq_tmp$x##1349]}) | lq_tmp$x##1349 == op##a1L7
                                                                                                                                    &amp;&amp; $k_##1276[VV##1275:=lq_tmp$x##1349]}</span><span class='hs-varid'>op</span></a></span> <span class='hs-varop'>`plusPtr`</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp$x##1350 : GHC.Types.Int | lq_tmp$x##1350 == l1##a1L1}</span><span class='hs-varid'>l1</span></a></span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>177: </span>
<span class=hs-linenum>178: </span><span class='hs-comment'>-- | Change a primitives such that it first applies a function to the value</span>
<span class=hs-linenum>179: </span><span class='hs-comment'>-- to be encoded.</span>
<span class=hs-linenum>180: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>181: </span><span class='hs-comment'>-- Note that primitives are 'Contravariant'</span>
<span class=hs-linenum>182: </span><span class='hs-comment'>-- &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a>&gt;. Hence, the following</span>
<span class=hs-linenum>183: </span><span class='hs-comment'>-- laws hold.</span>
<span class=hs-linenum>184: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>185: </span><span class='hs-comment'>-- &gt;contramapF id = id</span>
<span class=hs-linenum>186: </span><span class='hs-comment'>-- &gt;contramapF f . contramapF g = contramapF (g . f)</span>
<span class=hs-linenum>187: </span><span class='hs-comment'>{-# INLINE CONLIKE contramapF #-}</span>
<span class=hs-linenum>188: </span><span class='hs-definition'>contramapF</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>189: </span><a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##1505:(lq_tmp$x##1504:b -&gt; a) -&gt; lq_tmp$x##1506:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim b)</span><span class='hs-definition'>contramapF</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##1504:b -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##1623:GHC.Types.Int -&gt; lq_tmp$x##1624:(lq_tmp$x##1621:a -&gt; lq_tmp$x##1622:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; (Data.ByteString.Builder.Prim.Internal.FixedPrim a) | VV == Data.ByteString.Builder.Prim.Internal.$WFP}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1628 : GHC.Types.Int | lq_tmp$x##1628 == l##a1L9}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>xcmp:{lq_tmp$x##1566 : b | $k_##1565[VV##1564:=lq_tmp$x##1566][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8]} -&gt; lq_tmp$x##1567:{lq_tmp$x##1560 : (GHC.Ptr.Ptr {lq_tmp$x##1559 : GHC.Word.Word8 | $k_##1552[VV##1551:=lq_tmp$x##1559][VV##1553:=lq_tmp$x##1560][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8]
                                                                                                                                                                                                     &amp;&amp; $k_##1569[VV##1568:=lq_tmp$x##1559][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8][lq_tmp$x##1576:=xcmp]}) | $k_##1554[VV##1553:=lq_tmp$x##1560][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8]
                                                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##1571[VV##1570:=lq_tmp$x##1560][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8][lq_tmp$x##1576:=xcmp]} -&gt; {lq_tmp$x##1562 : (GHC.Types.IO {lq_tmp$x##1561 : () | $k_##1556[VV##1555:=lq_tmp$x##1561][VV##1557:=lq_tmp$x##1562][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8][lq_tmp$x##1550:=lq_tmp$x##1567]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                &amp;&amp; $k_##1573[VV##1572:=lq_tmp$x##1561][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8][lq_tmp$x##1576:=xcmp]}) | $k_##1558[VV##1557:=lq_tmp$x##1562][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8][lq_tmp$x##1550:=lq_tmp$x##1567]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  &amp;&amp; $k_##1575[VV##1574:=lq_tmp$x##1562][lq_tmp$db##13:=io##a1La][lq_tmp$db##15:=f##a1L8][lq_tmp$x##1576:=xcmp]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>lq_tmp$x##1602:a -&gt; lq_tmp$x##1603:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>io</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##1607:b -&gt; a</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-comment'>-- | Convert a 'FixedPrim' to a 'BoundedPrim'.</span>
<span class=hs-linenum>192: </span><span class='hs-comment'>{-# INLINE CONLIKE toB #-}</span>
<span class=hs-linenum>193: </span><span class='hs-definition'>toB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>194: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1692:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>toB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>FP</span> <span class='hs-varid'>l</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x##a1Ld:{VV##1731 : a | $k_##1732} -&gt; op##a1Le:{VV##1736 : (GHC.Ptr.Ptr {VV##1734 : GHC.Word.Word8 | $k_##1735}) | $k_##1737} -&gt; {VV##1743 : (GHC.Types.IO {VV##1741 : (GHC.Ptr.Ptr {VV##1739 : GHC.Word.Word8 | $k_##1740}) | $k_##1742}) | $k_##1744}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1890 : GHC.Types.Int | lq_tmp$x##1890 == l##a1Lb}</span><span class='hs-varid'>l</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1854 : (GHC.Base.Monad GHC.Types.IO) | lq_tmp$x##1854 == GHC.Base.$fMonadIO}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##1731 : a | $k_##1732}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##1736 : (GHC.Ptr.Ptr {VV##1734 : GHC.Word.Word8 | $k_##1735}) | $k_##1737}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>io</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1754 : a | lq_tmp$x##1754 == x##a1Ld
                      &amp;&amp; $k_##1732[VV##1731:=lq_tmp$x##1754]}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1756 : (GHC.Ptr.Ptr {lq_tmp$x##1755 : GHC.Word.Word8 | $k_##1735[VV##1734:=lq_tmp$x##1755][VV##1736:=lq_tmp$x##1756]}) | lq_tmp$x##1756 == op##a1Le
                                                                                                                                    &amp;&amp; $k_##1737[VV##1736:=lq_tmp$x##1756]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##1826 : (GHC.Types.IO {lq_tmp$x##1825 : (GHC.Ptr.Ptr {lq_tmp$x##1824 : GHC.Word.Word8 | $k_##1819[VV##1818:=lq_tmp$x##1824][VV##1820:=lq_tmp$x##1825][VV##1822:=lq_tmp$x##1826][lq_tmp$x##1804:=lq_anf$##7205759403792804733##d2Tz][lq_tmp$x##1805:=lq_anf$##7205759403792804734##d2TA]}) | $k_##1821[VV##1820:=lq_tmp$x##1825][VV##1822:=lq_tmp$x##1826][lq_tmp$x##1804:=lq_anf$##7205759403792804733##d2Tz][lq_tmp$x##1805:=lq_anf$##7205759403792804734##d2TA]}) | $k_##1823[VV##1822:=lq_tmp$x##1826][lq_tmp$x##1804:=lq_anf$##7205759403792804733##d2Tz][lq_tmp$x##1805:=lq_anf$##7205759403792804734##d2TA]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>forall a . lq_tmp$x##14:a -&gt; (GHC.Types.IO a)</span><span class='hs-varid'>return</span></a> <span class='hs-varop'>$!</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp$x##1793 : (GHC.Ptr.Ptr {lq_tmp$x##1792 : GHC.Word.Word8 | $k_##1735[VV##1734:=lq_tmp$x##1792][VV##1736:=lq_tmp$x##1793]}) | lq_tmp$x##1793 == op##a1Le
                                                                                                                                    &amp;&amp; $k_##1737[VV##1736:=lq_tmp$x##1793]}</span><span class='hs-varid'>op</span></a></span> <span class='hs-varop'>`plusPtr`</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{lq_tmp$x##1794 : GHC.Types.Int | lq_tmp$x##1794 == l##a1Lb}</span><span class='hs-varid'>l</span></a></span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>195: </span>
<span class=hs-linenum>196: </span><span class='hs-comment'>-- | Lift a 'FixedPrim' to a 'BoundedPrim'.</span>
<span class=hs-linenum>197: </span><span class='hs-comment'>{-# INLINE CONLIKE liftFixedToBounded #-}</span>
<span class=hs-linenum>198: </span><span class='hs-definition'>liftFixedToBounded</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>199: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##1902:(Data.ByteString.Builder.Prim.Internal.FixedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>liftFixedToBounded</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toB</span>
<span class=hs-linenum>200: </span>
<span class=hs-linenum>201: </span><span class='hs-comment'>{-# INLINE CONLIKE storableToF #-}</span>
<span class=hs-linenum>202: </span><span class='hs-comment'>{-# DEPRECATED storableToF
     "Deprecated since @bytestring-0.12.1.0@.\n\nThis function is dangerous in the presence of internal padding\nand makes naive assumptions about alignment.\n\n * For a primitive Haskell type like 'Int64', use the\n   corresponding primitive like 'Data.ByteString.Builder.Prim.int64Host'.\n * For other types, it is recommended to manually write a small\n   function that performs the necessary unaligned write\n   and zeroes or removes any internal padding bits."
  #-}</span>
<span class=hs-linenum>205: </span><span class='hs-definition'>storableToF</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-conid'>Storable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>FixedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>206: </span><span class='hs-cpp'>#if HS_UNALIGNED_POKES_OK</span>
<span class=hs-linenum>207: </span><span class='hs-definition'>storableToF</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FP</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizeOf</span> <span class='hs-layout'>(</span><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>op</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>poke</span> <span class='hs-layout'>(</span><span class='hs-varid'>castPtr</span> <span class='hs-varid'>op</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<span class=hs-linenum>208: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum>209: </span><a class=annot href="#"><span class=annottext>forall a .
(Foreign.Storable.Storable&lt;[]&gt; a) =&gt;
(Data.ByteString.Builder.Prim.Internal.FixedPrim a)</span><span class='hs-definition'>storableToF</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##2950:{lq_tmp$x##2943 : a | $k_##2867[VV##2866:=lq_tmp$x##2943]} -&gt; lq_tmp$x##2951:{lq_tmp$x##2945 : (GHC.Ptr.Ptr {lq_tmp$x##2944 : GHC.Word.Word8 | $k_##2870[VV##2869:=lq_tmp$x##2944][VV##2871:=lq_tmp$x##2945][lq_tmp$x##2865:=lq_tmp$x##2950]}) | $k_##2872[VV##2871:=lq_tmp$x##2945][lq_tmp$x##2865:=lq_tmp$x##2950]} -&gt; {lq_tmp$x##2947 : (GHC.Types.IO {lq_tmp$x##2946 : () | $k_##2874[VV##2873:=lq_tmp$x##2946][VV##2875:=lq_tmp$x##2947][lq_tmp$x##2865:=lq_tmp$x##2950][lq_tmp$x##2868:=lq_tmp$x##2951]}) | $k_##2876[VV##2875:=lq_tmp$x##2947][lq_tmp$x##2865:=lq_tmp$x##2950][lq_tmp$x##2868:=lq_tmp$x##2951]}</span><span class='hs-conid'>FP</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sizeOf</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2901 : a | $k_##2900[VV##2899:=lq_tmp$x##2901][lq_tmp$x##2891:=fix$36$$36$dIP_a1Uh]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##2566 : a | $k_##2567}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##2571 : (GHC.Ptr.Ptr {VV##2569 : GHC.Word.Word8 | $k_##2570}) | $k_##2572}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>210: </span>    <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>Foreign.Ptr.WordPtr</span><span class='hs-varid'>ptrToWordPtr</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2587 : (GHC.Ptr.Ptr {lq_tmp$x##2586 : GHC.Word.Word8 | $k_##2570[VV##2569:=lq_tmp$x##2586][VV##2571:=lq_tmp$x##2587]}) | lq_tmp$x##2587 == op##a1Lg
                                                                                                                                    &amp;&amp; $k_##2572[VV##2571:=lq_tmp$x##2587]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>`mod`</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2643 : Foreign.Ptr.WordPtr | lq_tmp$x##2643 == lq_anf$##7205759403792804807##d2UL}</span><span class='hs-varid'>fromIntegral</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>alignment</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2608 : a | $k_##2607[VV##2606:=lq_tmp$x##2608][lq_tmp$x##2598:=fix$36$$36$dIP_a1UB]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2677 : Foreign.Ptr.WordPtr | lq_tmp$x##2677 == lq_anf$##7205759403792804810##d2UO}</span><span class='hs-num'>0</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2860 : (Foreign.Storable.Storable a) | lq_tmp$x##2860 == $dStorable_a1U0}</span><span class='hs-varid'>poke</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2833 : (GHC.Ptr.Ptr {lq_tmp$x##2841 : a | $k_##2840[VV##2839:=lq_tmp$x##2841][lq_tmp$x##2835:=op##a1Lg]}) | plen lq_tmp$x##2833 == plen op##a1Lg
                                                                                                                       &amp;&amp; 0 &lt;= plen lq_tmp$x##2833}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>castPtr</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2843 : (GHC.Ptr.Ptr {lq_tmp$x##2842 : GHC.Word.Word8 | $k_##2570[VV##2569:=lq_tmp$x##2842][VV##2571:=lq_tmp$x##2843]}) | lq_tmp$x##2843 == op##a1Lg
                                                                                                                                    &amp;&amp; $k_##2572[VV##2571:=lq_tmp$x##2843]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2863 : a | lq_tmp$x##2863 == x##a1Lf
                      &amp;&amp; $k_##2567[VV##2566:=lq_tmp$x##2863]}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>211: </span>    <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##2811:(lq_tmp$x##2808:(GHC.Ptr.Ptr a) -&gt; (GHC.Types.IO {lq_tmp$x##2815 : () | $k_##2814[VV##2813:=lq_tmp$x##2815][lq_tmp$x##2809:=fix$36$$36$dStorable_a1U0][lq_tmp$x##2810:=x##a1Lf]})) -&gt; (GHC.Types.IO {lq_tmp$x##2815 : () | $k_##2814[VV##2813:=lq_tmp$x##2815][lq_tmp$x##2809:=fix$36$$36$dStorable_a1U0][lq_tmp$x##2810:=x##a1Lf]})</span><span class='hs-varid'>with</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2818 : a | lq_tmp$x##2818 == x##a1Lf
                      &amp;&amp; $k_##2567[VV##2566:=lq_tmp$x##2818]}</span><span class='hs-varid'>x</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##2783:(GHC.Ptr.Ptr a) -&gt; lq_tmp$x##2784:(GHC.Ptr.Ptr a) -&gt; lq_tmp$x##2785:GHC.Types.Int -&gt; (GHC.Types.IO ()) | VV == Foreign.Marshal.Utils.copyBytes}</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV##2710 : (GHC.Ptr.Ptr {VV##2708 : a | $k_##2709}) | $k_##2711}</span><span class='hs-varid'>tp</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>copyBytes</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2790 : (GHC.Ptr.Ptr {lq_tmp$x##2789 : GHC.Word.Word8 | $k_##2570[VV##2569:=lq_tmp$x##2789][VV##2571:=lq_tmp$x##2790]}) | lq_tmp$x##2790 == op##a1Lg
                                                                                                                                    &amp;&amp; $k_##2572[VV##2571:=lq_tmp$x##2790]}</span><span class='hs-varid'>op</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2720 : (GHC.Ptr.Ptr {lq_tmp$x##2728 : GHC.Word.Word8 | $k_##2727[VV##2726:=lq_tmp$x##2728][lq_tmp$x##2722:=tp##a1Lh]}) | plen lq_tmp$x##2720 == plen tp##a1Lh
                                                                                                                                    &amp;&amp; 0 &lt;= plen lq_tmp$x##2720}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>castPtr</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2730 : (GHC.Ptr.Ptr {lq_tmp$x##2729 : a | $k_##2709[VV##2708:=lq_tmp$x##2729][VV##2710:=lq_tmp$x##2730]}) | lq_tmp$x##2730 == tp##a1Lh
                                                                                                                       &amp;&amp; $k_##2711[VV##2710:=lq_tmp$x##2730]}</span><span class='hs-varid'>tp</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>sizeOf</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##2751 : a | $k_##2750[VV##2749:=lq_tmp$x##2751][lq_tmp$x##2741:=fix$36$$36$dIP_a1V1]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>212: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum>213: </span>
<span class=hs-linenum>214: </span><span class='hs-comment'>{-
{-# INLINE CONLIKE liftIOF #-}
liftIOF :: FixedPrim a -&gt; FixedPrim (IO a)
liftIOF (FP l io) = FP l (\xWrapped op -&gt; do x &lt;- xWrapped; io x op)
-}</span>
<span class=hs-linenum>219: </span>
<span class=hs-linenum>220: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>221: </span><span class='hs-comment'>-- Bounded-size builder primitives</span>
<span class=hs-linenum>222: </span><span class='hs-comment'>------------------------------------------------------------------------------</span>
<span class=hs-linenum>223: </span>
<span class=hs-linenum>224: </span><span class='hs-comment'>-- | A builder primitive that always results in sequence of bytes that is no longer</span>
<span class=hs-linenum>225: </span><span class='hs-comment'>-- than a pre-determined bound.</span>
<span class=hs-linenum>226: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>227: </span>
<span class=hs-linenum>228: </span><span class='hs-comment'>-- | The bound on the size of sequences of bytes generated by this 'BoundedPrim'.</span>
<span class=hs-linenum>229: </span><span class='hs-comment'>{-# INLINE CONLIKE sizeBound #-}</span>
<span class=hs-linenum>230: </span><span class='hs-definition'>sizeBound</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>231: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##2962:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; GHC.Types.Int</span><span class='hs-definition'>sizeBound</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3003 : GHC.Types.Int | lq_tmp$x##3003 == b##a1Li}</span><span class='hs-varid'>b</span></a>
<span class=hs-linenum>232: </span>
<span class=hs-linenum>233: </span><span class='hs-comment'>-- | @since 0.10.12.0</span>
<span class=hs-linenum>234: </span><span class='hs-definition'>boundedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>235: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##3007:GHC.Types.Int -&gt; lq_tmp$x##3008:(lq_tmp$x##3005:a -&gt; lq_tmp$x##3006:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>boundedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span>
<span class=hs-linenum>236: </span>
<span class=hs-linenum>237: </span><span class='hs-comment'>{-# DEPRECATED boudedPrim "Use 'boundedPrim' instead" #-}</span>
<span class=hs-linenum>238: </span><span class='hs-definition'>boudedPrim</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>239: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##3050:GHC.Types.Int -&gt; lq_tmp$x##3051:(lq_tmp$x##3048:a -&gt; lq_tmp$x##3049:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>boudedPrim</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span>
<span class=hs-linenum>240: </span>
<span class=hs-linenum>241: </span><span class='hs-comment'>{-# INLINE CONLIKE runB #-}</span>
<span class=hs-linenum>242: </span><span class='hs-definition'>runB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ptr</span> <span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum>243: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##3091:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3092:a -&gt; lq_tmp$x##3093:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-definition'>runB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3142:a -&gt; lq_tmp$x##3143:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-varid'>io</span></a>
<span class=hs-linenum>244: </span>
<span class=hs-linenum>245: </span><span class='hs-comment'>-- | Change a 'BoundedPrim' such that it first applies a function to the</span>
<span class=hs-linenum>246: </span><span class='hs-comment'>-- value to be encoded.</span>
<span class=hs-linenum>247: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>248: </span><span class='hs-comment'>-- Note that 'BoundedPrim's are 'Contravariant'</span>
<span class=hs-linenum>249: </span><span class='hs-comment'>-- &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a>&gt;. Hence, the following</span>
<span class=hs-linenum>250: </span><span class='hs-comment'>-- laws hold.</span>
<span class=hs-linenum>251: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>252: </span><span class='hs-comment'>-- &gt;contramapB id = id</span>
<span class=hs-linenum>253: </span><span class='hs-comment'>-- &gt;contramapB f . contramapB g = contramapB (g . f)</span>
<span class=hs-linenum>254: </span><span class='hs-comment'>{-# INLINE CONLIKE contramapB #-}</span>
<span class=hs-linenum>255: </span><span class='hs-definition'>contramapB</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span>
<span class=hs-linenum>256: </span><a class=annot href="#"><span class=annottext>forall b a .
lq_tmp$x##3148:(lq_tmp$x##3147:b -&gt; a) -&gt; lq_tmp$x##3149:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim b)</span><span class='hs-definition'>contramapB</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3147:b -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b</span> <span class='hs-varid'>io</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##3277:GHC.Types.Int -&gt; lq_tmp$x##3278:(lq_tmp$x##3275:a -&gt; lq_tmp$x##3276:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | VV == Data.ByteString.Builder.Prim.Internal.$WBP}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3282 : GHC.Types.Int | lq_tmp$x##3282 == b##a1Ll}</span><span class='hs-varid'>b</span></a> <a class=annot href="#"><span class=annottext>xcmp:{lq_tmp$x##3214 : b | $k_##3213[VV##3212:=lq_tmp$x##3214][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk]} -&gt; lq_tmp$x##3215:{lq_tmp$x##3207 : (GHC.Ptr.Ptr {lq_tmp$x##3206 : GHC.Word.Word8 | $k_##3197[VV##3196:=lq_tmp$x##3206][VV##3198:=lq_tmp$x##3207][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk]
                                                                                                                                                                                                     &amp;&amp; $k_##3217[VV##3216:=lq_tmp$x##3206][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk][lq_tmp$x##3226:=xcmp]}) | $k_##3199[VV##3198:=lq_tmp$x##3207][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk]
                                                                                                                                                                                                                                                                                                                       &amp;&amp; $k_##3219[VV##3218:=lq_tmp$x##3207][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk][lq_tmp$x##3226:=xcmp]} -&gt; {lq_tmp$x##3210 : (GHC.Types.IO {lq_tmp$x##3209 : (GHC.Ptr.Ptr {lq_tmp$x##3208 : GHC.Word.Word8 | $k_##3201[VV##3200:=lq_tmp$x##3208][VV##3202:=lq_tmp$x##3209][VV##3204:=lq_tmp$x##3210][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk][lq_tmp$x##3195:=lq_tmp$x##3215]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &amp;&amp; $k_##3221[VV##3220:=lq_tmp$x##3208][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk][lq_tmp$x##3226:=xcmp]}) | $k_##3203[VV##3202:=lq_tmp$x##3209][VV##3204:=lq_tmp$x##3210][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk][lq_tmp$x##3195:=lq_tmp$x##3215]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##3223[VV##3222:=lq_tmp$x##3209][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk][lq_tmp$x##3226:=xcmp]}) | $k_##3205[VV##3204:=lq_tmp$x##3210][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk][lq_tmp$x##3195:=lq_tmp$x##3215]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &amp;&amp; $k_##3225[VV##3224:=lq_tmp$x##3210][lq_tmp$db##13:=io##a1Lm][lq_tmp$db##15:=f##a1Lk][lq_tmp$x##3226:=xcmp]}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>lq_tmp$x##3255:a -&gt; lq_tmp$x##3256:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-varid'>io</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3260:b -&gt; a</span><span class='hs-varid'>f</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>257: </span>
<span class=hs-linenum>258: </span><span class='hs-comment'>-- | The 'BoundedPrim' that always results in the zero-length sequence.</span>
<span class=hs-linenum>259: </span><span class='hs-comment'>{-# INLINE CONLIKE emptyB #-}</span>
<span class=hs-linenum>260: </span><span class='hs-definition'>emptyB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>261: </span><a class=annot href="#"><span class=annottext>forall a . (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>emptyB</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3354 : GHC.Types.Int | lq_tmp$x##3354 == (lq_anf$##7205759403792804824##d2V2 : int)}</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>(GHC.Types.IO {lq_tmp$x##3384 : (GHC.Ptr.Ptr {lq_tmp$x##3383 : GHC.Word.Word8 | $k_##3380[VV##3379:=lq_tmp$x##3383][VV##3381:=lq_tmp$x##3384][lq_tmp$x##14:=op##a1Ln]}) | $k_##3382[VV##3381:=lq_tmp$x##3384][lq_tmp$x##14:=op##a1Ln]})</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{VV##3364 : (GHC.Ptr.Ptr {VV##3362 : GHC.Word.Word8 | $k_##3363}) | $k_##3365}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3386 : (GHC.Ptr.Ptr {lq_tmp$x##3385 : GHC.Word.Word8 | $k_##3363[VV##3362:=lq_tmp$x##3385][VV##3364:=lq_tmp$x##3386]}) | lq_tmp$x##3386 == op##a1Ln
                                                                                                                                    &amp;&amp; $k_##3365[VV##3364:=lq_tmp$x##3386]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>262: </span>
<span class=hs-linenum>263: </span><span class='hs-comment'>-- | Encode a pair by encoding its first component and then its second component.</span>
<span class=hs-linenum>264: </span><span class='hs-comment'>{-# INLINE CONLIKE pairB #-}</span>
<span class=hs-linenum>265: </span><span class='hs-definition'>pairB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>266: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3423:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3424:(Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (a, b))</span><span class='hs-definition'>pairB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>267: </span>    <a class=annot href="#"><span class=annottext>ds_d2QQ:{VV##3530 : ({VV##3523 : a | $k_##3524}, {VV##3525 : b | $k_##3526})&lt;\lq_tmp$x##3527 VV -&gt; {VV##3528 : b | $k_##3529}&gt; | $k_##3531} -&gt; op##a1Lu:{VV##3535 : (GHC.Ptr.Ptr {VV##3533 : GHC.Word.Word8 | $k_##3534}) | $k_##3536} -&gt; {VV##3542 : (GHC.Types.IO {VV##3540 : (GHC.Ptr.Ptr {VV##3538 : GHC.Word.Word8 | $k_##3539}) | $k_##3541}) | $k_##3543}</span><span class='hs-conid'>BP</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3517 : GHC.Types.Int | lq_tmp$x##3517 == b1##a1Lo + b2##a1Lq}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{lq_tmp$x##3520 : GHC.Types.Int | lq_tmp$x##3520 == b1##a1Lo}</span><span class='hs-varid'>b1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3521 : GHC.Types.Int | lq_tmp$x##3521 == b2##a1Lq}</span><span class='hs-varid'>b2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3548 : ({lq_tmp$x##3544 : a | $k_##3524[VV##3523:=lq_tmp$x##3544][VV##3530:=lq_tmp$x##3548]}, {lq_tmp$x##3545 : b | $k_##3526[VV##3525:=lq_tmp$x##3545][VV##3530:=lq_tmp$x##3548]})&lt;\lq_tmp$x##3549 VV -&gt; {lq_tmp$x##3547 : b | $k_##3529[VV##3528:=lq_tmp$x##3547][VV##3530:=lq_tmp$x##3548][lq_tmp$x##3527:=lq_tmp$x##3549][lq_tmp$x##3546:=lq_tmp$x##3549]}&gt; | lq_tmp$x##3548 == ds_d2QQ
                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; $k_##3531[VV##3530:=lq_tmp$x##3548]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{VV##3535 : (GHC.Ptr.Ptr {VV##3533 : GHC.Word.Word8 | $k_##3534}) | $k_##3536}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3592 : a | lq_tmp$x##3592 == x1##a1Ls
                      &amp;&amp; $k_##3524[VV##3523:=lq_tmp$x##3592][VV##3530:=lq_anf$##7205759403792804830##d2V8][liquid_internal_this:=lq_anf$##7205759403792804830##d2V8][lq_tmp$x##3544:=lq_tmp$x##3592][lq_tmp$x##3548:=lq_anf$##7205759403792804830##d2V8][lq_tmp$x##3551:=lq_tmp$x##3592][lq_tmp$x##3555:=lq_anf$##7205759403792804830##d2V8]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3594 : (GHC.Ptr.Ptr {lq_tmp$x##3593 : GHC.Word.Word8 | $k_##3534[VV##3533:=lq_tmp$x##3593][VV##3535:=lq_tmp$x##3594]}) | lq_tmp$x##3594 == op##a1Lu
                                                                                                                                    &amp;&amp; $k_##3536[VV##3535:=lq_tmp$x##3594]}</span><span class='hs-varid'>op</span></a> <span class='hs-varop'>&gt;&gt;=</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3605:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3606 : b | lq_tmp$x##3606 == x2##a1Lt
                      &amp;&amp; $k_##3526[VV##3525:=lq_tmp$x##3606][VV##3530:=lq_anf$##7205759403792804830##d2V8][liquid_internal_this:=lq_anf$##7205759403792804830##d2V8][lq_tmp$x##3545:=lq_tmp$x##3606][lq_tmp$x##3548:=lq_anf$##7205759403792804830##d2V8][lq_tmp$x##3552:=lq_tmp$x##3606][lq_tmp$x##3555:=lq_anf$##7205759403792804830##d2V8][lq_tmp$x##3566:=x1##a1Ls]
                      &amp;&amp; $k_##3529[VV##3528:=lq_tmp$x##3606][VV##3530:=lq_anf$##7205759403792804830##d2V8][liquid_internal_this:=lq_anf$##7205759403792804830##d2V8][lq_tmp$x##3527:=x1##a1Ls][lq_tmp$x##3546:=x1##a1Ls][lq_tmp$x##3547:=lq_tmp$x##3606][lq_tmp$x##3548:=lq_anf$##7205759403792804830##d2V8][lq_tmp$x##3549:=x1##a1Ls][lq_tmp$x##3552:=lq_tmp$x##3606][lq_tmp$x##3553:=x1##a1Ls][lq_tmp$x##3554:=lq_tmp$x##3606][lq_tmp$x##3555:=lq_anf$##7205759403792804830##d2V8][lq_tmp$x##3556:=x1##a1Ls][lq_tmp$x##3566:=x1##a1Ls]}</span><span class='hs-varid'>x2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>268: </span>
<span class=hs-linenum>269: </span><span class='hs-comment'>-- | Encode an 'Either' value using the first 'BoundedPrim' for 'Left'</span>
<span class=hs-linenum>270: </span><span class='hs-comment'>-- values and the second 'BoundedPrim' for 'Right' values.</span>
<span class=hs-linenum>271: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>272: </span><span class='hs-comment'>-- Note that the functions 'eitherB', 'pairB', and 'contramapB' (written below</span>
<span class=hs-linenum>273: </span><span class='hs-comment'>-- using '&gt;$&lt;') suffice to construct 'BoundedPrim's for all non-recursive</span>
<span class=hs-linenum>274: </span><span class='hs-comment'>-- algebraic datatypes. For example,</span>
<span class=hs-linenum>275: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>276: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>277: </span><span class='hs-comment'>--maybeB :: BoundedPrim () -&gt; BoundedPrim a -&gt; BoundedPrim (Maybe a)</span>
<span class=hs-linenum>278: </span><span class='hs-comment'>--maybeB nothing just = 'maybe' (Left ()) Right '&gt;$&lt;' eitherB nothing just</span>
<span class=hs-linenum>279: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>280: </span><span class='hs-comment'>{-# INLINE CONLIKE eitherB #-}</span>
<span class=hs-linenum>281: </span><span class='hs-definition'>eitherB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<span class=hs-linenum>282: </span><a class=annot href="#"><span class=annottext>forall a b .
lq_tmp$x##3763:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3764:(Data.ByteString.Builder.Prim.Internal.BoundedPrim b) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim (Data.Either.Either a b))</span><span class='hs-definition'>eitherB</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>io1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>BP</span> <span class='hs-varid'>b2</span> <span class='hs-varid'>io2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>283: </span>    <span class='hs-conid'>BP</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3858 : GHC.Types.Int | lq_tmp$x##3858 == (if b1##a1Lv &gt; b2##a1Lx then b1##a1Lv else b2##a1Lx)
                                  &amp;&amp; $k_##3857[VV##3856:=lq_tmp$x##3858][lq_tmp$x##3853:=GHC.Classes.$fOrdInt][lq_tmp$x##3854:=b1##a1Lv][lq_tmp$x##3855:=b2##a1Lx]}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>max</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3861 : GHC.Types.Int | lq_tmp$x##3861 == b1##a1Lv}</span><span class='hs-varid'>b1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3862 : GHC.Types.Int | lq_tmp$x##3862 == b2##a1Lx}</span><span class='hs-varid'>b2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>284: </span>        <a class=annot href="#"><span class=annottext>{lq_tmp$x##3884 : (Data.Either.Either {lq_tmp$x##3882 : a | $k_##3865[VV##3864:=lq_tmp$x##3882][VV##3868:=lq_tmp$x##3884]} {lq_tmp$x##3883 : b | $k_##3867[VV##3866:=lq_tmp$x##3883][VV##3868:=lq_tmp$x##3884]}) | lq_tmp$x##3884 == x##a1Lz
                                                                                                                                                                                                                   &amp;&amp; $k_##3869[VV##3868:=lq_tmp$x##3884]}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##3868 : (Data.Either.Either {VV##3864 : a | $k_##3865} {VV##3866 : b | $k_##3867}) | $k_##3869}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV##3873 : (GHC.Ptr.Ptr {VV##3871 : GHC.Word.Word8 | $k_##3872}) | $k_##3874}</span><span class='hs-varid'>op</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3884 : (Data.Either.Either {lq_tmp$x##3882 : a | $k_##3865[VV##3864:=lq_tmp$x##3882][VV##3868:=lq_tmp$x##3884]} {lq_tmp$x##3883 : b | $k_##3867[VV##3866:=lq_tmp$x##3883][VV##3868:=lq_tmp$x##3884]}) | lq_tmp$x##3884 == x##a1Lz
                                                                                                                                                                                                                   &amp;&amp; $k_##3869[VV##3868:=lq_tmp$x##3884]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>of</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3911:a -&gt; lq_tmp$x##3912:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-varid'>io1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3913 : a | lq_tmp$x##3913 == x1##a1LB
                      &amp;&amp; $k_##3865[VV##3864:=lq_tmp$x##3913][VV##3868:=lq_anf$##7205759403792804837##d2Vf][liquid_internal_this:=lq_anf$##7205759403792804837##d2Vf][lq_tmp$x##3882:=lq_tmp$x##3913][lq_tmp$x##3884:=lq_anf$##7205759403792804837##d2Vf][lq_tmp$x##3886:=lq_tmp$x##3913][lq_tmp$x##3888:=lq_anf$##7205759403792804837##d2Vf]}</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3915 : (GHC.Ptr.Ptr {lq_tmp$x##3914 : GHC.Word.Word8 | $k_##3872[VV##3871:=lq_tmp$x##3914][VV##3873:=lq_tmp$x##3915]}) | lq_tmp$x##3915 == op##a1LA
                                                                                                                                    &amp;&amp; $k_##3874[VV##3873:=lq_tmp$x##3915]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>;</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>lq_tmp$x##3941:b -&gt; lq_tmp$x##3942:(GHC.Ptr.Ptr GHC.Word.Word8) -&gt; (GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8))</span><span class='hs-varid'>io2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3943 : b | lq_tmp$x##3943 == x2##a1LC
                      &amp;&amp; $k_##3867[VV##3866:=lq_tmp$x##3943][VV##3868:=lq_anf$##7205759403792804837##d2Vf][liquid_internal_this:=lq_anf$##7205759403792804837##d2Vf][lq_tmp$x##3883:=lq_tmp$x##3943][lq_tmp$x##3884:=lq_anf$##7205759403792804837##d2Vf][lq_tmp$x##3917:=lq_tmp$x##3943][lq_tmp$x##3918:=lq_anf$##7205759403792804837##d2Vf]}</span><span class='hs-varid'>x2</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##3945 : (GHC.Ptr.Ptr {lq_tmp$x##3944 : GHC.Word.Word8 | $k_##3872[VV##3871:=lq_tmp$x##3944][VV##3873:=lq_tmp$x##3945]}) | lq_tmp$x##3945 == op##a1LA
                                                                                                                                    &amp;&amp; $k_##3874[VV##3873:=lq_tmp$x##3945]}</span><span class='hs-varid'>op</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>285: </span>
<span class=hs-linenum>286: </span><span class='hs-comment'>-- | Conditionally select a 'BoundedPrim'.</span>
<span class=hs-linenum>287: </span><span class='hs-comment'>-- For example, we can implement the ASCII primitive that drops characters with</span>
<span class=hs-linenum>288: </span><span class='hs-comment'>-- Unicode codepoints above 127 as follows.</span>
<span class=hs-linenum>289: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>290: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>291: </span><span class='hs-comment'>--charASCIIDrop = 'condB' (&lt; \'\\128\') ('liftFixedToBounded' 'Data.ByteString.Builder.Prim.char7') 'emptyB'</span>
<span class=hs-linenum>292: </span><span class='hs-comment'>-- @</span>
<span class=hs-linenum>293: </span><span class='hs-comment'>{-# INLINE CONLIKE condB #-}</span>
<span class=hs-linenum>294: </span><span class='hs-definition'>condB</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BoundedPrim</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>295: </span><a class=annot href="#"><span class=annottext>forall a .
lq_tmp$x##3989:(lq_tmp$x##3988:a -&gt; GHC.Types.Bool) -&gt; lq_tmp$x##3990:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; lq_tmp$x##3991:(Data.ByteString.Builder.Prim.Internal.BoundedPrim a) -&gt; (Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-definition'>condB</span></a> <a class=annot href="#"><span class=annottext>lq_tmp$x##3988:a -&gt; GHC.Types.Bool</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>be1</span></a> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim a)</span><span class='hs-varid'>be2</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>296: </span>    <span class='hs-varid'>contramapB</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4010 : GHC.Types.Bool | lq_tmp$x##4010 == lq_anf$##7205759403792804839##d2Vh}</span><span class='hs-layout'>(</span></a><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV##3995 : a | $k_##3996}</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4008 : a | lq_tmp$x##4008 == x##a1LG
                      &amp;&amp; $k_##3996[VV##3995:=lq_tmp$x##4008]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      lq_tmp$x##4040:a -&gt; {lq_tmp$x##4038 : (Data.Either.Either a b) | isLeft lq_tmp$x##4038} | VV == Data.Either.Left}</span><span class='hs-conid'>Left</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4047 : a | lq_tmp$x##4047 == x##a1LG
                      &amp;&amp; $k_##3996[VV##3995:=lq_tmp$x##4047]}</span><span class='hs-varid'>x</span></a> <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      lq_tmp$x##4022:b -&gt; {lq_tmp$x##4020 : (Data.Either.Either a b) | not (isLeft lq_tmp$x##4020)} | VV == Data.Either.Right}</span><span class='hs-conid'>Right</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4029 : a | lq_tmp$x##4029 == x##a1LG
                      &amp;&amp; $k_##3996[VV##3995:=lq_tmp$x##4029]}</span><span class='hs-varid'>x</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Builder.Prim.Internal.BoundedPrim (Data.Either.Either {lq_tmp$x##4063 : a | $k_##4062[VV##4061:=lq_tmp$x##4063][lq_tmp$x##4059:=be1##a1LE][lq_tmp$x##4060:=be2##a1LF]} {lq_tmp$x##4066 : a | $k_##4065[VV##4064:=lq_tmp$x##4066][lq_tmp$x##4059:=be1##a1LE][lq_tmp$x##4060:=be2##a1LF]}))</span><span class='hs-layout'>(</span></a><span class='hs-varid'>eitherB</span> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4068 : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | lq_tmp$x##4068 == be1##a1LE}</span><span class='hs-varid'>be1</span></a> <a class=annot href="#"><span class=annottext>{lq_tmp$x##4070 : (Data.ByteString.Builder.Prim.Internal.BoundedPrim a) | lq_tmp$x##4070 == be2##a1LF}</span><span class='hs-varid'>be2</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>297: </span>
<span class=hs-linenum>298: </span><span class='hs-comment'>-- | Select an implementation depending on bitness.</span>
<span class=hs-linenum>299: </span><span class='hs-comment'>-- Throw a compile time error if bitness is neither 32 nor 64.</span>
<span class=hs-linenum>300: </span><span class='hs-comment'>{-# INLINE caseWordSize_32_64 #-}</span>
<span class=hs-linenum>301: </span><span class='hs-definition'>caseWordSize_32_64</span>
<span class=hs-linenum>302: </span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-comment'>-- Value for 32-bit architecture</span>
<span class=hs-linenum>303: </span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-comment'>-- Value for 64-bit architecture</span>
<span class=hs-linenum>304: </span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>305: </span><span class='hs-cpp'>#if WORD_SIZE_IN_BITS == 32</span>
<span class=hs-linenum>306: </span><span class='hs-definition'>caseWordSize_32_64</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>const</span>
<span class=hs-linenum>307: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum>308: </span><span class='hs-cpp'>#if WORD_SIZE_IN_BITS == 64</span>
<span class=hs-linenum>309: </span><a class=annot href="#"><span class=annottext>forall a . lq_tmp$x##4111:a -&gt; lq_tmp$x##4112:a -&gt; a</span><span class='hs-definition'>caseWordSize_32_64</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>const</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      lq_tmp$x##4124:a -&gt; {lq_tmp$x##4122 : a | lq_tmp$x##4122 == lq_tmp$x##4124} | VV == GHC.Base.id}</span><span class='hs-varid'>id</span></a>
<span class=hs-linenum>310: </span><span class='hs-cpp'>#endif</span>
</pre>
</body>
</html>