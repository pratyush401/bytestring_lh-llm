<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>./Data/ByteString/Lazy/Internal.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>  1: </span><a class=annot href="#"><span class=annottext>{VV : GHC.Types.Module | false}</span><span class='hs-comment'>{-# LANGUAGE CPP #-}</span></a>
<span class=hs-linenum>  2: </span><span class='hs-comment'>{-# LANGUAGE BangPatterns #-}</span>
<span class=hs-linenum>  3: </span><span class='hs-comment'>{-# LANGUAGE DeriveLift #-}</span>
<span class=hs-linenum>  4: </span><span class='hs-comment'>{-# LANGUAGE StandaloneDeriving #-}</span>
<span class=hs-linenum>  5: </span><span class='hs-comment'>{-# LANGUAGE TypeFamilies #-}</span>
<span class=hs-linenum>  6: </span><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<span class=hs-linenum>  7: </span>
<span class=hs-linenum>  8: </span><span class='hs-cpp'>#ifdef HS_BYTESTRING_ASSERTIONS</span>
<span class=hs-linenum>  9: </span><span class='hs-comment'>{-# LANGUAGE PatternSynonyms #-}</span>
<span class=hs-linenum> 10: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 11: </span>
<span class=hs-linenum> 12: </span><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<span class=hs-linenum> 13: </span>
<span class=hs-linenum> 14: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 15: </span>
<span class=hs-linenum> 16: </span><span class='hs-comment'>-- |</span>
<span class=hs-linenum> 17: </span><span class='hs-comment'>-- Module      : Data.ByteString.Lazy.Internal</span>
<span class=hs-linenum> 18: </span><span class='hs-comment'>-- Copyright   : (c) Don Stewart 2006-2008</span>
<span class=hs-linenum> 19: </span><span class='hs-comment'>--               (c) Duncan Coutts 2006-2011</span>
<span class=hs-linenum> 20: </span><span class='hs-comment'>-- License     : BSD-style</span>
<span class=hs-linenum> 21: </span><span class='hs-comment'>-- Maintainer  : dons00@gmail.com, duncan@community.haskell.org</span>
<span class=hs-linenum> 22: </span><span class='hs-comment'>-- Stability   : unstable</span>
<span class=hs-linenum> 23: </span><span class='hs-comment'>-- Portability : non-portable</span>
<span class=hs-linenum> 24: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 25: </span><span class='hs-comment'>-- A module containing semi-public 'ByteString' internals. This exposes</span>
<span class=hs-linenum> 26: </span><span class='hs-comment'>-- the 'ByteString' representation and low level construction functions.</span>
<span class=hs-linenum> 27: </span><span class='hs-comment'>-- Modules which extend the 'ByteString' system will need to use this module</span>
<span class=hs-linenum> 28: </span><span class='hs-comment'>-- while ideally most users will be able to make do with the public interface</span>
<span class=hs-linenum> 29: </span><span class='hs-comment'>-- modules.</span>
<span class=hs-linenum> 30: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 31: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Data.ByteString.Lazy.Internal</span> <span class='hs-layout'>(</span>
<span class=hs-linenum> 32: </span>
<span class=hs-linenum> 33: </span>        <span class='hs-comment'>-- * The lazy @ByteString@ type and representation</span>
<span class=hs-linenum> 34: </span>        <span class='hs-conid'>ByteString</span><span class='hs-layout'>(</span><span class='hs-conid'>Empty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Chunk</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 35: </span>        <span class='hs-conid'>LazyByteString</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 36: </span>        <span class='hs-varid'>chunk</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 37: </span>        <span class='hs-varid'>foldrChunks</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 38: </span>        <span class='hs-varid'>foldlChunks</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 39: </span>
<span class=hs-linenum> 40: </span>        <span class='hs-comment'>-- * Data type invariant and abstraction function</span>
<span class=hs-linenum> 41: </span>        <span class='hs-varid'>invariant</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 42: </span>        <span class='hs-varid'>checkInvariant</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 43: </span>
<span class=hs-linenum> 44: </span>        <span class='hs-comment'>-- * Chunk allocation sizes</span>
<span class=hs-linenum> 45: </span>        <span class='hs-varid'>defaultChunkSize</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 46: </span>        <span class='hs-varid'>smallChunkSize</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 47: </span>        <span class='hs-varid'>chunkOverhead</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 48: </span>
<span class=hs-linenum> 49: </span>        <span class='hs-comment'>-- * Conversion with lists: packing and unpacking</span>
<span class=hs-linenum> 50: </span>        <span class='hs-varid'>packBytes</span><span class='hs-layout'>,</span> <span class='hs-varid'>packChars</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 51: </span>        <span class='hs-varid'>unpackBytes</span><span class='hs-layout'>,</span> <span class='hs-varid'>unpackChars</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 52: </span>        <span class='hs-comment'>-- * Conversions with strict ByteString</span>
<span class=hs-linenum> 53: </span>        <span class='hs-varid'>fromStrict</span><span class='hs-layout'>,</span> <span class='hs-varid'>toStrict</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 54: </span>
<span class=hs-linenum> 55: </span>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 56: </span>
<span class=hs-linenum> 57: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 58: </span>
<span class=hs-linenum> 59: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.ByteString.Internal.Type</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>S</span>
<span class=hs-linenum> 60: </span>
<span class=hs-linenum> 61: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Word</span> <span class='hs-layout'>(</span><span class='hs-conid'>Word8</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 62: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign.Storable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Storable</span><span class='hs-layout'>(</span><span class='hs-varid'>sizeOf</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 63: </span>
<span class=hs-linenum> 64: </span><span class='hs-cpp'>#if MIN_VERSION_base(4,13,0)</span>
<span class=hs-linenum> 65: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Semigroup</span>   <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>sconcat</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 66: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum> 67: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Semigroup</span>   <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>sconcat</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 68: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 69: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List.NonEmpty</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonEmpty</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conop'>:|</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 70: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.DeepSeq</span>  <span class='hs-layout'>(</span><span class='hs-conid'>NFData</span><span class='hs-layout'>,</span> <span class='hs-varid'>rnf</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 71: </span>
<span class=hs-linenum> 72: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.String</span>      <span class='hs-layout'>(</span><span class='hs-conid'>IsString</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 73: </span>
<span class=hs-linenum> 74: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Data</span>                <span class='hs-layout'>(</span><span class='hs-conid'>Data</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkConstr</span> <span class='hs-layout'>,</span><span class='hs-varid'>mkDataType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Constr</span><span class='hs-layout'>,</span> <span class='hs-conid'>DataType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Fixity</span><span class='hs-layout'>(</span><span class='hs-conid'>Prefix</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>constrIndex</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 75: </span>
<span class=hs-linenum> 76: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Exts</span>                 <span class='hs-layout'>(</span><span class='hs-conid'>IsList</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 77: </span>
<span class=hs-linenum> 78: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Language.Haskell.TH.Syntax</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TH</span>
<span class=hs-linenum> 79: </span>
<span class=hs-linenum> 80: </span><span class='hs-cpp'>#ifdef HS_BYTESTRING_ASSERTIONS</span>
<span class=hs-linenum> 81: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Exception</span> <span class='hs-layout'>(</span><span class='hs-varid'>assert</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 82: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum> 83: </span>
<span class=hs-linenum> 84: </span>
<span class=hs-linenum> 85: </span><span class='hs-comment'>-- | A space-efficient representation of a 'Word8' vector, supporting many</span>
<span class=hs-linenum> 86: </span><span class='hs-comment'>-- efficient operations.</span>
<span class=hs-linenum> 87: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 88: </span><span class='hs-comment'>-- A 'LazyByteString' contains 8-bit bytes, or by using the operations</span>
<span class=hs-linenum> 89: </span><span class='hs-comment'>-- from "Data.ByteString.Lazy.Char8" it can be interpreted as containing</span>
<span class=hs-linenum> 90: </span><span class='hs-comment'>-- 8-bit characters.</span>
<span class=hs-linenum> 91: </span><span class='hs-comment'>--</span>
<span class=hs-linenum> 92: </span><span class='hs-cpp'>#ifndef HS_BYTESTRING_ASSERTIONS</span>
<span class=hs-linenum> 93: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Chunk</span>  <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-conid'>S.StrictByteString</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum> 94: </span>  <span class='hs-comment'>-- INVARIANT: The S.StrictByteString field of any Chunk is not empty.</span>
<span class=hs-linenum> 95: </span>  <span class='hs-comment'>-- (See also the 'invariant' and 'checkInvariant' functions.)</span>
<span class=hs-linenum> 96: </span>
<span class=hs-linenum> 97: </span>  <span class='hs-comment'>-- To make testing of this invariant convenient, we add an</span>
<span class=hs-linenum> 98: </span>  <span class='hs-comment'>-- assertion to that effect when the HS_BYTESTRING_ASSERTIONS</span>
<span class=hs-linenum> 99: </span>  <span class='hs-comment'>-- preprocessor macro is defined, by renaming the actual constructor</span>
<span class=hs-linenum>100: </span>  <span class='hs-comment'>-- and providing a pattern synonym that does the checking:</span>
<span class=hs-linenum>101: </span><span class='hs-cpp'>#else</span>
<span class=hs-linenum>102: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Chunk_</span> <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-conid'>S.StrictByteString</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>103: </span>
<span class=hs-linenum>104: </span><span class='hs-definition'>pattern</span> <span class='hs-conid'>Chunk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>S.StrictByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>105: </span><span class='hs-definition'>pattern</span> <span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>Chunk_</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>106: </span>  <span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>assert</span> <span class='hs-layout'>(</span><span class='hs-varid'>len</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-conid'>Chunk_</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span>
<span class=hs-linenum>107: </span>
<span class=hs-linenum>108: </span><span class='hs-comment'>{-# COMPLETE Empty, Chunk #-}</span>
<span class=hs-linenum>109: </span><span class='hs-cpp'>#endif</span>
<span class=hs-linenum>110: </span>
<span class=hs-linenum>111: </span><a class=annot href="#"><span class=annottext>(Language.Haskell.TH.Syntax.Lift ('GHC.Types.BoxedRep 'GHC.Types.Lifted) Data.ByteString.Lazy.Internal.ByteString)</span><span class='hs-keyword'>deriving</span></a> <span class='hs-keyword'>instance</span> <span class='hs-conid'>TH.Lift</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>112: </span>
<span class=hs-linenum>113: </span>
<span class=hs-linenum>114: </span><span class='hs-comment'>-- | Type synonym for the lazy flavour of 'ByteString'.</span>
<span class=hs-linenum>115: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>116: </span><span class='hs-comment'>-- @since 0.11.2.0</span>
<span class=hs-linenum>117: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>LazyByteString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>118: </span>
<span class=hs-linenum>119: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Eq</span>  <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>120: </span>    <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq</span>
<span class=hs-linenum>121: </span>
<span class=hs-linenum>122: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>123: </span>    <span class='hs-varid'>compare</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cmp</span>
<span class=hs-linenum>124: </span>
<span class=hs-linenum>125: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(GHC.Base.Semigroup Data.ByteString.Lazy.Internal.ByteString)</span><span class='hs-conid'>Semigroup</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>126: </span>    <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>append</span>
<span class=hs-linenum>127: </span>    <a class=annot href="#"><span class=annottext>(GHC.Base.NonEmpty Data.ByteString.Lazy.Internal.ByteString) -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>sconcat</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:|</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[Data.ByteString.Lazy.Internal.ByteString] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>concat</span></a> <a class=annot href="#"><span class=annottext>{v : [Data.ByteString.Lazy.Internal.ByteString] | head v == b
                                                  &amp;&amp; len v == 1 + len bs
                                                  &amp;&amp; tail v == bs}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == b}</span><span class='hs-varid'>b</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{v : [Data.ByteString.Lazy.Internal.ByteString] | v == bs
                                                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>bs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>128: </span>    <a class=annot href="#"><span class=annottext>forall a .
(GHC.Real.Integral&lt;[]&gt; a) =&gt;
{VV : a | false} -&gt; {v : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>stimes</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>times</span>
<span class=hs-linenum>129: </span>
<span class=hs-linenum>130: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(GHC.Base.Monoid Data.ByteString.Lazy.Internal.ByteString)</span><span class='hs-conid'>Monoid</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>131: </span>    <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-varid'>mempty</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span>
<span class=hs-linenum>132: </span>    <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>mappend</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>
<span class=hs-linenum>133: </span>    <a class=annot href="#"><span class=annottext>[Data.ByteString.Lazy.Internal.ByteString] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>mconcat</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span>
<span class=hs-linenum>134: </span>
<span class=hs-linenum>135: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Control.DeepSeq.NFData Data.ByteString.Lazy.Internal.ByteString)</span><span class='hs-conid'>NFData</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>136: </span>    <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; ()</span><span class='hs-varid'>rnf</span></a> <span class='hs-conid'>Empty</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : () | v == ()}</span><span class='hs-conid'>()</span></a>
<span class=hs-linenum>137: </span>    <span class='hs-varid'>rnf</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Control.DeepSeq.NFData Data.ByteString.Lazy.Internal.ByteString)</span><span class='hs-varid'>rnf</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == b}</span><span class='hs-varid'>b</span></a>
<span class=hs-linenum>138: </span>
<span class=hs-linenum>139: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>140: </span>    <span class='hs-varid'>showsPrec</span> <span class='hs-varid'>p</span> <span class='hs-varid'>ps</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>showsPrec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-varid'>unpackChars</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span>
<span class=hs-linenum>141: </span>
<span class=hs-linenum>142: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>Read</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>143: </span>    <span class='hs-varid'>readsPrec</span> <span class='hs-varid'>p</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>packChars</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readsPrec</span> <span class='hs-varid'>p</span> <span class='hs-varid'>str</span> <span class='hs-keyglyph'>]</span>
<span class=hs-linenum>144: </span>
<span class=hs-linenum>145: </span><span class='hs-comment'>-- | @since 0.10.12.0</span>
<span class=hs-linenum>146: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(GHC.Exts.IsList Data.ByteString.Lazy.Internal.ByteString)</span><span class='hs-conid'>IsList</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>147: </span>  <span class='hs-keyword'>type</span> <span class='hs-conid'>Item</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Word8</span>
<span class=hs-linenum>148: </span>  <a class=annot href="#"><span class=annottext>[(GHC.Exts.Item Data.ByteString.Lazy.Internal.ByteString)] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>fromList</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>packBytes</span>
<span class=hs-linenum>149: </span>  <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; [(GHC.Exts.Item Data.ByteString.Lazy.Internal.ByteString)]</span><span class='hs-varid'>toList</span></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unpackBytes</span>
<span class=hs-linenum>150: </span>
<span class=hs-linenum>151: </span><span class='hs-comment'>-- | Beware: 'fromString' truncates multi-byte characters to octets.</span>
<span class=hs-linenum>152: </span><span class='hs-comment'>-- e.g. "枯朶に烏のとまりけり秋の暮" becomes �6k�nh~�Q��n�</span>
<span class=hs-linenum>153: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>(Data.String.IsString Data.ByteString.Lazy.Internal.ByteString)</span><span class='hs-conid'>IsString</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>154: </span>    <a class=annot href="#"><span class=annottext>[GHC.Types.Char] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>fromString</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>packChars</span>
<span class=hs-linenum>155: </span>
<span class=hs-linenum>156: </span><span class='hs-keyword'>instance</span> <a class=annot href="#"><span class=annottext>forall a .
(GHC.Base.MonadPlus&lt;[]&gt; a) =&gt;
(forall d .
 (Data.Data.Data&lt;[]&gt; d) =&gt;
 d -&gt; a d) -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; a Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Data</span></a> <span class='hs-conid'>ByteString</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>157: </span>  <a class=annot href="#"><span class=annottext>forall a .
(forall d b .
 (Data.Data.Data&lt;[]&gt; d) =&gt;
 a (d -&gt; b) -&gt; d -&gt; a b) -&gt; (forall g .
                             g -&gt; a g) -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; a Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>gfoldl</span></a> <a class=annot href="#"><span class=annottext>forall a b . (Data.Data.Data&lt;[]&gt; a) =&gt; c (a -&gt; b) -&gt; a -&gt; c b</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>forall a . a -&gt; b a</span><span class='hs-varid'>z</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>txt</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a [GHC.Word.Word8] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>z</span></a> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>packBytes</span></a> <span class='hs-varop'>`f`</span> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>unpackBytes</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == txt}</span><span class='hs-varid'>txt</span></a>
<span class=hs-linenum>158: </span>  <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; {v : Data.Data.Constr | false}</span><span class='hs-varid'>toConstr</span></a> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>packConstr</span>
<span class=hs-linenum>159: </span>  <a class=annot href="#"><span class=annottext>forall a .
(forall b r .
 (Data.Data.Data&lt;[]&gt; b) =&gt;
 a (b -&gt; r) -&gt; a r) -&gt; (forall r .
                        r -&gt; a r) -&gt; Data.Data.Constr -&gt; a Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>gunfold</span></a> <a class=annot href="#"><span class=annottext>forall a b . (Data.Data.Data&lt;[]&gt; a) =&gt; c (a -&gt; b) -&gt; c b</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>forall a . a -&gt; b a</span><span class='hs-varid'>z</span></a> <a class=annot href="#"><span class=annottext>Data.Data.Constr</span><span class='hs-varid'>c</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>constrIndex</span></a> <a class=annot href="#"><span class=annottext>{v : Data.Data.Constr | v == c}</span><span class='hs-varid'>c</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum>160: </span>    <span class='hs-num'>1</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : (Data.Data.Data [GHC.Word.Word8]) | v == $dData_aTlo}</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>a [GHC.Word.Word8] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varid'>z</span> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>packBytes</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>161: </span>    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Classes.IP [GHC.Types.Char] GHC.Stack.Types.CallStack) | v == $dIP_aTls}</span><span class='hs-varid'>error</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"gunfold: unexpected constructor of lazy ByteString"</span></a>
<span class=hs-linenum>162: </span>  <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; {v : Data.Data.DataType | false}</span><span class='hs-varid'>dataTypeOf</span></a> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>byteStringDataType</span>
<span class=hs-linenum>163: </span>
<span class=hs-linenum>164: </span><span class='hs-definition'>packConstr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Constr</span>
<span class=hs-linenum>165: </span><a class=annot href="#"><span class=annottext>{VV : Data.Data.Constr | false}</span><span class='hs-definition'>packConstr</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConstr</span> <a class=annot href="#"><span class=annottext>{VV : Data.Data.DataType | false}</span><span class='hs-varid'>byteStringDataType</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"pack"</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a> <a class=annot href="#"><span class=annottext>{v : Data.Data.Fixity | v == Prefix}</span><span class='hs-conid'>Prefix</span></a>
<span class=hs-linenum>166: </span>
<span class=hs-linenum>167: </span><span class='hs-definition'>byteStringDataType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataType</span>
<span class=hs-linenum>168: </span><a class=annot href="#"><span class=annottext>{VV : Data.Data.DataType | false}</span><span class='hs-definition'>byteStringDataType</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDataType</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Data.ByteString.Lazy.ByteString"</span></a> <a class=annot href="#"><span class=annottext>{v : [Data.Data.Constr] | head v == packConstr}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{VV : Data.Data.Constr | false}</span><span class='hs-varid'>packConstr</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>169: </span>
<span class=hs-linenum>170: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum>171: </span><span class='hs-comment'>-- Packing and unpacking from lists</span>
<span class=hs-linenum>172: </span>
<span class=hs-linenum>173: </span><span class='hs-definition'>packBytes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>174: </span><a class=annot href="#"><span class=annottext>[GHC.Word.Word8] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-definition'>packBytes</span></a> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>cs0</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>175: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Word.Word8] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>packChunks</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>32</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == cs0
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs0</span></a>
<span class=hs-linenum>176: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>177: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Word.Word8] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>packChunks</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-varid'>cs</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Internal.Type.ByteString, [GHC.Word.Word8])</span><span class='hs-conid'>S.packUptoLenBytes</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | v == cs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum>178: </span>      <span class='hs-layout'>(</span><span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-conid'>Empty</span></a>
<span class=hs-linenum>179: </span>      <span class='hs-layout'>(</span><span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varid'>packChunks</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>min</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == smallChunkSize}</span><span class='hs-varid'>smallChunkSize</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Word.Word8] | len v &gt;= 0}</span><span class='hs-varid'>cs'</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>180: </span>
<span class=hs-linenum>181: </span><span class='hs-definition'>packChars</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>182: </span><a class=annot href="#"><span class=annottext>[GHC.Types.Char] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-definition'>packChars</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>cs0</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Types.Char] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>packChunks</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>32</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == cs0
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs0</span></a>
<span class=hs-linenum>183: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>184: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; [GHC.Types.Char] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>packChunks</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>cs</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>(Data.ByteString.Internal.Type.ByteString, [GHC.Types.Char])</span><span class='hs-conid'>S.packUptoLenChars</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | v == cs
                        &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>cs</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum>185: </span>      <span class='hs-layout'>(</span><span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-conid'>Empty</span></a>
<span class=hs-linenum>186: </span>      <span class='hs-layout'>(</span><span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varid'>packChunks</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>min</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == n}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == smallChunkSize}</span><span class='hs-varid'>smallChunkSize</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | len v &gt;= 0}</span><span class='hs-varid'>cs'</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>187: </span>
<span class=hs-linenum>188: </span><span class='hs-definition'>unpackBytes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Word8</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>189: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; [GHC.Word.Word8]</span><span class='hs-definition'>unpackBytes</span></a> <span class='hs-conid'>Empty</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>190: </span><span class='hs-definition'>unpackBytes</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Word.Word8] -&gt; [GHC.Word.Word8]</span><span class='hs-conid'>S.unpackAppendBytesLazy</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>[GHC.Word.Word8]</span><span class='hs-layout'>(</span></a><span class='hs-varid'>unpackBytes</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>191: </span>
<span class=hs-linenum>192: </span><span class='hs-definition'>unpackChars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>193: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; [GHC.Types.Char]</span><span class='hs-definition'>unpackChars</span></a> <span class='hs-conid'>Empty</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>194: </span><span class='hs-definition'>unpackChars</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; [GHC.Types.Char] -&gt; [GHC.Types.Char]</span><span class='hs-conid'>S.unpackAppendCharsLazy</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-layout'>(</span></a><span class='hs-varid'>unpackChars</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>195: </span>
<span class=hs-linenum>196: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum>197: </span>
<span class=hs-linenum>198: </span><span class='hs-comment'>-- We no longer use these invariant-checking functions internally,</span>
<span class=hs-linenum>199: </span><span class='hs-comment'>-- preferring an assertion on `Chunk` itself, controlled by the</span>
<span class=hs-linenum>200: </span><span class='hs-comment'>-- HS_BYTESTRING_ASSERTIONS preprocessor macro.</span>
<span class=hs-linenum>201: </span>
<span class=hs-linenum>202: </span><span class='hs-comment'>-- | The data type invariant:</span>
<span class=hs-linenum>203: </span><span class='hs-comment'>-- Every ByteString is either 'Empty' or consists of non-null</span>
<span class=hs-linenum>204: </span><span class='hs-comment'>-- 'S.StrictByteString's. All functions must preserve this.</span>
<span class=hs-linenum>205: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>206: </span><span class='hs-definition'>invariant</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>207: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; GHC.Types.Bool</span><span class='hs-definition'>invariant</span></a> <span class='hs-conid'>Empty</span>                     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v
                      &amp;&amp; v == True}</span><span class='hs-conid'>True</span></a>
<span class=hs-linenum>208: </span><span class='hs-definition'>invariant</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTDb : int)}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len
                     &amp;&amp; v == (dt_dTDb : int)}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>invariant</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum>209: </span>
<span class=hs-linenum>210: </span><span class='hs-comment'>-- | Lazily checks that the given 'ByteString' satisfies the data type's</span>
<span class=hs-linenum>211: </span><span class='hs-comment'>-- "no empty chunks" invariant, raising an exception in place of the</span>
<span class=hs-linenum>212: </span><span class='hs-comment'>-- first chunk that does not satisfy the invariant.</span>
<span class=hs-linenum>213: </span><span class='hs-definition'>checkInvariant</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>214: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-definition'>checkInvariant</span></a> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-conid'>Empty</span></a>
<span class=hs-linenum>215: </span><span class='hs-definition'>checkInvariant</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span>
<span class=hs-linenum>216: </span>    <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTD8 : int)}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>&gt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varid'>checkInvariant</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>217: </span>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Char] | false} -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>error</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Data.ByteString.Lazy: invariant violation:"</span></a>
<span class=hs-linenum>218: </span>               <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-varid'>show</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Chunk</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c
                                                &amp;&amp; v == BS dt_dTD6 dt_dTD7 dt_dTD8}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>219: </span>
<span class=hs-linenum>220: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum>221: </span>
<span class=hs-linenum>222: </span><span class='hs-comment'>-- | Smart constructor for 'Chunk'. Guarantees the data type invariant.</span>
<span class=hs-linenum>223: </span><span class='hs-definition'>chunk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>S.StrictByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>224: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-definition'>chunk</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>c</span></a><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>cs</span></a> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTD5 : int)}</span><span class='hs-varid'>len</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum>225: </span>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c
                                                &amp;&amp; v == BS dt_dTD3 dt_dTD4 dt_dTD5}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum>226: </span><span class='hs-comment'>{-# INLINE chunk #-}</span>
<span class=hs-linenum>227: </span>
<span class=hs-linenum>228: </span><span class='hs-comment'>-- | Consume the chunks of a lazy ByteString with a natural right fold.</span>
<span class=hs-linenum>229: </span><span class='hs-definition'>foldrChunks</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>S.StrictByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>230: </span><a class=annot href="#"><span class=annottext>forall a .
(Data.ByteString.Internal.Type.ByteString -&gt; a -&gt; a) -&gt; a -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; a</span><span class='hs-definition'>foldrChunks</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; a -&gt; a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>z</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; a</span><span class='hs-varid'>go</span></a>
<span class=hs-linenum>231: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; a</span><span class='hs-varid'>go</span></a> <span class='hs-conid'>Empty</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == z}</span><span class='hs-varid'>z</span></a>
<span class=hs-linenum>232: </span>        <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; a -&gt; a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><span class='hs-varid'>go</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>233: </span><span class='hs-comment'>{-# INLINE foldrChunks #-}</span>
<span class=hs-linenum>234: </span>
<span class=hs-linenum>235: </span><span class='hs-comment'>-- | Consume the chunks of a lazy ByteString with a strict, tail-recursive,</span>
<span class=hs-linenum>236: </span><span class='hs-comment'>-- accumulating left fold.</span>
<span class=hs-linenum>237: </span><span class='hs-definition'>foldlChunks</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S.StrictByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>238: </span><a class=annot href="#"><span class=annottext>forall a .
(a -&gt; Data.ByteString.Internal.Type.ByteString -&gt; a) -&gt; a -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; a</span><span class='hs-definition'>foldlChunks</span></a> <a class=annot href="#"><span class=annottext>a -&gt; Data.ByteString.Internal.Type.ByteString -&gt; a</span><span class='hs-varid'>f</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; a</span><span class='hs-varid'>go</span></a>
<span class=hs-linenum>239: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>a -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; a</span><span class='hs-varid'>go</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>a</span></a> <span class='hs-conid'>Empty</span>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == a}</span><span class='hs-varid'>a</span></a>
<span class=hs-linenum>240: </span>        <span class='hs-varid'>go</span> <span class='hs-varop'>!</span><span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; a</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><span class='hs-varid'>f</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == a}</span><span class='hs-varid'>a</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c}</span><span class='hs-varid'>c</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum>241: </span><span class='hs-comment'>{-# INLINE foldlChunks #-}</span>
<span class=hs-linenum>242: </span>
<span class=hs-linenum>243: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum>244: </span>
<span class=hs-linenum>245: </span><span class='hs-comment'>-- The representation uses lists of packed chunks. When we have to convert from</span>
<span class=hs-linenum>246: </span><span class='hs-comment'>-- a lazy list to the chunked representation, then by default we use this</span>
<span class=hs-linenum>247: </span><span class='hs-comment'>-- chunk size. Some functions give you more control over the chunk size.</span>
<span class=hs-linenum>248: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>249: </span><span class='hs-comment'>-- Measurements here:</span>
<span class=hs-linenum>250: </span><span class='hs-comment'>--  <a href="http://www.cse.unsw.edu.au/~dons/tmp/chunksize_v_cache.png">http://www.cse.unsw.edu.au/~dons/tmp/chunksize_v_cache.png</a></span>
<span class=hs-linenum>251: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>252: </span><span class='hs-comment'>-- indicate that a value around 0.5 to 1 x your L2 cache is best.</span>
<span class=hs-linenum>253: </span><span class='hs-comment'>-- The following value assumes people have something greater than 128k,</span>
<span class=hs-linenum>254: </span><span class='hs-comment'>-- and need to share the cache with other programs.</span>
<span class=hs-linenum>255: </span>
<span class=hs-linenum>256: </span><span class='hs-comment'>-- | The chunk size used for I\/O. Currently set to 32k, less the memory management overhead</span>
<span class=hs-linenum>257: </span><span class='hs-definition'>defaultChunkSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>258: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-definition'>defaultChunkSize</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>32</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == k}</span><span class='hs-varid'>k</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == chunkOverhead}</span><span class='hs-varid'>chunkOverhead</span></a>
<span class=hs-linenum>259: </span>   <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 1024}</span><span class='hs-num'>1024</span></a>
<span class=hs-linenum>260: </span>
<span class=hs-linenum>261: </span><span class='hs-comment'>-- | The recommended chunk size. Currently set to 4k, less the memory management overhead</span>
<span class=hs-linenum>262: </span><span class='hs-definition'>smallChunkSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>263: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-definition'>smallChunkSize</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>4</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == k}</span><span class='hs-varid'>k</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == chunkOverhead}</span><span class='hs-varid'>chunkOverhead</span></a>
<span class=hs-linenum>264: </span>   <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 1024}</span><span class='hs-num'>1024</span></a>
<span class=hs-linenum>265: </span>
<span class=hs-linenum>266: </span><span class='hs-comment'>-- | The memory management overhead. Currently this is tuned for GHC only.</span>
<span class=hs-linenum>267: </span><span class='hs-definition'>chunkOverhead</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>268: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-definition'>chunkOverhead</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a> <span class='hs-varop'>*</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>sizeOf</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-varid'>undefined</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<span class=hs-linenum>269: </span>
<span class=hs-linenum>270: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum>271: </span><span class='hs-comment'>-- Implementations for Eq, Ord and Monoid instances</span>
<span class=hs-linenum>272: </span>
<span class=hs-linenum>273: </span><span class='hs-definition'>eq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>274: </span><a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; GHC.Types.Bool</span><span class='hs-definition'>eq</span></a> <span class='hs-conid'>Empty</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v
                      &amp;&amp; v == True}</span><span class='hs-conid'>True</span></a>
<span class=hs-linenum>275: </span><span class='hs-definition'>eq</span> <span class='hs-conid'>Empty</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not v
                      &amp;&amp; v == False}</span><span class='hs-conid'>False</span></a>
<span class=hs-linenum>276: </span><span class='hs-definition'>eq</span> <span class='hs-keyword'>_</span>     <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not v
                      &amp;&amp; v == False}</span><span class='hs-conid'>False</span></a>
<span class=hs-linenum>277: </span><span class='hs-definition'>eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>ap</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTCZ : int)}</span><span class='hs-varid'>al</span></a><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>bp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTD2 : int)}</span><span class='hs-varid'>bl</span></a><span class='hs-layout'>)</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>278: </span>  <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | (v == EQ &lt;=&gt; al == bl)
                          &amp;&amp; (v == GT &lt;=&gt; al &gt; bl)
                          &amp;&amp; (v == LT &lt;=&gt; al &lt; bl)}</span><span class='hs-varid'>compare</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCZ : int)}</span><span class='hs-varid'>al</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTD2 : int)}</span><span class='hs-varid'>bl</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum>279: </span>    <span class='hs-conid'>LT</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == a}</span><span class='hs-varid'>a</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-conid'>S.BS</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == bp}</span><span class='hs-varid'>bp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCZ : int)}</span><span class='hs-varid'>al</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>eq</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == as}</span><span class='hs-keyword'>as</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Chunk</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen bp - al
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.plusForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == bp}</span><span class='hs-varid'>bp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCZ : int)}</span><span class='hs-varid'>al</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl - al}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTD2 : int)}</span><span class='hs-varid'>bl</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCZ : int)}</span><span class='hs-varid'>al</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>280: </span>    <span class='hs-conid'>EQ</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == a}</span><span class='hs-varid'>a</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == b}</span><span class='hs-varid'>b</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>eq</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == as}</span><span class='hs-keyword'>as</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a>
<span class=hs-linenum>281: </span>    <span class='hs-conid'>GT</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-conid'>S.BS</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == ap}</span><span class='hs-varid'>ap</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTD2 : int)}</span><span class='hs-varid'>bl</span></a> <span class='hs-varop'>==</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == b}</span><span class='hs-varid'>b</span></a> <span class='hs-varop'>&amp;&amp;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>eq</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Chunk</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen ap - bl
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.plusForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == ap}</span><span class='hs-varid'>ap</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTD2 : int)}</span><span class='hs-varid'>bl</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al - bl}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCZ : int)}</span><span class='hs-varid'>al</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTD2 : int)}</span><span class='hs-varid'>bl</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == as}</span><span class='hs-keyword'>as</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a>
<span class=hs-linenum>282: </span>
<span class=hs-linenum>283: </span><span class='hs-definition'>cmp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<span class=hs-linenum>284: </span><a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; GHC.Types.Ordering</span><span class='hs-definition'>cmp</span></a> <span class='hs-conid'>Empty</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | v == EQ}</span><span class='hs-conid'>EQ</span></a>
<span class=hs-linenum>285: </span><span class='hs-definition'>cmp</span> <span class='hs-conid'>Empty</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | v == LT}</span><span class='hs-conid'>LT</span></a>
<span class=hs-linenum>286: </span><span class='hs-definition'>cmp</span> <span class='hs-keyword'>_</span>     <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | v == GT}</span><span class='hs-conid'>GT</span></a>
<span class=hs-linenum>287: </span><span class='hs-definition'>cmp</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>ap</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTCT : int)}</span><span class='hs-varid'>al</span></a><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>bp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTCW : int)}</span><span class='hs-varid'>bl</span></a><span class='hs-layout'>)</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>288: </span>  <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | (v == EQ &lt;=&gt; al == bl)
                          &amp;&amp; (v == GT &lt;=&gt; al &gt; bl)
                          &amp;&amp; (v == LT &lt;=&gt; al &lt; bl)}</span><span class='hs-varid'>compare</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCT : int)}</span><span class='hs-varid'>al</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTCW : int)}</span><span class='hs-varid'>bl</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum>289: </span>    <span class='hs-conid'>LT</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>GHC.Types.Ordering</span><span class='hs-varid'>compare</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == a}</span><span class='hs-varid'>a</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == bp}</span><span class='hs-varid'>bp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCT : int)}</span><span class='hs-varid'>al</span></a><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<span class=hs-linenum>290: </span>            <span class='hs-conid'>EQ</span>     <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; GHC.Types.Ordering</span><span class='hs-varid'>cmp</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == as}</span><span class='hs-keyword'>as</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Chunk</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen bp - al
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.plusForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == bp}</span><span class='hs-varid'>bp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCT : int)}</span><span class='hs-varid'>al</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl - al}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTCW : int)}</span><span class='hs-varid'>bl</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCT : int)}</span><span class='hs-varid'>al</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>291: </span>            <span class='hs-varid'>result</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Ordering</span><span class='hs-varid'>result</span></a>
<span class=hs-linenum>292: </span>    <span class='hs-conid'>EQ</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | (v == EQ &lt;=&gt; a == b)
                          &amp;&amp; (v == GT &lt;=&gt; a &gt; b)
                          &amp;&amp; (v == LT &lt;=&gt; a &lt; b)}</span><span class='hs-varid'>compare</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == a}</span><span class='hs-varid'>a</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == b}</span><span class='hs-varid'>b</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum>293: </span>            <span class='hs-conid'>EQ</span>     <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; GHC.Types.Ordering</span><span class='hs-varid'>cmp</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == as}</span><span class='hs-keyword'>as</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a>
<span class=hs-linenum>294: </span>            <span class='hs-varid'>result</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Ordering | (v == EQ &lt;=&gt; a == b)
                          &amp;&amp; (v == GT &lt;=&gt; a &gt; b)
                          &amp;&amp; (v == LT &lt;=&gt; a &lt; b)}</span><span class='hs-varid'>result</span></a>
<span class=hs-linenum>295: </span>    <span class='hs-conid'>GT</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>GHC.Types.Ordering</span><span class='hs-varid'>compare</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == ap}</span><span class='hs-varid'>ap</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTCW : int)}</span><span class='hs-varid'>bl</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == b}</span><span class='hs-varid'>b</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum>296: </span>            <span class='hs-conid'>EQ</span>     <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; GHC.Types.Ordering</span><span class='hs-varid'>cmp</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Chunk</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | fplen v == fplen ap - bl
                                                  &amp;&amp; 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.plusForeignPtr</span> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == ap}</span><span class='hs-varid'>ap</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTCW : int)}</span><span class='hs-varid'>bl</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al - bl}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == al
                     &amp;&amp; v == (dt_dTCT : int)}</span><span class='hs-varid'>al</span></a> <span class='hs-comment'>-</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTCW : int)}</span><span class='hs-varid'>bl</span></a><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == as}</span><span class='hs-keyword'>as</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a>
<span class=hs-linenum>297: </span>            <span class='hs-varid'>result</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Ordering</span><span class='hs-varid'>result</span></a>
<span class=hs-linenum>298: </span>
<span class=hs-linenum>299: </span><span class='hs-definition'>append</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>300: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-definition'>append</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>ys</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrChunks</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == ys}</span><span class='hs-varid'>ys</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == xs}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>301: </span>
<span class=hs-linenum>302: </span><span class='hs-definition'>concat</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ByteString</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>303: </span><a class=annot href="#"><span class=annottext>[Data.ByteString.Lazy.Internal.ByteString] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-definition'>concat</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[Data.ByteString.Lazy.Internal.ByteString] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>to</span></a>
<span class=hs-linenum>304: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>305: </span>    <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; [Data.ByteString.Lazy.Internal.ByteString] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>go</span></a> <span class='hs-conid'>Empty</span>        <a class=annot href="#"><span class=annottext>[Data.ByteString.Lazy.Internal.ByteString]</span><span class='hs-varid'>css</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[Data.ByteString.Lazy.Internal.ByteString] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>to</span></a> <a class=annot href="#"><span class=annottext>{v : [Data.ByteString.Lazy.Internal.ByteString] | v == css
                                                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>css</span></a>
<span class=hs-linenum>306: </span>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-varid'>css</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varid'>go</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a> <a class=annot href="#"><span class=annottext>{v : [Data.ByteString.Lazy.Internal.ByteString] | v == css
                                                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>css</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>307: </span>    <a class=annot href="#"><span class=annottext>[Data.ByteString.Lazy.Internal.ByteString] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>to</span></a> <span class='hs-conid'>[]</span>               <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-conid'>Empty</span></a>
<span class=hs-linenum>308: </span>    <span class='hs-varid'>to</span> <span class='hs-layout'>(</span><span class='hs-varid'>cs</span><span class='hs-conop'>:</span><span class='hs-varid'>css</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; [Data.ByteString.Lazy.Internal.ByteString] -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a> <a class=annot href="#"><span class=annottext>{v : [Data.ByteString.Lazy.Internal.ByteString] | v == css
                                                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>css</span></a>
<span class=hs-linenum>309: </span>
<span class=hs-linenum>310: </span><span class='hs-comment'>-- | Repeats the given ByteString n times.</span>
<span class=hs-linenum>311: </span><span class='hs-definition'>times</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ByteString</span>
<span class=hs-linenum>312: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Real.Integral&lt;[]&gt; a) =&gt;
{VV : a | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-definition'>times</span></a> <span class='hs-num'>0</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-conid'>Empty</span></a>
<span class=hs-linenum>313: </span><span class='hs-definition'>times</span> <span class='hs-varid'>n</span> <span class='hs-varid'>lbs0</span>
<span class=hs-linenum>314: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | false}</span><span class='hs-varid'>n</span></a> <span class='hs-varop'>&lt;</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-num'>0</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Classes.IP [GHC.Types.Char] GHC.Stack.Types.CallStack) | v == $dIP_aTfb}</span><span class='hs-varid'>error</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"stimes: non-negative multiplier expected"</span></a>
<span class=hs-linenum>315: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false}</span><span class='hs-varid'>lbs0</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum>316: </span>    <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-conid'>Empty</span></a>
<span class=hs-linenum>317: </span>    <span class='hs-conid'>Chunk</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>lbs</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == bs}</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varid'>go</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == lbs}</span><span class='hs-varid'>lbs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>318: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>319: </span>    <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>go</span></a> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a .
(GHC.Real.Integral&lt;[]&gt; a) =&gt;
{VV : a | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>times</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | false}</span><span class='hs-varid'>n</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>a</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false}</span><span class='hs-varid'>lbs0</span></a>
<span class=hs-linenum>320: </span>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-layout'>(</span></a><span class='hs-varid'>go</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>321: </span>
<span class=hs-linenum>322: </span><span class='hs-comment'>------------------------------------------------------------------------</span>
<span class=hs-linenum>323: </span><span class='hs-comment'>-- Conversions</span>
<span class=hs-linenum>324: </span>
<span class=hs-linenum>325: </span><span class='hs-comment'>-- |/O(1)/ Convert a 'S.StrictByteString' into a 'LazyByteString'.</span>
<span class=hs-linenum>326: </span><span class='hs-definition'>fromStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>S.StrictByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LazyByteString</span>
<span class=hs-linenum>327: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-definition'>fromStrict</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-conid'>Empty</span></a>
<span class=hs-linenum>328: </span><span class='hs-definition'>fromStrict</span> <span class='hs-varid'>bs</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-conid'>Chunk</span></a> <a class=annot href="#"><span class=annottext>Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>bs</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == Empty}</span><span class='hs-conid'>Empty</span></a>
<span class=hs-linenum>329: </span>
<span class=hs-linenum>330: </span><span class='hs-comment'>-- |/O(n)/ Convert a 'LazyByteString' into a 'S.StrictByteString'.</span>
<span class=hs-linenum>331: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>332: </span><span class='hs-comment'>-- Note that this is an /expensive/ operation that forces the whole</span>
<span class=hs-linenum>333: </span><span class='hs-comment'>-- 'LazyByteString' into memory and then copies all the data. If possible, try to</span>
<span class=hs-linenum>334: </span><span class='hs-comment'>-- avoid converting back and forth between strict and lazy bytestrings.</span>
<span class=hs-linenum>335: </span><span class='hs-comment'>--</span>
<span class=hs-linenum>336: </span><span class='hs-definition'>toStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LazyByteString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S.StrictByteString</span>
<span class=hs-linenum>337: </span><a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-definition'>toStrict</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {v : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>Data.ByteString.Lazy.Internal.ByteString</span><span class='hs-varid'>cs</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>goLen0</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum>338: </span>    <span class='hs-comment'>-- We pass the original [ByteString] (bss0) through as an argument through</span>
<span class=hs-linenum>339: </span>    <span class='hs-comment'>-- goLen0, goLen1, and goLen since we will need it again in goCopy. Passing</span>
<span class=hs-linenum>340: </span>    <span class='hs-comment'>-- it as an explicit argument avoids capturing it in these functions'</span>
<span class=hs-linenum>341: </span>    <span class='hs-comment'>-- closures which would result in unnecessary closure allocation.</span>
<span class=hs-linenum>342: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>343: </span>    <span class='hs-comment'>-- It's still possible that the result is empty</span>
<span class=hs-linenum>344: </span>    <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen0</span></a> <span class='hs-keyword'>_</span>   <span class='hs-conid'>Empty</span>                 <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; GHC.Types.Int -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-conid'>S.BS</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == nullForeignPtr}</span><span class='hs-conid'>S.nullForeignPtr</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>345: </span>    <span class='hs-varid'>goLen0</span> <span class='hs-varid'>cs0</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {v : Data.ByteString.Internal.Type.ByteString | false} -&gt; {v : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen1</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false}</span><span class='hs-varid'>cs0</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | v == c}</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum>346: </span>
<span class=hs-linenum>347: </span>    <span class='hs-comment'>-- It's still possible that the result is a single chunk</span>
<span class=hs-linenum>348: </span>    <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : Data.ByteString.Internal.Type.ByteString | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen1</span></a> <span class='hs-keyword'>_</span>   <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Internal.Type.ByteString | false}</span><span class='hs-varid'>bs</span></a>
<span class=hs-linenum>349: </span>    <span class='hs-varid'>goLen1</span> <span class='hs-varid'>cs0</span> <span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTCE : int)}</span><span class='hs-varid'>bl</span></a><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTCH : int)}</span><span class='hs-varid'>cl</span></a><span class='hs-layout'>)</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>350: </span>        <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {v : GHC.Types.Int | false} -&gt; {v : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false}</span><span class='hs-varid'>cs0</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.checkedAdd</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Lazy.toStrict"</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == bl
                     &amp;&amp; v == (dt_dTCE : int)}</span><span class='hs-varid'>bl</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == cl
                     &amp;&amp; v == (dt_dTCH : int)}</span><span class='hs-varid'>cl</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum>351: </span>
<span class=hs-linenum>352: </span>    <span class='hs-comment'>-- General case, just find the total length we'll need</span>
<span class=hs-linenum>353: </span>    <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : GHC.Types.Int | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen</span></a> <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false}</span><span class='hs-varid'>cs0</span></a> <span class='hs-varop'>!</span><a class=annot href="#"><span class=annottext>{VV : GHC.Types.Int | false}</span><span class='hs-varid'>total</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTCK : int)}</span><span class='hs-varid'>cl</span></a><span class='hs-layout'>)</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>354: </span>      <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : GHC.Types.Int | false} -&gt; {VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-varid'>goLen</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false}</span><span class='hs-varid'>cs0</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><span class='hs-conid'>S.checkedAdd</span> <a class=annot href="#"><span class=annottext>[GHC.Types.Char]</span><span class='hs-str'>"Lazy.toStrict"</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>total</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == cl
                     &amp;&amp; v == (dt_dTCK : int)}</span><span class='hs-varid'>cl</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a>
<span class=hs-linenum>355: </span>    <span class='hs-varid'>goLen</span> <span class='hs-varid'>cs0</span> <span class='hs-varid'>total</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>356: </span>      <a class=annot href="#"><span class=annottext>((GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) -&gt; (GHC.Types.IO ())) -&gt; Data.ByteString.Internal.Type.ByteString</span><span class='hs-conid'>S.unsafeCreateFp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | false}</span><span class='hs-varid'>total</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>{VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>goCopy</span> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | false}</span><span class='hs-varid'>cs0</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a>
<span class=hs-linenum>357: </span>
<span class=hs-linenum>358: </span>    <span class='hs-comment'>-- Copy the data</span>
<span class=hs-linenum>359: </span>    <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>goCopy</span></a> <span class='hs-conid'>Empty</span>                    <span class='hs-varop'>!</span><span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Base.Monad GHC.Types.IO) | v == $fMonadIO}</span><span class='hs-varid'>return</span></a> <a class=annot href="#"><span class=annottext>{v : () | v == ()}</span><span class='hs-conid'>()</span></a>
<span class=hs-linenum>360: </span>    <span class='hs-varid'>goCopy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <span class='hs-keyword'>_</span>  <span class='hs-num'>0</span>  <span class='hs-layout'>)</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><span class='hs-varid'>ptr</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : Data.ByteString.Lazy.Internal.ByteString | false} -&gt; {VV : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false} -&gt; (GHC.Types.IO ())</span><span class='hs-varid'>goCopy</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a>
<span class=hs-linenum>361: </span>    <span class='hs-varid'>goCopy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Chunk</span> <span class='hs-layout'>(</span><span class='hs-conid'>S.BS</span> <a class=annot href="#"><span class=annottext>(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8)</span><span class='hs-varid'>fp</span></a> <span class='hs-varid'>len</span><span class='hs-layout'>)</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><span class='hs-varid'>ptr</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class=hs-linenum>362: </span>      <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-conid'>S.memcpyFp</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | v == fp}</span><span class='hs-varid'>fp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTCN : int)}</span><span class='hs-varid'>len</span></a>
<span class=hs-linenum>363: </span>      <a class=annot href="#"><span class=annottext>(GHC.Types.IO ())</span><span class='hs-varid'>goCopy</span></a> <a class=annot href="#"><span class=annottext>{v : Data.ByteString.Lazy.Internal.ByteString | v == cs}</span><span class='hs-varid'>cs</span></a> <a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | 0 &lt;= fplen v}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) | false}</span><span class='hs-varid'>ptr</span></a> <span class='hs-varop'>`S.plusForeignPtr`</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (dt_dTCN : int)}</span><span class='hs-varid'>len</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>364: </span><span class='hs-comment'>-- See the comment on Data.ByteString.Internal.concat for some background on</span>
<span class=hs-linenum>365: </span><span class='hs-comment'>-- this implementation.</span>
</pre>
</body>
</html>